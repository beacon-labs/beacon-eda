
// Generated from VerilogParser.g4 by ANTLR 4.11.1


#include "VerilogParserVisitor.h"

#include "VerilogParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct VerilogParserStaticData final {
  VerilogParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  VerilogParserStaticData(const VerilogParserStaticData&) = delete;
  VerilogParserStaticData(VerilogParserStaticData&&) = delete;
  VerilogParserStaticData& operator=(const VerilogParserStaticData&) = delete;
  VerilogParserStaticData& operator=(VerilogParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag verilogparserParserOnceFlag;
VerilogParserStaticData *verilogparserParserStaticData = nullptr;

void verilogparserParserInitialize() {
  assert(verilogparserParserStaticData == nullptr);
  auto staticData = std::make_unique<VerilogParserStaticData>(
    std::vector<std::string>{
      "library_text", "library_description", "library_declaration", "library_incdir", 
      "include_statement", "file_path_spec", "source_text", "description", 
      "module_declaration", "module_keyword", "module_parameter_port_list", 
      "list_of_port_declarations", "port", "port_implicit", "port_explicit", 
      "port_expression", "port_reference", "port_declaration", "module_item", 
      "module_or_generate_item", "module_or_generate_item_declaration", 
      "parameter_override", "config_declaration", "design_statement", "design_statement_item", 
      "config_rule_statement", "default_clause", "inst_clause", "inst_name", 
      "cell_clause", "liblist_clause", "use_clause", "local_parameter_declaration", 
      "parameter_declaration", "specparam_declaration", "parameter_type", 
      "inout_declaration", "input_declaration", "output_declaration", "event_declaration", 
      "integer_declaration", "net_declaration", "real_declaration", "realtime_declaration", 
      "reg_declaration", "time_declaration", "net_type", "output_variable_type", 
      "real_type", "variable_type", "drive_strength", "strength0", "strength1", 
      "charge_strength", "delay3", "delay2", "delay_value", "list_of_defparam_assignments", 
      "list_of_event_identifiers", "event_id", "list_of_net_decl_assignments", 
      "list_of_net_identifiers", "net_id", "list_of_param_assignments", 
      "list_of_port_identifiers", "list_of_real_identifiers", "list_of_specparam_assignments", 
      "list_of_variable_identifiers", "list_of_variable_port_identifiers", 
      "var_port_id", "defparam_assignment", "net_decl_assignment", "param_assignment", 
      "specparam_assignment", "pulse_control_specparam", "error_limit_value", 
      "reject_limit_value", "limit_value", "dimension", "range_", "function_declaration", 
      "function_item_declaration", "function_port_list", "func_port_item", 
      "function_range_or_type", "task_declaration", "task_item_declaration", 
      "task_port_list", "task_port_item", "tf_input_declaration", "tf_output_declaration", 
      "tf_inout_declaration", "task_port_type", "block_item_declaration", 
      "list_of_block_variable_identifiers", "list_of_block_real_identifiers", 
      "block_variable_type", "block_real_type", "gate_instantiation", "cmos_switch_instance", 
      "enable_gate_instance", "mos_switch_instance", "n_input_gate_instance", 
      "n_output_gate_instance", "pass_switch_instance", "pass_enable_switch_instance", 
      "pull_gate_instance", "name_of_gate_instance", "pulldown_strength", 
      "pullup_strength", "enable_terminal", "inout_terminal", "input_terminal", 
      "ncontrol_terminal", "output_terminal", "pcontrol_terminal", "cmos_switchtype", 
      "enable_gatetype", "mos_switchtype", "n_input_gatetype", "n_output_gatetype", 
      "pass_en_switchtype", "pass_switchtype", "module_instantiation", "parameter_value_assignment", 
      "list_of_parameter_assignments", "ordered_parameter_assignment", "named_parameter_assignment", 
      "module_instance", "name_of_module_instance", "list_of_port_connections", 
      "ordered_port_connection", "named_port_connection", "generate_region", 
      "genvar_declaration", "list_of_genvar_identifiers", "loop_generate_construct", 
      "genvar_initialization", "genvar_expression", "genvar_iteration", 
      "conditional_generate_construct", "if_generate_construct", "case_generate_construct", 
      "case_generate_item", "generate_block", "generate_block_name", "generate_block_or_null", 
      "udp_declaration", "udp_port_list", "udp_declaration_port_list", "udp_port_declaration", 
      "udp_output_declaration", "udp_input_declaration", "udp_reg_declaration", 
      "udp_body", "combinational_body", "combinational_entry", "sequential_body", 
      "udp_initial_statement", "init_val", "sequential_entry", "seq_input_list", 
      "level_input_list", "edge_input_list", "edge_indicator", "current_state", 
      "next_state", "output_symbol", "level_symbol", "edge_symbol", "udp_instantiation", 
      "udp_instance", "name_of_udp_instance", "continuous_assign", "list_of_net_assignments", 
      "net_assignment", "initial_construct", "always_construct", "blocking_assignment", 
      "nonblocking_assignment", "procedural_continuous_assignments", "variable_assignment", 
      "par_block", "block_name", "seq_block", "statement", "statement_or_null", 
      "function_statement", "delay_control", "delay_or_event_control", "disable_statement", 
      "event_control", "event_trigger", "event_expression", "procedural_timing_control", 
      "procedural_timing_control_statement", "wait_statement", "conditional_statement", 
      "case_statement", "case_item", "loop_statement", "system_task_enable", 
      "sys_task_en_port_list", "sys_task_en_port_item", "task_enable", "task_en_port_list", 
      "specify_block", "specify_item", "pulsestyle_declaration", "showcancelled_declaration", 
      "path_declaration", "simple_path_declaration", "parallel_path_description", 
      "full_path_description", "list_of_path_inputs", "list_of_path_outputs", 
      "specify_input_terminal_descriptor", "specify_output_terminal_descriptor", 
      "input_identifier", "output_identifier", "path_delay_value", "list_of_path_delay_expressions", 
      "t_path_delay_expression", "trise_path_delay_expression", "tfall_path_delay_expression", 
      "tz_path_delay_expression", "t01_path_delay_expression", "t10_path_delay_expression", 
      "t0z_path_delay_expression", "tz1_path_delay_expression", "t1z_path_delay_expression", 
      "tz0_path_delay_expression", "t0x_path_delay_expression", "tx1_path_delay_expression", 
      "t1x_path_delay_expression", "tx0_path_delay_expression", "txz_path_delay_expression", 
      "tzx_path_delay_expression", "path_delay_expression", "edge_sensitive_path_declaration", 
      "parallel_edge_sensitive_path_description", "full_edge_sensitive_path_description", 
      "data_source_expression", "edge_identifier", "state_dependent_path_declaration", 
      "polarity_operator", "system_timing_check", "setup_timing_check", 
      "notifier_opt", "hold_timing_check", "setuphold_timing_check", "timing_check_opt", 
      "stamptime_cond_opt", "checktime_cond_opt", "delayed_ref_opt", "delayed_data_opt", 
      "recovery_timing_check", "removal_timing_check", "recrem_timing_check", 
      "skew_timing_check", "timeskew_timing_check", "skew_timing_check_opt", 
      "event_based_flag_opt", "remain_active_flag_opt", "fullskew_timing_check", 
      "period_timing_check", "width_timing_check", "threshold_opt", "nochange_timing_check", 
      "checktime_condition", "controlled_reference_event", "data_event", 
      "delayed_data", "delayed_reference", "end_edge_offset", "event_based_flag", 
      "notifier", "reference_event", "remain_active_flag", "stamptime_condition", 
      "start_edge_offset", "threshold", "timing_check_limit", "timing_check_event", 
      "controlled_timing_check_event", "timing_check_event_control", "specify_terminal_descriptor", 
      "edge_control_specifier", "edge_descriptor", "timing_check_condition", 
      "scalar_timing_check_condition", "scalar_constant", "concatenation", 
      "constant_concatenation", "constant_multiple_concatenation", "module_path_concatenation", 
      "module_path_multiple_concatenation", "multiple_concatenation", "constant_function_call", 
      "constant_system_function_call", "function_call", "system_function_call", 
      "sys_func_call_port_list", "base_expression", "constant_base_expression", 
      "constant_expression", "constant_mintypmax_expression", "constant_range_expression", 
      "dimension_constant_expression", "expression", "lsb_constant_expression", 
      "mintypmax_expression", "module_path_expression", "module_path_mintypmax_expression", 
      "msb_constant_expression", "range_expression", "width_constant_expression", 
      "constant_primary", "module_path_primary", "primary", "select_", "bit_select", 
      "net_lvalue", "const_select", "const_bit_select", "variable_lvalue", 
      "unary_operator", "unary_module_path_operator", "number", "real_number", 
      "decimal_number", "binary_number", "octal_number", "hex_number", "size", 
      "fixed_point_number", "exponential_number", "unsigned_number", "decimal_value", 
      "binary_value", "octal_value", "hex_value", "decimal_base", "binary_base", 
      "octal_base", "hex_base", "string_", "attribute_instance", "attr_spec", 
      "attr_name", "block_identifier", "cell_identifier", "config_identifier", 
      "escaped_identifier", "event_identifier", "function_identifier", "gate_instance_identifier", 
      "generate_block_identifier", "genvar_identifier", "hierarchical_identifier", 
      "hier_ref", "identifier", "input_port_identifier", "instance_identifier", 
      "library_identifier", "module_identifier", "module_instance_identifier", 
      "net_identifier", "output_port_identifier", "parameter_identifier", 
      "port_identifier", "real_identifier", "simple_identifier", "specparam_identifier", 
      "system_function_identifier", "system_task_identifier", "task_identifier", 
      "terminal_identifier", "topmodule_identifier", "udp_identifier", "udp_instance_identifier", 
      "variable_identifier"
    },
    std::vector<std::string>{
      "", "'always'", "'&'", "'&&'", "'&&&'", "'and'", "'*'", "'**'", "'*>'", 
      "'assign'", "'@'", "'automatic'", "'begin'", "'buf'", "'bufif1'", 
      "'bufif0'", "'^'", "'case'", "'casex'", "'casez'", "'^~'", "'cell'", 
      "':'", "'cmos'", "','", "'config'", "'deassign'", "'default'", "'defparam'", 
      "'design'", "'disable'", "'$'", "'$fullskew'", "'$hold'", "'$nochange'", 
      "'$period'", "'$recovery'", "'$recrem'", "'$removal'", "'$setup'", 
      "'$setuphold'", "'$skew'", "'$timeskew'", "'$width'", "'\"'", "'.'", 
      "'edge'", "'else'", "'!'", "'!='", "'!=='", "'end'", "'endcase'", 
      "'endconfig'", "'endfunction'", "'endgenerate'", "'endmodule'", "'endprimitive'", 
      "'endspecify'", "'endtable'", "'endtask'", "'='", "'=='", "'==='", 
      "'=>'", "'event'", "'for'", "'force'", "'forever'", "'fork'", "'function'", 
      "", "'generate'", "'genvar'", "'>'", "'>='", "'>>'", "'>>>'", "'#'", 
      "'highz1'", "'highz0'", "'if'", "'ifnone'", "'include'", "'initial'", 
      "'inout'", "'input'", "'instance'", "'integer'", "'join'", "'large'", 
      "'['", "'{'", "'liblist'", "'library'", "'localparam'", "'('", "'<'", 
      "'<='", "'<<'", "'<<<'", "'macromodule'", "'medium'", "'-'", "'-:'", 
      "'->'", "'-incdir'", "'%'", "'module'", "'nand'", "'negedge'", "'nmos'", 
      "'nor'", "'noshowcancelled'", "'not'", "'notif1'", "'notif0'", "'or'", 
      "'output'", "'parameter'", "'PATHPULSE$'", "'+'", "'+:'", "'pmos'", 
      "'posedge'", "'primitive'", "'pulldown'", "'pull1'", "'pullup'", "'pull0'", 
      "'pulsestyle_ondetect'", "'pulsestyle_onevent'", "'\\u003F'", "']'", 
      "'}'", "'rcmos'", "'real'", "'realtime'", "'reg'", "'release'", "'repeat'", 
      "'rnmos'", "')'", "'rpmos'", "'rtran'", "'rtranif1'", "'rtranif0'", 
      "';'", "'scalared'", "'showcancelled'", "'signed'", "'/'", "'small'", 
      "'specify'", "'specparam'", "'strong1'", "'strong0'", "'supply1'", 
      "'supply0'", "'table'", "'task'", "'~'", "'~&'", "'~^'", "'time'", 
      "'~|'", "'tran'", "'tranif1'", "'tranif0'", "'tri'", "'triand'", "'tri1'", 
      "'trior'", "'trireg'", "'tri0'", "'use'", "'uwire'", "'vectored'", 
      "'|'", "'||'", "'wait'", "'wand'", "'weak1'", "'weak0'", "'while'", 
      "'wire'", "'wor'", "'xnor'", "'xor'", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'celldefine'", 
      "", "", "", "", "'end_keywords'", "'endcelldefine'", "", "", "", "", 
      "", "'nounconnected_drive'", "", "'resetall'", "", "", "", "", "", 
      "", "", "", "", "", "'``'", "", "'`\\`\"'", "'`\"'"
    },
    std::vector<std::string>{
      "", "ALWAYS", "AM", "AMAM", "AMAMAM", "AND", "AS", "ASAS", "ASGT", 
      "ASSIGN", "AT", "AUTOMATIC", "BEGIN", "BUF", "BUFIFONE", "BUFIFZERO", 
      "CA", "CASE", "CASEX", "CASEZ", "CATI", "CELL", "CL", "CMOS", "CO", 
      "CONFIG", "DEASSIGN", "DEFAULT", "DEFPARAM", "DESIGN", "DISABLE", 
      "DL", "DLFULLSKEW", "DLHOLD", "DLNOCHANGE", "DLPERIOD", "DLRECOVERY", 
      "DLRECREM", "DLREMOVAL", "DLSETUP", "DLSETUPHOLD", "DLSKEW", "DLTIMESKEW", 
      "DLWIDTH", "DQ", "DT", "EDGE", "ELSE", "EM", "EMEQ", "EMEQEQ", "END", 
      "ENDCASE", "ENDCONFIG", "ENDFUNCTION", "ENDGENERATE", "ENDMODULE", 
      "ENDPRIMITIVE", "ENDSPECIFY", "ENDTABLE", "ENDTASK", "EQ", "EQEQ", 
      "EQEQEQ", "EQGT", "EVENT", "FOR", "FORCE", "FOREVER", "FORK", "FUNCTION", 
      "GA", "GENERATE", "GENVAR", "GT", "GTEQ", "GTGT", "GTGTGT", "HA", 
      "HIGHZONE", "HIGHZZERO", "IF", "IFNONE", "INCLUDE", "INITIAL", "INOUT", 
      "INPUT", "INSTANCE", "INTEGER", "JOIN", "LARGE", "LB", "LC", "LIBLIST", 
      "LIBRARY", "LOCALPARAM", "LP", "LT", "LTEQ", "LTLT", "LTLTLT", "MACROMODULE", 
      "MEDIUM", "MI", "MICL", "MIGT", "MIINCDIR", "MO", "MODULE", "NAND", 
      "NEGEDGE", "NMOS", "NOR", "NOSHOWCANCELLED", "NOT", "NOTIFONE", "NOTIFZERO", 
      "OR", "OUTPUT", "PARAMETER", "PATHPULSEDL", "PL", "PLCL", "PMOS", 
      "POSEDGE", "PRIMITIVE", "PULLDOWN", "PULLONE", "PULLUP", "PULLZERO", 
      "PULSESTYLE_ONDETECT", "PULSESTYLE_ONEVENT", "QM", "RB", "RC", "RCMOS", 
      "REAL", "REALTIME", "REG", "RELEASE", "REPEAT", "RNMOS", "RP", "RPMOS", 
      "RTRAN", "RTRANIFONE", "RTRANIFZERO", "SC", "SCALARED", "SHOWCANCELLED", 
      "SIGNED", "SL", "SMALL", "SPECIFY", "SPECPARAM", "STRONGONE", "STRONGZERO", 
      "SUPPLYONE", "SUPPLYZERO", "TABLE", "TASK", "TI", "TIAM", "TICA", 
      "TIME", "TIVL", "TRAN", "TRANIFONE", "TRANIFZERO", "TRI", "TRIAND", 
      "TRIONE", "TRIOR", "TRIREG", "TRIZERO", "USE", "UWIRE", "VECTORED", 
      "VL", "VLVL", "WAIT", "WAND", "WEAKONE", "WEAKZERO", "WHILE", "WIRE", 
      "WOR", "XNOR", "XOR", "BINARY_BASE", "COMMENT", "DECIMAL_BASE", "ESCAPED_IDENTIFIER", 
      "EXPONENTIAL_NUMBER", "FIXED_POINT_NUMBER", "HEX_BASE", "OCTAL_BASE", 
      "SIMPLE_IDENTIFIER", "STRING", "SYSTEM_TF_IDENTIFIER", "UNSIGNED_NUMBER", 
      "WHITE_SPACE", "BINARY_VALUE", "X_OR_Z_UNDERSCORE", "EDGE_DESCRIPTOR", 
      "HEX_VALUE", "FILE_PATH_SPEC", "OCTAL_VALUE", "EDGE_SYMBOL", "LEVEL_ONLY_SYMBOL", 
      "OUTPUT_OR_LEVEL_SYMBOL", "BEGIN_KEYWORDS_DIRECTIVE", "CELLDEFINE_DIRECTIVE", 
      "DEFAULT_NETTYPE_DIRECTIVE", "DEFINE_DIRECTIVE", "ELSE_DIRECTIVE", 
      "ELSIF_DIRECTIVE", "END_KEYWORDS_DIRECTIVE", "ENDCELLDEFINE_DIRECTIVE", 
      "ENDIF_DIRECTIVE", "IFDEF_DIRECTIVE", "IFNDEF_DIRECTIVE", "INCLUDE_DIRECTIVE", 
      "LINE_DIRECTIVE", "NOUNCONNECTED_DRIVE_DIRECTIVE", "PRAGMA_DIRECTIVE", 
      "RESETALL_DIRECTIVE", "TIMESCALE_DIRECTIVE", "UNCONNECTED_DRIVE_DIRECTIVE", 
      "UNDEF_DIRECTIVE", "MACRO_USAGE", "VERSION_SPECIFIER", "DEFAULT_NETTYPE_VALUE", 
      "COMMENT_5", "MACRO_NAME", "WHITE_SPACE_7", "FILENAME", "MACRO_DELIMITER", 
      "MACRO_ESC_NEWLINE", "MACRO_ESC_QUOTE", "MACRO_QUOTE", "MACRO_TEXT", 
      "SOURCE_TEXT", "TIME_UNIT", "TIME_VALUE", "UNCONNECTED_DRIVE_VALUE", 
      "MACRO_IDENTIFIER"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,246,4544,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,
  	7,134,2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,
  	7,140,2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,
  	7,146,2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,
  	7,152,2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,
  	7,158,2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,
  	7,164,2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,
  	7,170,2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,
  	7,176,2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,
  	7,182,2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,
  	7,188,2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,
  	7,194,2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,
  	7,200,2,201,7,201,2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,
  	7,206,2,207,7,207,2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,
  	7,212,2,213,7,213,2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,
  	7,218,2,219,7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,
  	7,224,2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,
  	7,230,2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,2,236,
  	7,236,2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,7,241,2,242,
  	7,242,2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,2,247,7,247,2,248,
  	7,248,2,249,7,249,2,250,7,250,2,251,7,251,2,252,7,252,2,253,7,253,2,254,
  	7,254,2,255,7,255,2,256,7,256,2,257,7,257,2,258,7,258,2,259,7,259,2,260,
  	7,260,2,261,7,261,2,262,7,262,2,263,7,263,2,264,7,264,2,265,7,265,2,266,
  	7,266,2,267,7,267,2,268,7,268,2,269,7,269,2,270,7,270,2,271,7,271,2,272,
  	7,272,2,273,7,273,2,274,7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,
  	7,278,2,279,7,279,2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,
  	7,284,2,285,7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,
  	7,290,2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,
  	7,296,2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,2,302,
  	7,302,2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,7,307,2,308,
  	7,308,2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,2,313,7,313,2,314,
  	7,314,2,315,7,315,2,316,7,316,2,317,7,317,2,318,7,318,2,319,7,319,2,320,
  	7,320,2,321,7,321,2,322,7,322,2,323,7,323,2,324,7,324,2,325,7,325,2,326,
  	7,326,2,327,7,327,2,328,7,328,2,329,7,329,2,330,7,330,2,331,7,331,2,332,
  	7,332,2,333,7,333,2,334,7,334,2,335,7,335,2,336,7,336,2,337,7,337,2,338,
  	7,338,2,339,7,339,2,340,7,340,2,341,7,341,2,342,7,342,2,343,7,343,2,344,
  	7,344,2,345,7,345,2,346,7,346,2,347,7,347,2,348,7,348,2,349,7,349,2,350,
  	7,350,2,351,7,351,2,352,7,352,2,353,7,353,2,354,7,354,2,355,7,355,2,356,
  	7,356,2,357,7,357,2,358,7,358,2,359,7,359,2,360,7,360,2,361,7,361,2,362,
  	7,362,2,363,7,363,2,364,7,364,2,365,7,365,2,366,7,366,2,367,7,367,2,368,
  	7,368,2,369,7,369,2,370,7,370,2,371,7,371,2,372,7,372,2,373,7,373,2,374,
  	7,374,2,375,7,375,2,376,7,376,2,377,7,377,2,378,7,378,2,379,7,379,2,380,
  	7,380,2,381,7,381,1,0,5,0,766,8,0,10,0,12,0,769,9,0,1,0,1,0,1,1,1,1,1,
  	1,3,1,776,8,1,1,2,1,2,1,2,1,2,1,2,5,2,783,8,2,10,2,12,2,786,9,2,1,2,3,
  	2,789,8,2,1,2,1,2,1,3,1,3,1,3,1,3,5,3,797,8,3,10,3,12,3,800,9,3,1,4,1,
  	4,1,4,1,4,1,5,1,5,1,6,5,6,809,8,6,10,6,12,6,812,9,6,1,6,1,6,1,7,1,7,1,
  	7,3,7,819,8,7,1,8,5,8,822,8,8,10,8,12,8,825,9,8,1,8,1,8,1,8,3,8,830,8,
  	8,1,8,3,8,833,8,8,1,8,1,8,5,8,837,8,8,10,8,12,8,840,9,8,1,8,1,8,1,9,1,
  	9,1,10,1,10,1,10,1,10,1,10,5,10,851,8,10,10,10,12,10,854,9,10,1,10,1,
  	10,1,11,1,11,1,11,1,11,5,11,862,8,11,10,11,12,11,865,9,11,1,11,1,11,1,
  	11,1,11,1,11,1,11,4,11,873,8,11,11,11,12,11,874,1,11,1,11,1,11,1,11,1,
  	11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,3,11,889,8,11,1,12,3,12,892,8,12,
  	1,12,3,12,895,8,12,1,13,1,13,1,14,1,14,1,14,1,14,3,14,903,8,14,1,14,1,
  	14,1,15,1,15,1,15,1,15,1,15,5,15,912,8,15,10,15,12,15,915,9,15,1,15,1,
  	15,3,15,919,8,15,1,16,1,16,1,16,1,16,1,16,3,16,926,8,16,1,17,5,17,929,
  	8,17,10,17,12,17,932,9,17,1,17,1,17,5,17,936,8,17,10,17,12,17,939,9,17,
  	1,17,1,17,5,17,943,8,17,10,17,12,17,946,9,17,1,17,3,17,949,8,17,1,18,
  	1,18,1,18,1,18,1,18,1,18,1,18,5,18,958,8,18,10,18,12,18,961,9,18,1,18,
  	1,18,1,18,1,18,5,18,967,8,18,10,18,12,18,970,9,18,1,18,3,18,973,8,18,
  	1,19,5,19,976,8,19,10,19,12,19,979,9,19,1,19,1,19,5,19,983,8,19,10,19,
  	12,19,986,9,19,1,19,1,19,1,19,1,19,5,19,992,8,19,10,19,12,19,995,9,19,
  	1,19,1,19,5,19,999,8,19,10,19,12,19,1002,9,19,1,19,1,19,5,19,1006,8,19,
  	10,19,12,19,1009,9,19,1,19,1,19,5,19,1013,8,19,10,19,12,19,1016,9,19,
  	1,19,1,19,5,19,1020,8,19,10,19,12,19,1023,9,19,1,19,1,19,5,19,1027,8,
  	19,10,19,12,19,1030,9,19,1,19,1,19,5,19,1034,8,19,10,19,12,19,1037,9,
  	19,1,19,1,19,5,19,1041,8,19,10,19,12,19,1044,9,19,1,19,1,19,5,19,1048,
  	8,19,10,19,12,19,1051,9,19,1,19,3,19,1054,8,19,1,20,1,20,1,20,1,20,1,
  	20,1,20,1,20,1,20,1,20,1,20,3,20,1066,8,20,1,21,1,21,1,21,1,21,1,22,1,
  	22,1,22,1,22,1,22,5,22,1077,8,22,10,22,12,22,1080,9,22,1,22,1,22,1,23,
  	1,23,5,23,1086,8,23,10,23,12,23,1089,9,23,1,23,1,23,1,24,1,24,1,24,3,
  	24,1096,8,24,1,24,1,24,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,
  	25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,1,25,3,25,1120,8,25,1,
  	26,1,26,1,27,1,27,1,27,1,28,1,28,1,28,5,28,1130,8,28,10,28,12,28,1133,
  	9,28,1,29,1,29,1,29,1,29,3,29,1139,8,29,1,29,1,29,1,30,1,30,5,30,1145,
  	8,30,10,30,12,30,1148,9,30,1,31,1,31,1,31,1,31,3,31,1154,8,31,1,31,1,
  	31,1,31,3,31,1159,8,31,1,32,1,32,3,32,1163,8,32,1,32,3,32,1166,8,32,1,
  	32,1,32,1,32,1,32,1,32,3,32,1173,8,32,1,33,1,33,3,33,1177,8,33,1,33,3,
  	33,1180,8,33,1,33,1,33,1,33,1,33,1,33,3,33,1187,8,33,1,34,1,34,3,34,1191,
  	8,34,1,34,1,34,1,34,1,35,1,35,1,36,1,36,3,36,1200,8,36,1,36,3,36,1203,
  	8,36,1,36,3,36,1206,8,36,1,36,1,36,1,37,1,37,3,37,1212,8,37,1,37,3,37,
  	1215,8,37,1,37,3,37,1218,8,37,1,37,1,37,1,38,1,38,3,38,1224,8,38,1,38,
  	3,38,1227,8,38,1,38,3,38,1230,8,38,1,38,1,38,1,38,1,38,3,38,1236,8,38,
  	1,38,3,38,1239,8,38,1,38,1,38,1,38,1,38,1,38,3,38,1246,8,38,1,39,1,39,
  	1,39,1,39,1,40,1,40,1,40,1,40,1,41,1,41,3,41,1258,8,41,1,41,3,41,1261,
  	8,41,1,41,1,41,1,41,1,41,1,41,3,41,1268,8,41,1,41,3,41,1271,8,41,1,41,
  	3,41,1274,8,41,1,41,1,41,1,41,1,41,1,41,3,41,1281,8,41,1,41,3,41,1284,
  	8,41,1,41,1,41,3,41,1288,8,41,1,41,1,41,1,41,1,41,1,41,3,41,1295,8,41,
  	1,41,3,41,1298,8,41,1,41,3,41,1301,8,41,1,41,1,41,3,41,1305,8,41,1,41,
  	1,41,1,41,1,41,1,41,3,41,1312,8,41,1,41,3,41,1315,8,41,1,41,3,41,1318,
  	8,41,1,41,1,41,1,41,1,41,1,41,3,41,1325,8,41,1,41,3,41,1328,8,41,1,41,
  	3,41,1331,8,41,1,41,1,41,1,41,1,41,1,41,3,41,1338,8,41,1,41,3,41,1341,
  	8,41,1,41,3,41,1344,8,41,1,41,1,41,3,41,1348,8,41,1,41,1,41,1,41,1,41,
  	1,41,3,41,1355,8,41,1,41,3,41,1358,8,41,1,41,3,41,1361,8,41,1,41,1,41,
  	3,41,1365,8,41,1,41,1,41,1,41,3,41,1370,8,41,1,42,1,42,1,42,1,42,1,43,
  	1,43,1,43,1,43,1,44,1,44,3,44,1382,8,44,1,44,3,44,1385,8,44,1,44,1,44,
  	1,44,1,45,1,45,1,45,1,45,1,46,1,46,1,47,1,47,1,48,1,48,5,48,1400,8,48,
  	10,48,12,48,1403,9,48,1,48,1,48,1,48,1,48,3,48,1409,8,48,1,49,1,49,5,
  	49,1413,8,49,10,49,12,49,1416,9,49,1,49,1,49,1,49,1,49,3,49,1422,8,49,
  	1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,
  	1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,
  	1,50,1,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,1460,8,50,1,51,1,51,1,52,
  	1,52,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,1,53,3,53,1475,8,53,1,54,
  	1,54,1,54,1,54,1,54,1,54,1,54,1,54,1,54,3,54,1486,8,54,3,54,1488,8,54,
  	1,54,1,54,3,54,1492,8,54,1,55,1,55,1,55,1,55,1,55,1,55,1,55,3,55,1501,
  	8,55,1,55,1,55,3,55,1505,8,55,1,56,1,56,1,56,3,56,1510,8,56,1,57,1,57,
  	1,57,5,57,1515,8,57,10,57,12,57,1518,9,57,1,58,1,58,1,58,5,58,1523,8,
  	58,10,58,12,58,1526,9,58,1,59,1,59,5,59,1530,8,59,10,59,12,59,1533,9,
  	59,1,60,1,60,1,60,5,60,1538,8,60,10,60,12,60,1541,9,60,1,61,1,61,1,61,
  	5,61,1546,8,61,10,61,12,61,1549,9,61,1,62,1,62,5,62,1553,8,62,10,62,12,
  	62,1556,9,62,1,63,1,63,1,63,5,63,1561,8,63,10,63,12,63,1564,9,63,1,64,
  	1,64,1,64,5,64,1569,8,64,10,64,12,64,1572,9,64,1,65,1,65,1,65,5,65,1577,
  	8,65,10,65,12,65,1580,9,65,1,66,1,66,1,66,5,66,1585,8,66,10,66,12,66,
  	1588,9,66,1,67,1,67,1,67,5,67,1593,8,67,10,67,12,67,1596,9,67,1,68,1,
  	68,1,68,5,68,1601,8,68,10,68,12,68,1604,9,68,1,69,1,69,1,69,3,69,1609,
  	8,69,1,70,1,70,1,70,1,70,1,71,1,71,1,71,1,71,1,72,1,72,1,72,1,72,1,73,
  	1,73,1,73,1,73,1,73,3,73,1628,8,73,1,74,1,74,1,74,1,74,1,74,1,74,3,74,
  	1636,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,
  	1649,8,74,1,74,1,74,3,74,1653,8,74,1,75,1,75,1,76,1,76,1,77,1,77,1,78,
  	1,78,1,78,1,78,1,78,1,78,1,79,1,79,1,79,1,79,1,79,1,79,1,80,1,80,3,80,
  	1675,8,80,1,80,3,80,1678,8,80,1,80,1,80,1,80,4,80,1683,8,80,11,80,12,
  	80,1684,1,80,1,80,1,80,1,80,1,80,3,80,1692,8,80,1,80,3,80,1695,8,80,1,
  	80,1,80,1,80,1,80,1,80,1,80,5,80,1703,8,80,10,80,12,80,1706,9,80,1,80,
  	1,80,1,80,3,80,1711,8,80,1,81,1,81,5,81,1715,8,81,10,81,12,81,1718,9,
  	81,1,81,1,81,1,81,3,81,1723,8,81,1,82,1,82,1,82,5,82,1728,8,82,10,82,
  	12,82,1731,9,82,1,83,5,83,1734,8,83,10,83,12,83,1737,9,83,1,83,1,83,1,
  	84,1,84,1,84,3,84,1744,8,84,1,84,1,84,1,84,1,84,3,84,1750,8,84,1,85,1,
  	85,3,85,1754,8,85,1,85,1,85,1,85,5,85,1759,8,85,10,85,12,85,1762,9,85,
  	1,85,1,85,1,85,1,85,1,85,3,85,1769,8,85,1,85,1,85,1,85,3,85,1774,8,85,
  	1,85,1,85,1,85,5,85,1779,8,85,10,85,12,85,1782,9,85,1,85,1,85,1,85,3,
  	85,1787,8,85,1,86,1,86,5,86,1791,8,86,10,86,12,86,1794,9,86,1,86,1,86,
  	1,86,1,86,5,86,1800,8,86,10,86,12,86,1803,9,86,1,86,1,86,1,86,1,86,5,
  	86,1809,8,86,10,86,12,86,1812,9,86,1,86,1,86,1,86,3,86,1817,8,86,1,87,
  	1,87,1,87,5,87,1822,8,87,10,87,12,87,1825,9,87,1,88,5,88,1828,8,88,10,
  	88,12,88,1831,9,88,1,88,1,88,5,88,1835,8,88,10,88,12,88,1838,9,88,1,88,
  	1,88,5,88,1842,8,88,10,88,12,88,1845,9,88,1,88,3,88,1848,8,88,1,89,1,
  	89,3,89,1852,8,89,1,89,3,89,1855,8,89,1,89,3,89,1858,8,89,1,89,1,89,1,
  	89,1,89,1,89,3,89,1865,8,89,1,90,1,90,3,90,1869,8,90,1,90,3,90,1872,8,
  	90,1,90,3,90,1875,8,90,1,90,1,90,1,90,1,90,1,90,3,90,1882,8,90,1,91,1,
  	91,3,91,1886,8,91,1,91,3,91,1889,8,91,1,91,3,91,1892,8,91,1,91,1,91,1,
  	91,1,91,1,91,3,91,1899,8,91,1,92,1,92,1,93,5,93,1904,8,93,10,93,12,93,
  	1907,9,93,1,93,1,93,3,93,1911,8,93,1,93,3,93,1914,8,93,1,93,1,93,1,93,
  	1,93,5,93,1920,8,93,10,93,12,93,1923,9,93,1,93,1,93,1,93,1,93,1,93,5,
  	93,1930,8,93,10,93,12,93,1933,9,93,1,93,1,93,1,93,1,93,1,93,5,93,1940,
  	8,93,10,93,12,93,1943,9,93,1,93,1,93,1,93,1,93,1,93,5,93,1950,8,93,10,
  	93,12,93,1953,9,93,1,93,1,93,1,93,1,93,1,93,5,93,1960,8,93,10,93,12,93,
  	1963,9,93,1,93,1,93,5,93,1967,8,93,10,93,12,93,1970,9,93,1,93,1,93,1,
  	93,1,93,5,93,1976,8,93,10,93,12,93,1979,9,93,1,93,1,93,1,93,3,93,1984,
  	8,93,1,94,1,94,1,94,5,94,1989,8,94,10,94,12,94,1992,9,94,1,95,1,95,1,
  	95,5,95,1997,8,95,10,95,12,95,2000,9,95,1,96,1,96,5,96,2004,8,96,10,96,
  	12,96,2007,9,96,1,97,1,97,5,97,2011,8,97,10,97,12,97,2014,9,97,1,98,1,
  	98,3,98,2018,8,98,1,98,1,98,1,98,5,98,2023,8,98,10,98,12,98,2026,9,98,
  	1,98,1,98,1,98,1,98,3,98,2032,8,98,1,98,3,98,2035,8,98,1,98,1,98,1,98,
  	5,98,2040,8,98,10,98,12,98,2043,9,98,1,98,1,98,1,98,1,98,3,98,2049,8,
  	98,1,98,1,98,1,98,5,98,2054,8,98,10,98,12,98,2057,9,98,1,98,1,98,1,98,
  	1,98,3,98,2063,8,98,1,98,3,98,2066,8,98,1,98,1,98,1,98,5,98,2071,8,98,
  	10,98,12,98,2074,9,98,1,98,1,98,1,98,1,98,3,98,2080,8,98,1,98,3,98,2083,
  	8,98,1,98,1,98,1,98,5,98,2088,8,98,10,98,12,98,2091,9,98,1,98,1,98,1,
  	98,1,98,3,98,2097,8,98,1,98,1,98,1,98,5,98,2102,8,98,10,98,12,98,2105,
  	9,98,1,98,1,98,1,98,1,98,1,98,1,98,5,98,2113,8,98,10,98,12,98,2116,9,
  	98,1,98,1,98,1,98,1,98,3,98,2122,8,98,1,98,1,98,1,98,5,98,2127,8,98,10,
  	98,12,98,2130,9,98,1,98,1,98,1,98,1,98,3,98,2136,8,98,1,98,1,98,1,98,
  	5,98,2141,8,98,10,98,12,98,2144,9,98,1,98,1,98,3,98,2148,8,98,1,99,3,
  	99,2151,8,99,1,99,1,99,1,99,1,99,1,99,1,99,1,99,1,99,1,99,1,99,1,100,
  	3,100,2164,8,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,101,
  	3,101,2175,8,101,1,101,1,101,1,101,1,101,1,101,1,101,1,101,1,101,1,102,
  	3,102,2186,8,102,1,102,1,102,1,102,1,102,1,102,1,102,5,102,2194,8,102,
  	10,102,12,102,2197,9,102,1,102,1,102,1,103,3,103,2202,8,103,1,103,1,103,
  	1,103,1,103,5,103,2208,8,103,10,103,12,103,2211,9,103,1,103,1,103,1,103,
  	1,103,1,104,3,104,2218,8,104,1,104,1,104,1,104,1,104,1,104,1,104,1,105,
  	3,105,2227,8,105,1,105,1,105,1,105,1,105,1,105,1,105,1,105,1,105,1,106,
  	3,106,2238,8,106,1,106,1,106,1,106,1,106,1,107,1,107,3,107,2246,8,107,
  	1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,108,1,108,
  	1,108,1,108,1,108,1,108,3,108,2264,8,108,1,109,1,109,1,109,1,109,1,109,
  	1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,3,109,
  	2282,8,109,1,110,1,110,1,111,1,111,1,112,1,112,1,113,1,113,1,114,1,114,
  	1,115,1,115,1,116,1,116,1,117,1,117,1,118,1,118,1,119,1,119,1,120,1,120,
  	1,121,1,121,1,122,1,122,1,123,1,123,3,123,2312,8,123,1,123,1,123,1,123,
  	5,123,2317,8,123,10,123,12,123,2320,9,123,1,123,1,123,1,124,1,124,1,124,
  	1,124,1,124,1,125,1,125,1,125,5,125,2332,8,125,10,125,12,125,2335,9,125,
  	1,125,1,125,1,125,5,125,2340,8,125,10,125,12,125,2343,9,125,3,125,2345,
  	8,125,1,126,1,126,1,127,1,127,1,127,1,127,3,127,2353,8,127,1,127,1,127,
  	1,128,1,128,1,128,1,128,1,128,1,129,1,129,3,129,2364,8,129,1,130,1,130,
  	1,130,5,130,2369,8,130,10,130,12,130,2372,9,130,1,130,1,130,1,130,5,130,
  	2377,8,130,10,130,12,130,2380,9,130,3,130,2382,8,130,1,131,5,131,2385,
  	8,131,10,131,12,131,2388,9,131,1,131,3,131,2391,8,131,1,132,5,132,2394,
  	8,132,10,132,12,132,2397,9,132,1,132,1,132,1,132,1,132,3,132,2403,8,132,
  	1,132,1,132,1,133,1,133,5,133,2409,8,133,10,133,12,133,2412,9,133,1,133,
  	1,133,1,134,1,134,1,134,1,134,1,135,1,135,1,135,5,135,2423,8,135,10,135,
  	12,135,2426,9,135,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
  	1,136,1,137,1,137,1,137,1,137,1,138,1,138,1,139,1,139,1,139,1,139,1,140,
  	1,140,3,140,2450,8,140,1,141,1,141,1,141,1,141,1,141,1,141,1,141,3,141,
  	2459,8,141,1,142,1,142,1,142,1,142,1,142,4,142,2466,8,142,11,142,12,142,
  	2467,1,142,1,142,1,143,1,143,1,143,5,143,2475,8,143,10,143,12,143,2478,
  	9,143,1,143,1,143,1,143,1,143,1,143,3,143,2485,8,143,1,143,3,143,2488,
  	8,143,1,144,1,144,1,144,3,144,2493,8,144,1,144,5,144,2496,8,144,10,144,
  	12,144,2499,9,144,1,144,3,144,2502,8,144,1,145,1,145,1,145,1,146,1,146,
  	3,146,2509,8,146,1,147,5,147,2512,8,147,10,147,12,147,2515,9,147,1,147,
  	1,147,1,147,1,147,1,147,1,147,1,147,4,147,2524,8,147,11,147,12,147,2525,
  	1,147,1,147,1,147,1,147,5,147,2532,8,147,10,147,12,147,2535,9,147,1,147,
  	1,147,1,147,1,147,1,147,1,147,1,147,1,147,1,147,3,147,2546,8,147,1,148,
  	1,148,1,148,1,148,1,148,5,148,2553,8,148,10,148,12,148,2556,9,148,1,149,
  	1,149,1,149,1,149,1,149,5,149,2563,8,149,10,149,12,149,2566,9,149,1,150,
  	1,150,1,150,1,150,1,150,1,150,1,150,1,150,1,150,3,150,2577,8,150,1,151,
  	5,151,2580,8,151,10,151,12,151,2583,9,151,1,151,1,151,1,151,5,151,2588,
  	8,151,10,151,12,151,2591,9,151,1,151,1,151,1,151,1,151,1,151,3,151,2598,
  	8,151,3,151,2600,8,151,1,152,5,152,2603,8,152,10,152,12,152,2606,9,152,
  	1,152,1,152,1,152,1,153,5,153,2612,8,153,10,153,12,153,2615,9,153,1,153,
  	1,153,1,153,1,154,1,154,3,154,2622,8,154,1,155,1,155,4,155,2626,8,155,
  	11,155,12,155,2627,1,155,1,155,1,156,1,156,1,156,1,156,1,156,1,157,3,
  	157,2638,8,157,1,157,1,157,4,157,2642,8,157,11,157,12,157,2643,1,157,
  	1,157,1,158,1,158,1,158,1,158,1,158,1,158,1,159,1,159,3,159,2656,8,159,
  	1,160,1,160,1,160,1,160,1,160,1,160,1,160,1,161,1,161,3,161,2667,8,161,
  	1,162,4,162,2670,8,162,11,162,12,162,2671,1,163,5,163,2675,8,163,10,163,
  	12,163,2678,9,163,1,163,1,163,5,163,2682,8,163,10,163,12,163,2685,9,163,
  	1,164,1,164,1,164,1,164,1,164,1,164,3,164,2693,8,164,1,165,1,165,1,166,
  	1,166,3,166,2699,8,166,1,167,1,167,1,168,1,168,1,169,1,169,1,170,1,170,
  	3,170,2709,8,170,1,170,3,170,2712,8,170,1,170,1,170,1,170,5,170,2717,
  	8,170,10,170,12,170,2720,9,170,1,170,1,170,1,171,3,171,2725,8,171,1,171,
  	1,171,1,171,1,171,1,171,1,171,5,171,2733,8,171,10,171,12,171,2736,9,171,
  	1,171,1,171,1,172,1,172,3,172,2742,8,172,1,173,1,173,3,173,2746,8,173,
  	1,173,3,173,2749,8,173,1,173,1,173,1,173,1,174,1,174,1,174,5,174,2757,
  	8,174,10,174,12,174,2760,9,174,1,175,1,175,1,175,1,175,1,176,1,176,1,
  	176,1,177,1,177,1,177,1,178,1,178,1,178,3,178,2775,8,178,1,178,1,178,
  	1,179,1,179,1,179,3,179,2782,8,179,1,179,1,179,1,180,1,180,1,180,1,180,
  	1,180,1,180,1,180,1,180,3,180,2794,8,180,1,181,1,181,1,181,1,181,1,182,
  	1,182,1,182,5,182,2803,8,182,10,182,12,182,2806,9,182,3,182,2808,8,182,
  	1,182,5,182,2811,8,182,10,182,12,182,2814,9,182,1,182,1,182,1,183,1,183,
  	1,183,1,184,1,184,1,184,5,184,2824,8,184,10,184,12,184,2827,9,184,3,184,
  	2829,8,184,1,184,5,184,2832,8,184,10,184,12,184,2835,9,184,1,184,1,184,
  	1,185,5,185,2840,8,185,10,185,12,185,2843,9,185,1,185,1,185,1,185,1,185,
  	5,185,2849,8,185,10,185,12,185,2852,9,185,1,185,1,185,5,185,2856,8,185,
  	10,185,12,185,2859,9,185,1,185,1,185,5,185,2863,8,185,10,185,12,185,2866,
  	9,185,1,185,1,185,5,185,2870,8,185,10,185,12,185,2873,9,185,1,185,1,185,
  	5,185,2877,8,185,10,185,12,185,2880,9,185,1,185,1,185,5,185,2884,8,185,
  	10,185,12,185,2887,9,185,1,185,1,185,1,185,1,185,5,185,2893,8,185,10,
  	185,12,185,2896,9,185,1,185,1,185,5,185,2900,8,185,10,185,12,185,2903,
  	9,185,1,185,1,185,1,185,1,185,5,185,2909,8,185,10,185,12,185,2912,9,185,
  	1,185,1,185,5,185,2916,8,185,10,185,12,185,2919,9,185,1,185,1,185,5,185,
  	2923,8,185,10,185,12,185,2926,9,185,1,185,1,185,5,185,2930,8,185,10,185,
  	12,185,2933,9,185,1,185,1,185,5,185,2937,8,185,10,185,12,185,2940,9,185,
  	1,185,3,185,2943,8,185,1,186,1,186,5,186,2947,8,186,10,186,12,186,2950,
  	9,186,1,186,3,186,2953,8,186,1,187,1,187,1,188,1,188,1,188,1,188,1,188,
  	1,188,1,188,3,188,2964,8,188,1,189,1,189,1,189,1,189,1,189,1,189,1,189,
  	1,189,3,189,2974,8,189,1,190,1,190,1,190,1,190,1,191,1,191,1,191,1,191,
  	1,191,1,191,1,191,1,191,1,191,1,191,1,191,1,191,1,191,3,191,2993,8,191,
  	1,192,1,192,1,192,3,192,2998,8,192,1,192,1,192,1,193,1,193,1,193,1,193,
  	1,193,1,193,3,193,3008,8,193,1,193,1,193,1,193,1,193,1,193,1,193,5,193,
  	3016,8,193,10,193,12,193,3019,9,193,1,194,1,194,3,194,3023,8,194,1,195,
  	1,195,1,195,1,196,1,196,1,196,1,196,1,196,1,196,1,197,1,197,1,197,1,197,
  	1,197,1,197,1,197,3,197,3041,8,197,1,198,1,198,1,198,1,198,1,198,4,198,
  	3048,8,198,11,198,12,198,3049,1,198,1,198,1,198,1,198,1,198,1,198,1,198,
  	4,198,3059,8,198,11,198,12,198,3060,1,198,1,198,1,198,1,198,1,198,1,198,
  	1,198,4,198,3070,8,198,11,198,12,198,3071,1,198,1,198,3,198,3076,8,198,
  	1,199,1,199,1,199,5,199,3081,8,199,10,199,12,199,3084,9,199,1,199,1,199,
  	1,199,1,199,1,199,3,199,3091,8,199,1,199,3,199,3094,8,199,1,200,1,200,
  	1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,
  	1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,1,200,3,200,3120,
  	8,200,1,201,1,201,3,201,3124,8,201,1,201,1,201,1,202,1,202,1,202,1,202,
  	5,202,3132,8,202,10,202,12,202,3135,9,202,1,202,1,202,1,203,3,203,3140,
  	8,203,1,204,1,204,3,204,3144,8,204,1,204,1,204,1,205,1,205,1,205,1,205,
  	5,205,3152,8,205,10,205,12,205,3155,9,205,1,205,1,205,1,206,1,206,5,206,
  	3161,8,206,10,206,12,206,3164,9,206,1,206,1,206,1,207,1,207,1,207,1,207,
  	1,207,3,207,3173,8,207,1,208,1,208,1,208,1,208,1,208,1,208,1,208,1,208,
  	3,208,3183,8,208,1,209,1,209,1,209,1,209,1,209,1,209,1,209,1,209,3,209,
  	3193,8,209,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,1,210,3,210,
  	3204,8,210,1,211,1,211,1,211,1,211,1,211,1,211,1,211,1,211,3,211,3214,
  	8,211,1,212,1,212,1,212,3,212,3219,8,212,1,212,1,212,1,212,1,212,1,213,
  	1,213,1,213,3,213,3228,8,213,1,213,1,213,1,213,1,213,1,214,1,214,1,214,
  	5,214,3237,8,214,10,214,12,214,3240,9,214,1,215,1,215,1,215,5,215,3245,
  	8,215,10,215,12,215,3248,9,215,1,216,1,216,1,216,1,216,1,216,3,216,3255,
  	8,216,1,217,1,217,1,217,1,217,1,217,3,217,3262,8,217,1,218,1,218,1,219,
  	1,219,1,220,1,220,1,220,1,220,1,220,3,220,3273,8,220,1,221,1,221,1,221,
  	1,221,1,221,1,221,3,221,3281,8,221,1,221,1,221,1,221,1,221,1,221,1,221,
  	1,221,1,221,1,221,1,221,1,221,1,221,1,221,1,221,1,221,1,221,1,221,1,221,
  	1,221,1,221,1,221,1,221,1,221,1,221,3,221,3307,8,221,3,221,3309,8,221,
  	1,222,1,222,1,223,1,223,1,224,1,224,1,225,1,225,1,226,1,226,1,227,1,227,
  	1,228,1,228,1,229,1,229,1,230,1,230,1,231,1,231,1,232,1,232,1,233,1,233,
  	1,234,1,234,1,235,1,235,1,236,1,236,1,237,1,237,1,238,1,238,1,239,1,239,
  	1,239,1,239,1,239,1,239,1,239,1,239,3,239,3353,8,239,1,240,1,240,3,240,
  	3357,8,240,1,240,1,240,1,240,1,240,1,240,3,240,3364,8,240,1,240,1,240,
  	1,240,1,240,1,240,1,241,1,241,3,241,3373,8,241,1,241,1,241,1,241,1,241,
  	1,241,3,241,3380,8,241,1,241,1,241,1,241,1,241,1,241,1,242,1,242,1,243,
  	1,243,1,244,1,244,1,244,1,244,1,244,1,244,1,244,1,244,1,244,1,244,1,244,
  	1,244,1,244,1,244,3,244,3405,8,244,1,245,1,245,1,246,1,246,1,246,1,246,
  	1,246,1,246,1,246,1,246,1,246,1,246,1,246,1,246,3,246,3421,8,246,1,247,
  	1,247,1,247,1,247,1,247,1,247,1,247,1,247,3,247,3431,8,247,1,247,1,247,
  	1,247,1,248,1,248,3,248,3438,8,248,1,249,1,249,1,249,1,249,1,249,1,249,
  	1,249,1,249,3,249,3448,8,249,1,249,1,249,1,249,1,250,1,250,1,250,1,250,
  	1,250,1,250,1,250,1,250,1,250,1,250,3,250,3463,8,250,1,250,1,250,1,250,
  	1,251,1,251,3,251,3470,8,251,1,251,3,251,3473,8,251,1,252,1,252,3,252,
  	3477,8,252,1,252,3,252,3480,8,252,1,253,1,253,3,253,3484,8,253,1,253,
  	3,253,3487,8,253,1,254,1,254,3,254,3491,8,254,1,254,3,254,3494,8,254,
  	1,255,1,255,3,255,3498,8,255,1,256,1,256,1,256,1,256,1,256,1,256,1,256,
  	1,256,3,256,3508,8,256,1,256,1,256,1,256,1,257,1,257,1,257,1,257,1,257,
  	1,257,1,257,1,257,3,257,3521,8,257,1,257,1,257,1,257,1,258,1,258,1,258,
  	1,258,1,258,1,258,1,258,1,258,1,258,1,258,3,258,3536,8,258,1,258,1,258,
  	1,258,1,259,1,259,1,259,1,259,1,259,1,259,1,259,1,259,3,259,3549,8,259,
  	1,259,1,259,1,259,1,260,1,260,1,260,1,260,1,260,1,260,1,260,1,260,3,260,
  	3562,8,260,1,260,1,260,1,260,1,261,1,261,3,261,3569,8,261,1,261,3,261,
  	3572,8,261,1,262,1,262,3,262,3576,8,262,1,262,3,262,3579,8,262,1,263,
  	1,263,3,263,3583,8,263,1,264,1,264,1,264,1,264,1,264,1,264,1,264,1,264,
  	1,264,1,264,3,264,3595,8,264,1,264,1,264,1,264,1,265,1,265,1,265,1,265,
  	1,265,1,265,3,265,3606,8,265,1,265,1,265,1,265,1,266,1,266,1,266,1,266,
  	1,266,1,266,3,266,3617,8,266,1,266,1,266,1,266,1,267,1,267,1,267,1,267,
  	3,267,3626,8,267,1,268,1,268,1,268,1,268,1,268,1,268,1,268,1,268,1,268,
  	1,268,3,268,3638,8,268,1,268,1,268,1,268,1,269,1,269,1,270,1,270,1,271,
  	1,271,1,272,1,272,1,272,1,272,1,272,3,272,3654,8,272,1,273,1,273,1,273,
  	1,273,1,273,3,273,3661,8,273,1,274,1,274,1,275,1,275,1,276,1,276,1,277,
  	1,277,1,278,1,278,1,279,1,279,1,280,1,280,1,281,1,281,1,282,1,282,1,283,
  	3,283,3682,8,283,1,283,1,283,1,283,3,283,3687,8,283,1,284,1,284,1,284,
  	1,284,3,284,3693,8,284,1,285,1,285,1,285,3,285,3698,8,285,1,286,1,286,
  	3,286,3702,8,286,1,287,1,287,1,287,1,287,1,287,5,287,3709,8,287,10,287,
  	12,287,3712,9,287,1,287,1,287,1,288,1,288,1,289,1,289,1,289,1,289,1,289,
  	3,289,3723,8,289,1,290,1,290,1,290,1,290,1,290,1,290,1,290,1,290,1,290,
  	1,290,1,290,1,290,1,290,1,290,1,290,1,290,1,290,1,290,1,290,3,290,3744,
  	8,290,1,291,1,291,3,291,3748,8,291,1,292,1,292,1,292,1,292,5,292,3754,
  	8,292,10,292,12,292,3757,9,292,1,292,1,292,1,293,1,293,1,293,1,293,5,
  	293,3765,8,293,10,293,12,293,3768,9,293,1,293,1,293,1,294,1,294,1,294,
  	1,294,1,294,1,295,1,295,1,295,1,295,5,295,3781,8,295,10,295,12,295,3784,
  	9,295,1,295,1,295,1,296,1,296,1,296,1,296,1,296,1,297,1,297,1,297,1,297,
  	1,297,1,298,1,298,5,298,3800,8,298,10,298,12,298,3803,9,298,1,298,1,298,
  	1,298,1,298,5,298,3809,8,298,10,298,12,298,3812,9,298,1,298,1,298,1,299,
  	1,299,1,299,1,299,1,299,5,299,3821,8,299,10,299,12,299,3824,9,299,1,299,
  	1,299,1,300,1,300,5,300,3830,8,300,10,300,12,300,3833,9,300,1,300,1,300,
  	1,300,1,300,5,300,3839,8,300,10,300,12,300,3842,9,300,1,300,1,300,1,301,
  	1,301,3,301,3848,8,301,1,302,1,302,1,302,1,302,5,302,3854,8,302,10,302,
  	12,302,3857,9,302,1,302,1,302,1,303,1,303,1,304,1,304,1,305,1,305,1,305,
  	1,305,5,305,3869,8,305,10,305,12,305,3872,9,305,1,305,1,305,3,305,3876,
  	8,305,1,305,1,305,1,305,5,305,3881,8,305,10,305,12,305,3884,9,305,1,305,
  	1,305,1,305,1,305,5,305,3890,8,305,10,305,12,305,3893,9,305,1,305,1,305,
  	1,305,1,305,5,305,3899,8,305,10,305,12,305,3902,9,305,1,305,1,305,1,305,
  	1,305,5,305,3908,8,305,10,305,12,305,3911,9,305,1,305,1,305,1,305,1,305,
  	5,305,3917,8,305,10,305,12,305,3920,9,305,1,305,1,305,1,305,1,305,5,305,
  	3926,8,305,10,305,12,305,3929,9,305,1,305,1,305,1,305,1,305,5,305,3935,
  	8,305,10,305,12,305,3938,9,305,1,305,1,305,1,305,1,305,5,305,3944,8,305,
  	10,305,12,305,3947,9,305,1,305,1,305,1,305,1,305,5,305,3953,8,305,10,
  	305,12,305,3956,9,305,1,305,1,305,1,305,1,305,5,305,3962,8,305,10,305,
  	12,305,3965,9,305,1,305,1,305,1,305,1,305,5,305,3971,8,305,10,305,12,
  	305,3974,9,305,1,305,1,305,1,305,1,305,5,305,3980,8,305,10,305,12,305,
  	3983,9,305,1,305,1,305,1,305,1,305,5,305,3989,8,305,10,305,12,305,3992,
  	9,305,1,306,1,306,1,306,1,306,1,306,1,306,3,306,4000,8,306,1,307,1,307,
  	1,307,1,307,1,307,1,307,1,307,1,307,1,307,1,307,1,307,1,307,1,307,3,307,
  	4015,8,307,1,308,1,308,1,309,1,309,1,309,1,309,5,309,4023,8,309,10,309,
  	12,309,4026,9,309,1,309,1,309,3,309,4030,8,309,1,309,1,309,1,309,5,309,
  	4035,8,309,10,309,12,309,4038,9,309,1,309,1,309,1,309,1,309,5,309,4044,
  	8,309,10,309,12,309,4047,9,309,1,309,1,309,1,309,1,309,5,309,4053,8,309,
  	10,309,12,309,4056,9,309,1,309,1,309,1,309,1,309,5,309,4062,8,309,10,
  	309,12,309,4065,9,309,1,309,1,309,1,309,1,309,5,309,4071,8,309,10,309,
  	12,309,4074,9,309,1,309,1,309,1,309,1,309,5,309,4080,8,309,10,309,12,
  	309,4083,9,309,1,309,1,309,1,309,1,309,5,309,4089,8,309,10,309,12,309,
  	4092,9,309,1,309,1,309,1,309,1,309,5,309,4098,8,309,10,309,12,309,4101,
  	9,309,1,309,1,309,1,309,1,309,5,309,4107,8,309,10,309,12,309,4110,9,309,
  	1,309,1,309,1,309,1,309,5,309,4116,8,309,10,309,12,309,4119,9,309,1,309,
  	1,309,1,309,1,309,5,309,4125,8,309,10,309,12,309,4128,9,309,1,309,1,309,
  	1,309,1,309,5,309,4134,8,309,10,309,12,309,4137,9,309,1,309,1,309,1,309,
  	1,309,5,309,4143,8,309,10,309,12,309,4146,9,309,1,310,1,310,1,311,1,311,
  	1,311,1,311,1,311,1,311,3,311,4156,8,311,1,312,1,312,1,312,1,312,5,312,
  	4162,8,312,10,312,12,312,4165,9,312,1,312,1,312,3,312,4169,8,312,1,312,
  	1,312,1,312,5,312,4174,8,312,10,312,12,312,4177,9,312,1,312,1,312,1,312,
  	1,312,5,312,4183,8,312,10,312,12,312,4186,9,312,1,312,1,312,1,312,1,312,
  	5,312,4192,8,312,10,312,12,312,4195,9,312,1,312,1,312,1,312,1,312,5,312,
  	4201,8,312,10,312,12,312,4204,9,312,1,312,1,312,1,312,1,312,5,312,4210,
  	8,312,10,312,12,312,4213,9,312,1,312,1,312,1,312,1,312,5,312,4219,8,312,
  	10,312,12,312,4222,9,312,1,312,1,312,1,312,1,312,5,312,4228,8,312,10,
  	312,12,312,4231,9,312,1,312,1,312,1,312,1,312,5,312,4237,8,312,10,312,
  	12,312,4240,9,312,1,313,1,313,1,313,1,313,1,313,1,313,3,313,4248,8,313,
  	1,314,1,314,1,315,1,315,1,315,1,315,1,315,1,315,1,315,1,315,1,315,1,315,
  	1,315,1,315,1,315,3,315,4265,8,315,1,316,1,316,1,317,1,317,1,317,1,317,
  	1,317,1,317,3,317,4275,8,317,1,317,1,317,1,317,1,317,1,317,1,317,1,317,
  	1,317,1,317,3,317,4286,8,317,1,318,1,318,1,318,1,318,1,318,1,318,1,318,
  	1,318,1,318,1,318,3,318,4298,8,318,1,319,1,319,1,319,3,319,4303,8,319,
  	1,319,1,319,1,319,1,319,1,319,1,319,1,319,1,319,1,319,3,319,4314,8,319,
  	1,320,3,320,4317,8,320,1,320,1,320,1,320,1,320,1,321,1,321,1,321,1,321,
  	4,321,4327,8,321,11,321,12,321,4328,1,322,1,322,3,322,4333,8,322,1,322,
  	1,322,1,322,1,322,5,322,4339,8,322,10,322,12,322,4342,9,322,1,322,1,322,
  	3,322,4346,8,322,1,323,3,323,4349,8,323,1,323,1,323,1,323,1,323,1,324,
  	1,324,1,324,1,324,4,324,4359,8,324,11,324,12,324,4360,1,325,1,325,3,325,
  	4365,8,325,1,325,1,325,1,325,1,325,5,325,4371,8,325,10,325,12,325,4374,
  	9,325,1,325,1,325,3,325,4378,8,325,1,326,1,326,1,327,1,327,1,328,1,328,
  	1,328,1,328,1,328,3,328,4389,8,328,1,329,1,329,3,329,4393,8,329,1,330,
  	1,330,3,330,4397,8,330,1,330,1,330,1,330,3,330,4402,8,330,1,331,3,331,
  	4405,8,331,1,331,1,331,1,331,1,332,3,332,4411,8,332,1,332,1,332,1,332,
  	1,333,3,333,4417,8,333,1,333,1,333,1,333,1,334,1,334,1,335,1,335,1,336,
  	1,336,1,337,1,337,1,338,1,338,1,339,1,339,1,340,1,340,1,341,1,341,1,342,
  	1,342,1,343,1,343,1,344,1,344,1,345,1,345,1,346,1,346,1,347,1,347,1,347,
  	1,347,1,347,5,347,4453,8,347,10,347,12,347,4456,9,347,1,347,1,347,1,347,
  	1,348,1,348,1,348,3,348,4464,8,348,1,349,1,349,1,350,1,350,1,351,1,351,
  	1,352,1,352,1,353,1,353,1,354,1,354,1,355,1,355,1,356,1,356,1,357,1,357,
  	1,358,1,358,1,359,5,359,4487,8,359,10,359,12,359,4490,9,359,1,359,1,359,
  	1,360,1,360,3,360,4496,8,360,1,360,1,360,1,361,1,361,3,361,4502,8,361,
  	1,362,1,362,1,363,1,363,1,364,1,364,1,365,1,365,1,366,1,366,1,367,1,367,
  	1,368,1,368,1,369,1,369,1,370,1,370,1,371,1,371,1,372,1,372,1,373,1,373,
  	1,374,1,374,1,375,1,375,1,376,1,376,1,377,1,377,1,378,1,378,1,379,1,379,
  	1,380,1,380,1,381,1,381,1,381,0,4,386,610,618,624,382,0,2,4,6,8,10,12,
  	14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,
  	60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,
  	106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,
  	142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,
  	178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,
  	214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,
  	250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,
  	286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,
  	322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,
  	358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,
  	394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,
  	430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,
  	466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,
  	502,504,506,508,510,512,514,516,518,520,522,524,526,528,530,532,534,536,
  	538,540,542,544,546,548,550,552,554,556,558,560,562,564,566,568,570,572,
  	574,576,578,580,582,584,586,588,590,592,594,596,598,600,602,604,606,608,
  	610,612,614,616,618,620,622,624,626,628,630,632,634,636,638,640,642,644,
  	646,648,650,652,654,656,658,660,662,664,666,668,670,672,674,676,678,680,
  	682,684,686,688,690,692,694,696,698,700,702,704,706,708,710,712,714,716,
  	718,720,722,724,726,728,730,732,734,736,738,740,742,744,746,748,750,752,
  	754,756,758,760,762,0,26,2,0,101,101,108,108,3,0,88,88,136,137,164,164,
  	2,0,148,148,177,177,6,0,157,158,169,172,174,174,176,176,181,181,185,186,
  	2,0,88,88,164,164,4,0,129,129,156,156,158,158,183,183,4,0,127,127,155,
  	155,157,157,182,182,2,0,23,23,135,135,2,0,14,15,115,116,4,0,111,111,123,
  	123,141,141,143,143,5,0,5,5,109,109,112,112,117,117,187,188,2,0,13,13,
  	114,114,2,0,145,146,167,168,2,0,144,144,166,166,1,0,209,210,2,0,110,110,
  	124,124,2,0,103,103,121,121,3,0,6,6,107,107,151,151,2,0,76,77,99,100,
  	2,0,74,75,97,98,2,0,49,50,62,63,3,0,16,16,20,20,163,163,2,0,49,49,62,
  	62,9,0,2,2,16,16,20,20,48,48,103,103,121,121,161,163,165,165,178,178,
  	7,0,2,2,16,16,20,20,48,48,161,163,165,165,178,178,2,0,200,200,203,203,
  	4788,0,767,1,0,0,0,2,775,1,0,0,0,4,777,1,0,0,0,6,792,1,0,0,0,8,801,1,
  	0,0,0,10,805,1,0,0,0,12,810,1,0,0,0,14,818,1,0,0,0,16,823,1,0,0,0,18,
  	843,1,0,0,0,20,845,1,0,0,0,22,888,1,0,0,0,24,894,1,0,0,0,26,896,1,0,0,
  	0,28,898,1,0,0,0,30,918,1,0,0,0,32,920,1,0,0,0,34,948,1,0,0,0,36,972,
  	1,0,0,0,38,1053,1,0,0,0,40,1065,1,0,0,0,42,1067,1,0,0,0,44,1071,1,0,0,
  	0,46,1083,1,0,0,0,48,1095,1,0,0,0,50,1119,1,0,0,0,52,1121,1,0,0,0,54,
  	1123,1,0,0,0,56,1126,1,0,0,0,58,1134,1,0,0,0,60,1142,1,0,0,0,62,1149,
  	1,0,0,0,64,1172,1,0,0,0,66,1186,1,0,0,0,68,1188,1,0,0,0,70,1195,1,0,0,
  	0,72,1197,1,0,0,0,74,1209,1,0,0,0,76,1245,1,0,0,0,78,1247,1,0,0,0,80,
  	1251,1,0,0,0,82,1369,1,0,0,0,84,1371,1,0,0,0,86,1375,1,0,0,0,88,1379,
  	1,0,0,0,90,1389,1,0,0,0,92,1393,1,0,0,0,94,1395,1,0,0,0,96,1408,1,0,0,
  	0,98,1421,1,0,0,0,100,1459,1,0,0,0,102,1461,1,0,0,0,104,1463,1,0,0,0,
  	106,1474,1,0,0,0,108,1491,1,0,0,0,110,1504,1,0,0,0,112,1509,1,0,0,0,114,
  	1511,1,0,0,0,116,1519,1,0,0,0,118,1527,1,0,0,0,120,1534,1,0,0,0,122,1542,
  	1,0,0,0,124,1550,1,0,0,0,126,1557,1,0,0,0,128,1565,1,0,0,0,130,1573,1,
  	0,0,0,132,1581,1,0,0,0,134,1589,1,0,0,0,136,1597,1,0,0,0,138,1605,1,0,
  	0,0,140,1610,1,0,0,0,142,1614,1,0,0,0,144,1618,1,0,0,0,146,1627,1,0,0,
  	0,148,1652,1,0,0,0,150,1654,1,0,0,0,152,1656,1,0,0,0,154,1658,1,0,0,0,
  	156,1660,1,0,0,0,158,1666,1,0,0,0,160,1710,1,0,0,0,162,1722,1,0,0,0,164,
  	1724,1,0,0,0,166,1735,1,0,0,0,168,1749,1,0,0,0,170,1786,1,0,0,0,172,1816,
  	1,0,0,0,174,1818,1,0,0,0,176,1847,1,0,0,0,178,1864,1,0,0,0,180,1881,1,
  	0,0,0,182,1898,1,0,0,0,184,1900,1,0,0,0,186,1983,1,0,0,0,188,1985,1,0,
  	0,0,190,1993,1,0,0,0,192,2001,1,0,0,0,194,2008,1,0,0,0,196,2147,1,0,0,
  	0,198,2150,1,0,0,0,200,2163,1,0,0,0,202,2174,1,0,0,0,204,2185,1,0,0,0,
  	206,2201,1,0,0,0,208,2217,1,0,0,0,210,2226,1,0,0,0,212,2237,1,0,0,0,214,
  	2243,1,0,0,0,216,2263,1,0,0,0,218,2281,1,0,0,0,220,2283,1,0,0,0,222,2285,
  	1,0,0,0,224,2287,1,0,0,0,226,2289,1,0,0,0,228,2291,1,0,0,0,230,2293,1,
  	0,0,0,232,2295,1,0,0,0,234,2297,1,0,0,0,236,2299,1,0,0,0,238,2301,1,0,
  	0,0,240,2303,1,0,0,0,242,2305,1,0,0,0,244,2307,1,0,0,0,246,2309,1,0,0,
  	0,248,2323,1,0,0,0,250,2344,1,0,0,0,252,2346,1,0,0,0,254,2348,1,0,0,0,
  	256,2356,1,0,0,0,258,2361,1,0,0,0,260,2381,1,0,0,0,262,2386,1,0,0,0,264,
  	2395,1,0,0,0,266,2406,1,0,0,0,268,2415,1,0,0,0,270,2419,1,0,0,0,272,2427,
  	1,0,0,0,274,2437,1,0,0,0,276,2441,1,0,0,0,278,2443,1,0,0,0,280,2449,1,
  	0,0,0,282,2451,1,0,0,0,284,2460,1,0,0,0,286,2487,1,0,0,0,288,2501,1,0,
  	0,0,290,2503,1,0,0,0,292,2508,1,0,0,0,294,2545,1,0,0,0,296,2547,1,0,0,
  	0,298,2557,1,0,0,0,300,2576,1,0,0,0,302,2599,1,0,0,0,304,2604,1,0,0,0,
  	306,2613,1,0,0,0,308,2621,1,0,0,0,310,2623,1,0,0,0,312,2631,1,0,0,0,314,
  	2637,1,0,0,0,316,2647,1,0,0,0,318,2655,1,0,0,0,320,2657,1,0,0,0,322,2666,
  	1,0,0,0,324,2669,1,0,0,0,326,2676,1,0,0,0,328,2692,1,0,0,0,330,2694,1,
  	0,0,0,332,2698,1,0,0,0,334,2700,1,0,0,0,336,2702,1,0,0,0,338,2704,1,0,
  	0,0,340,2706,1,0,0,0,342,2724,1,0,0,0,344,2739,1,0,0,0,346,2743,1,0,0,
  	0,348,2753,1,0,0,0,350,2761,1,0,0,0,352,2765,1,0,0,0,354,2768,1,0,0,0,
  	356,2771,1,0,0,0,358,2778,1,0,0,0,360,2793,1,0,0,0,362,2795,1,0,0,0,364,
  	2799,1,0,0,0,366,2817,1,0,0,0,368,2820,1,0,0,0,370,2942,1,0,0,0,372,2952,
  	1,0,0,0,374,2954,1,0,0,0,376,2963,1,0,0,0,378,2973,1,0,0,0,380,2975,1,
  	0,0,0,382,2992,1,0,0,0,384,2994,1,0,0,0,386,3007,1,0,0,0,388,3022,1,0,
  	0,0,390,3024,1,0,0,0,392,3027,1,0,0,0,394,3033,1,0,0,0,396,3075,1,0,0,
  	0,398,3093,1,0,0,0,400,3119,1,0,0,0,402,3121,1,0,0,0,404,3127,1,0,0,0,
  	406,3139,1,0,0,0,408,3141,1,0,0,0,410,3147,1,0,0,0,412,3158,1,0,0,0,414,
  	3172,1,0,0,0,416,3182,1,0,0,0,418,3192,1,0,0,0,420,3203,1,0,0,0,422,3213,
  	1,0,0,0,424,3215,1,0,0,0,426,3224,1,0,0,0,428,3233,1,0,0,0,430,3241,1,
  	0,0,0,432,3249,1,0,0,0,434,3256,1,0,0,0,436,3263,1,0,0,0,438,3265,1,0,
  	0,0,440,3272,1,0,0,0,442,3308,1,0,0,0,444,3310,1,0,0,0,446,3312,1,0,0,
  	0,448,3314,1,0,0,0,450,3316,1,0,0,0,452,3318,1,0,0,0,454,3320,1,0,0,0,
  	456,3322,1,0,0,0,458,3324,1,0,0,0,460,3326,1,0,0,0,462,3328,1,0,0,0,464,
  	3330,1,0,0,0,466,3332,1,0,0,0,468,3334,1,0,0,0,470,3336,1,0,0,0,472,3338,
  	1,0,0,0,474,3340,1,0,0,0,476,3342,1,0,0,0,478,3352,1,0,0,0,480,3354,1,
  	0,0,0,482,3370,1,0,0,0,484,3386,1,0,0,0,486,3388,1,0,0,0,488,3404,1,0,
  	0,0,490,3406,1,0,0,0,492,3420,1,0,0,0,494,3422,1,0,0,0,496,3435,1,0,0,
  	0,498,3439,1,0,0,0,500,3452,1,0,0,0,502,3467,1,0,0,0,504,3474,1,0,0,0,
  	506,3481,1,0,0,0,508,3488,1,0,0,0,510,3495,1,0,0,0,512,3499,1,0,0,0,514,
  	3512,1,0,0,0,516,3525,1,0,0,0,518,3540,1,0,0,0,520,3553,1,0,0,0,522,3566,
  	1,0,0,0,524,3573,1,0,0,0,526,3580,1,0,0,0,528,3584,1,0,0,0,530,3599,1,
  	0,0,0,532,3610,1,0,0,0,534,3621,1,0,0,0,536,3627,1,0,0,0,538,3642,1,0,
  	0,0,540,3644,1,0,0,0,542,3646,1,0,0,0,544,3648,1,0,0,0,546,3655,1,0,0,
  	0,548,3662,1,0,0,0,550,3664,1,0,0,0,552,3666,1,0,0,0,554,3668,1,0,0,0,
  	556,3670,1,0,0,0,558,3672,1,0,0,0,560,3674,1,0,0,0,562,3676,1,0,0,0,564,
  	3678,1,0,0,0,566,3681,1,0,0,0,568,3688,1,0,0,0,570,3697,1,0,0,0,572,3701,
  	1,0,0,0,574,3703,1,0,0,0,576,3715,1,0,0,0,578,3722,1,0,0,0,580,3743,1,
  	0,0,0,582,3747,1,0,0,0,584,3749,1,0,0,0,586,3760,1,0,0,0,588,3771,1,0,
  	0,0,590,3776,1,0,0,0,592,3787,1,0,0,0,594,3792,1,0,0,0,596,3797,1,0,0,
  	0,598,3815,1,0,0,0,600,3827,1,0,0,0,602,3845,1,0,0,0,604,3849,1,0,0,0,
  	606,3860,1,0,0,0,608,3862,1,0,0,0,610,3875,1,0,0,0,612,3993,1,0,0,0,614,
  	4014,1,0,0,0,616,4016,1,0,0,0,618,4029,1,0,0,0,620,4147,1,0,0,0,622,4149,
  	1,0,0,0,624,4168,1,0,0,0,626,4241,1,0,0,0,628,4249,1,0,0,0,630,4264,1,
  	0,0,0,632,4266,1,0,0,0,634,4285,1,0,0,0,636,4297,1,0,0,0,638,4313,1,0,
  	0,0,640,4316,1,0,0,0,642,4326,1,0,0,0,644,4345,1,0,0,0,646,4348,1,0,0,
  	0,648,4358,1,0,0,0,650,4377,1,0,0,0,652,4379,1,0,0,0,654,4381,1,0,0,0,
  	656,4388,1,0,0,0,658,4392,1,0,0,0,660,4401,1,0,0,0,662,4404,1,0,0,0,664,
  	4410,1,0,0,0,666,4416,1,0,0,0,668,4421,1,0,0,0,670,4423,1,0,0,0,672,4425,
  	1,0,0,0,674,4427,1,0,0,0,676,4429,1,0,0,0,678,4431,1,0,0,0,680,4433,1,
  	0,0,0,682,4435,1,0,0,0,684,4437,1,0,0,0,686,4439,1,0,0,0,688,4441,1,0,
  	0,0,690,4443,1,0,0,0,692,4445,1,0,0,0,694,4447,1,0,0,0,696,4460,1,0,0,
  	0,698,4465,1,0,0,0,700,4467,1,0,0,0,702,4469,1,0,0,0,704,4471,1,0,0,0,
  	706,4473,1,0,0,0,708,4475,1,0,0,0,710,4477,1,0,0,0,712,4479,1,0,0,0,714,
  	4481,1,0,0,0,716,4483,1,0,0,0,718,4488,1,0,0,0,720,4493,1,0,0,0,722,4501,
  	1,0,0,0,724,4503,1,0,0,0,726,4505,1,0,0,0,728,4507,1,0,0,0,730,4509,1,
  	0,0,0,732,4511,1,0,0,0,734,4513,1,0,0,0,736,4515,1,0,0,0,738,4517,1,0,
  	0,0,740,4519,1,0,0,0,742,4521,1,0,0,0,744,4523,1,0,0,0,746,4525,1,0,0,
  	0,748,4527,1,0,0,0,750,4529,1,0,0,0,752,4531,1,0,0,0,754,4533,1,0,0,0,
  	756,4535,1,0,0,0,758,4537,1,0,0,0,760,4539,1,0,0,0,762,4541,1,0,0,0,764,
  	766,3,2,1,0,765,764,1,0,0,0,766,769,1,0,0,0,767,765,1,0,0,0,767,768,1,
  	0,0,0,768,770,1,0,0,0,769,767,1,0,0,0,770,771,5,0,0,1,771,1,1,0,0,0,772,
  	776,3,4,2,0,773,776,3,8,4,0,774,776,3,44,22,0,775,772,1,0,0,0,775,773,
  	1,0,0,0,775,774,1,0,0,0,776,3,1,0,0,0,777,778,5,94,0,0,778,779,3,728,
  	364,0,779,784,3,10,5,0,780,781,5,24,0,0,781,783,3,10,5,0,782,780,1,0,
  	0,0,783,786,1,0,0,0,784,782,1,0,0,0,784,785,1,0,0,0,785,788,1,0,0,0,786,
  	784,1,0,0,0,787,789,3,6,3,0,788,787,1,0,0,0,788,789,1,0,0,0,789,790,1,
  	0,0,0,790,791,5,147,0,0,791,5,1,0,0,0,792,793,5,106,0,0,793,798,3,10,
  	5,0,794,795,5,24,0,0,795,797,3,10,5,0,796,794,1,0,0,0,797,800,1,0,0,0,
  	798,796,1,0,0,0,798,799,1,0,0,0,799,7,1,0,0,0,800,798,1,0,0,0,801,802,
  	5,83,0,0,802,803,3,10,5,0,803,804,5,147,0,0,804,9,1,0,0,0,805,806,5,206,
  	0,0,806,11,1,0,0,0,807,809,3,14,7,0,808,807,1,0,0,0,809,812,1,0,0,0,810,
  	808,1,0,0,0,810,811,1,0,0,0,811,813,1,0,0,0,812,810,1,0,0,0,813,814,5,
  	0,0,1,814,13,1,0,0,0,815,819,3,16,8,0,816,819,3,294,147,0,817,819,3,44,
  	22,0,818,815,1,0,0,0,818,816,1,0,0,0,818,817,1,0,0,0,819,15,1,0,0,0,820,
  	822,3,694,347,0,821,820,1,0,0,0,822,825,1,0,0,0,823,821,1,0,0,0,823,824,
  	1,0,0,0,824,826,1,0,0,0,825,823,1,0,0,0,826,827,3,18,9,0,827,829,3,730,
  	365,0,828,830,3,20,10,0,829,828,1,0,0,0,829,830,1,0,0,0,830,832,1,0,0,
  	0,831,833,3,22,11,0,832,831,1,0,0,0,832,833,1,0,0,0,833,834,1,0,0,0,834,
  	838,5,147,0,0,835,837,3,36,18,0,836,835,1,0,0,0,837,840,1,0,0,0,838,836,
  	1,0,0,0,838,839,1,0,0,0,839,841,1,0,0,0,840,838,1,0,0,0,841,842,5,56,
  	0,0,842,17,1,0,0,0,843,844,7,0,0,0,844,19,1,0,0,0,845,846,5,78,0,0,846,
  	847,5,96,0,0,847,852,3,66,33,0,848,849,5,24,0,0,849,851,3,66,33,0,850,
  	848,1,0,0,0,851,854,1,0,0,0,852,850,1,0,0,0,852,853,1,0,0,0,853,855,1,
  	0,0,0,854,852,1,0,0,0,855,856,5,142,0,0,856,21,1,0,0,0,857,858,5,96,0,
  	0,858,863,3,34,17,0,859,860,5,24,0,0,860,862,3,34,17,0,861,859,1,0,0,
  	0,862,865,1,0,0,0,863,861,1,0,0,0,863,864,1,0,0,0,864,866,1,0,0,0,865,
  	863,1,0,0,0,866,867,5,142,0,0,867,889,1,0,0,0,868,869,5,96,0,0,869,872,
  	3,24,12,0,870,871,5,24,0,0,871,873,3,24,12,0,872,870,1,0,0,0,873,874,
  	1,0,0,0,874,872,1,0,0,0,874,875,1,0,0,0,875,876,1,0,0,0,876,877,5,142,
  	0,0,877,889,1,0,0,0,878,879,5,96,0,0,879,880,3,26,13,0,880,881,5,142,
  	0,0,881,889,1,0,0,0,882,883,5,96,0,0,883,884,3,28,14,0,884,885,5,142,
  	0,0,885,889,1,0,0,0,886,887,5,96,0,0,887,889,5,142,0,0,888,857,1,0,0,
  	0,888,868,1,0,0,0,888,878,1,0,0,0,888,882,1,0,0,0,888,886,1,0,0,0,889,
  	23,1,0,0,0,890,892,3,26,13,0,891,890,1,0,0,0,891,892,1,0,0,0,892,895,
  	1,0,0,0,893,895,3,28,14,0,894,891,1,0,0,0,894,893,1,0,0,0,895,25,1,0,
  	0,0,896,897,3,30,15,0,897,27,1,0,0,0,898,899,5,45,0,0,899,900,3,740,370,
  	0,900,902,5,96,0,0,901,903,3,30,15,0,902,901,1,0,0,0,902,903,1,0,0,0,
  	903,904,1,0,0,0,904,905,5,142,0,0,905,29,1,0,0,0,906,919,3,32,16,0,907,
  	908,5,92,0,0,908,913,3,32,16,0,909,910,5,24,0,0,910,912,3,32,16,0,911,
  	909,1,0,0,0,912,915,1,0,0,0,913,911,1,0,0,0,913,914,1,0,0,0,914,916,1,
  	0,0,0,915,913,1,0,0,0,916,917,5,134,0,0,917,919,1,0,0,0,918,906,1,0,0,
  	0,918,907,1,0,0,0,919,31,1,0,0,0,920,925,3,740,370,0,921,922,5,91,0,0,
  	922,923,3,614,307,0,923,924,5,133,0,0,924,926,1,0,0,0,925,921,1,0,0,0,
  	925,926,1,0,0,0,926,33,1,0,0,0,927,929,3,694,347,0,928,927,1,0,0,0,929,
  	932,1,0,0,0,930,928,1,0,0,0,930,931,1,0,0,0,931,933,1,0,0,0,932,930,1,
  	0,0,0,933,949,3,72,36,0,934,936,3,694,347,0,935,934,1,0,0,0,936,939,1,
  	0,0,0,937,935,1,0,0,0,937,938,1,0,0,0,938,940,1,0,0,0,939,937,1,0,0,0,
  	940,949,3,74,37,0,941,943,3,694,347,0,942,941,1,0,0,0,943,946,1,0,0,0,
  	944,942,1,0,0,0,944,945,1,0,0,0,945,947,1,0,0,0,946,944,1,0,0,0,947,949,
  	3,76,38,0,948,930,1,0,0,0,948,937,1,0,0,0,948,944,1,0,0,0,949,35,1,0,
  	0,0,950,951,3,34,17,0,951,952,5,147,0,0,952,973,1,0,0,0,953,973,3,38,
  	19,0,954,973,3,266,133,0,955,973,3,412,206,0,956,958,3,694,347,0,957,
  	956,1,0,0,0,958,961,1,0,0,0,959,957,1,0,0,0,959,960,1,0,0,0,960,962,1,
  	0,0,0,961,959,1,0,0,0,962,963,3,66,33,0,963,964,5,147,0,0,964,973,1,0,
  	0,0,965,967,3,694,347,0,966,965,1,0,0,0,967,970,1,0,0,0,968,966,1,0,0,
  	0,968,969,1,0,0,0,969,971,1,0,0,0,970,968,1,0,0,0,971,973,3,68,34,0,972,
  	950,1,0,0,0,972,953,1,0,0,0,972,954,1,0,0,0,972,955,1,0,0,0,972,959,1,
  	0,0,0,972,968,1,0,0,0,973,37,1,0,0,0,974,976,3,694,347,0,975,974,1,0,
  	0,0,976,979,1,0,0,0,977,975,1,0,0,0,977,978,1,0,0,0,978,980,1,0,0,0,979,
  	977,1,0,0,0,980,1054,3,40,20,0,981,983,3,694,347,0,982,981,1,0,0,0,983,
  	986,1,0,0,0,984,982,1,0,0,0,984,985,1,0,0,0,985,987,1,0,0,0,986,984,1,
  	0,0,0,987,988,3,64,32,0,988,989,5,147,0,0,989,1054,1,0,0,0,990,992,3,
  	694,347,0,991,990,1,0,0,0,992,995,1,0,0,0,993,991,1,0,0,0,993,994,1,0,
  	0,0,994,996,1,0,0,0,995,993,1,0,0,0,996,1054,3,42,21,0,997,999,3,694,
  	347,0,998,997,1,0,0,0,999,1002,1,0,0,0,1000,998,1,0,0,0,1000,1001,1,0,
  	0,0,1001,1003,1,0,0,0,1002,1000,1,0,0,0,1003,1054,3,346,173,0,1004,1006,
  	3,694,347,0,1005,1004,1,0,0,0,1006,1009,1,0,0,0,1007,1005,1,0,0,0,1007,
  	1008,1,0,0,0,1008,1010,1,0,0,0,1009,1007,1,0,0,0,1010,1054,3,196,98,0,
  	1011,1013,3,694,347,0,1012,1011,1,0,0,0,1013,1016,1,0,0,0,1014,1012,1,
  	0,0,0,1014,1015,1,0,0,0,1015,1017,1,0,0,0,1016,1014,1,0,0,0,1017,1054,
  	3,246,123,0,1018,1020,3,694,347,0,1019,1018,1,0,0,0,1020,1023,1,0,0,0,
  	1021,1019,1,0,0,0,1021,1022,1,0,0,0,1022,1024,1,0,0,0,1023,1021,1,0,0,
  	0,1024,1054,3,340,170,0,1025,1027,3,694,347,0,1026,1025,1,0,0,0,1027,
  	1030,1,0,0,0,1028,1026,1,0,0,0,1028,1029,1,0,0,0,1029,1031,1,0,0,0,1030,
  	1028,1,0,0,0,1031,1054,3,352,176,0,1032,1034,3,694,347,0,1033,1032,1,
  	0,0,0,1034,1037,1,0,0,0,1035,1033,1,0,0,0,1035,1036,1,0,0,0,1036,1038,
  	1,0,0,0,1037,1035,1,0,0,0,1038,1054,3,354,177,0,1039,1041,3,694,347,0,
  	1040,1039,1,0,0,0,1041,1044,1,0,0,0,1042,1040,1,0,0,0,1042,1043,1,0,0,
  	0,1043,1045,1,0,0,0,1044,1042,1,0,0,0,1045,1054,3,272,136,0,1046,1048,
  	3,694,347,0,1047,1046,1,0,0,0,1048,1051,1,0,0,0,1049,1047,1,0,0,0,1049,
  	1050,1,0,0,0,1050,1052,1,0,0,0,1051,1049,1,0,0,0,1052,1054,3,280,140,
  	0,1053,977,1,0,0,0,1053,984,1,0,0,0,1053,993,1,0,0,0,1053,1000,1,0,0,
  	0,1053,1007,1,0,0,0,1053,1014,1,0,0,0,1053,1021,1,0,0,0,1053,1028,1,0,
  	0,0,1053,1035,1,0,0,0,1053,1042,1,0,0,0,1053,1049,1,0,0,0,1054,39,1,0,
  	0,0,1055,1066,3,82,41,0,1056,1066,3,88,44,0,1057,1066,3,80,40,0,1058,
  	1066,3,84,42,0,1059,1066,3,90,45,0,1060,1066,3,86,43,0,1061,1066,3,78,
  	39,0,1062,1066,3,268,134,0,1063,1066,3,170,85,0,1064,1066,3,160,80,0,
  	1065,1055,1,0,0,0,1065,1056,1,0,0,0,1065,1057,1,0,0,0,1065,1058,1,0,0,
  	0,1065,1059,1,0,0,0,1065,1060,1,0,0,0,1065,1061,1,0,0,0,1065,1062,1,0,
  	0,0,1065,1063,1,0,0,0,1065,1064,1,0,0,0,1066,41,1,0,0,0,1067,1068,5,28,
  	0,0,1068,1069,3,114,57,0,1069,1070,5,147,0,0,1070,43,1,0,0,0,1071,1072,
  	5,25,0,0,1072,1073,3,704,352,0,1073,1074,5,147,0,0,1074,1078,3,46,23,
  	0,1075,1077,3,50,25,0,1076,1075,1,0,0,0,1077,1080,1,0,0,0,1078,1076,1,
  	0,0,0,1078,1079,1,0,0,0,1079,1081,1,0,0,0,1080,1078,1,0,0,0,1081,1082,
  	5,53,0,0,1082,45,1,0,0,0,1083,1087,5,29,0,0,1084,1086,3,48,24,0,1085,
  	1084,1,0,0,0,1086,1089,1,0,0,0,1087,1085,1,0,0,0,1087,1088,1,0,0,0,1088,
  	1090,1,0,0,0,1089,1087,1,0,0,0,1090,1091,5,147,0,0,1091,47,1,0,0,0,1092,
  	1093,3,728,364,0,1093,1094,5,45,0,0,1094,1096,1,0,0,0,1095,1092,1,0,0,
  	0,1095,1096,1,0,0,0,1096,1097,1,0,0,0,1097,1098,3,702,351,0,1098,49,1,
  	0,0,0,1099,1100,3,52,26,0,1100,1101,3,60,30,0,1101,1102,5,147,0,0,1102,
  	1120,1,0,0,0,1103,1104,3,54,27,0,1104,1105,3,60,30,0,1105,1106,5,147,
  	0,0,1106,1120,1,0,0,0,1107,1108,3,54,27,0,1108,1109,3,62,31,0,1109,1110,
  	5,147,0,0,1110,1120,1,0,0,0,1111,1112,3,58,29,0,1112,1113,3,60,30,0,1113,
  	1114,5,147,0,0,1114,1120,1,0,0,0,1115,1116,3,58,29,0,1116,1117,3,62,31,
  	0,1117,1118,5,147,0,0,1118,1120,1,0,0,0,1119,1099,1,0,0,0,1119,1103,1,
  	0,0,0,1119,1107,1,0,0,0,1119,1111,1,0,0,0,1119,1115,1,0,0,0,1120,51,1,
  	0,0,0,1121,1122,5,27,0,0,1122,53,1,0,0,0,1123,1124,5,87,0,0,1124,1125,
  	3,56,28,0,1125,55,1,0,0,0,1126,1131,3,756,378,0,1127,1128,5,45,0,0,1128,
  	1130,3,726,363,0,1129,1127,1,0,0,0,1130,1133,1,0,0,0,1131,1129,1,0,0,
  	0,1131,1132,1,0,0,0,1132,57,1,0,0,0,1133,1131,1,0,0,0,1134,1138,5,21,
  	0,0,1135,1136,3,728,364,0,1136,1137,5,45,0,0,1137,1139,1,0,0,0,1138,1135,
  	1,0,0,0,1138,1139,1,0,0,0,1139,1140,1,0,0,0,1140,1141,3,702,351,0,1141,
  	59,1,0,0,0,1142,1146,5,93,0,0,1143,1145,3,728,364,0,1144,1143,1,0,0,0,
  	1145,1148,1,0,0,0,1146,1144,1,0,0,0,1146,1147,1,0,0,0,1147,61,1,0,0,0,
  	1148,1146,1,0,0,0,1149,1153,5,175,0,0,1150,1151,3,728,364,0,1151,1152,
  	5,45,0,0,1152,1154,1,0,0,0,1153,1150,1,0,0,0,1153,1154,1,0,0,0,1154,1155,
  	1,0,0,0,1155,1158,3,702,351,0,1156,1157,5,22,0,0,1157,1159,5,25,0,0,1158,
  	1156,1,0,0,0,1158,1159,1,0,0,0,1159,63,1,0,0,0,1160,1162,5,95,0,0,1161,
  	1163,5,150,0,0,1162,1161,1,0,0,0,1162,1163,1,0,0,0,1163,1165,1,0,0,0,
  	1164,1166,3,158,79,0,1165,1164,1,0,0,0,1165,1166,1,0,0,0,1166,1167,1,
  	0,0,0,1167,1173,3,126,63,0,1168,1169,5,95,0,0,1169,1170,3,70,35,0,1170,
  	1171,3,126,63,0,1171,1173,1,0,0,0,1172,1160,1,0,0,0,1172,1168,1,0,0,0,
  	1173,65,1,0,0,0,1174,1176,5,119,0,0,1175,1177,5,150,0,0,1176,1175,1,0,
  	0,0,1176,1177,1,0,0,0,1177,1179,1,0,0,0,1178,1180,3,158,79,0,1179,1178,
  	1,0,0,0,1179,1180,1,0,0,0,1180,1181,1,0,0,0,1181,1187,3,126,63,0,1182,
  	1183,5,119,0,0,1183,1184,3,70,35,0,1184,1185,3,126,63,0,1185,1187,1,0,
  	0,0,1186,1174,1,0,0,0,1186,1182,1,0,0,0,1187,67,1,0,0,0,1188,1190,5,154,
  	0,0,1189,1191,3,158,79,0,1190,1189,1,0,0,0,1190,1191,1,0,0,0,1191,1192,
  	1,0,0,0,1192,1193,3,132,66,0,1193,1194,5,147,0,0,1194,69,1,0,0,0,1195,
  	1196,7,1,0,0,1196,71,1,0,0,0,1197,1199,5,85,0,0,1198,1200,3,92,46,0,1199,
  	1198,1,0,0,0,1199,1200,1,0,0,0,1200,1202,1,0,0,0,1201,1203,5,150,0,0,
  	1202,1201,1,0,0,0,1202,1203,1,0,0,0,1203,1205,1,0,0,0,1204,1206,3,158,
  	79,0,1205,1204,1,0,0,0,1205,1206,1,0,0,0,1206,1207,1,0,0,0,1207,1208,
  	3,128,64,0,1208,73,1,0,0,0,1209,1211,5,86,0,0,1210,1212,3,92,46,0,1211,
  	1210,1,0,0,0,1211,1212,1,0,0,0,1212,1214,1,0,0,0,1213,1215,5,150,0,0,
  	1214,1213,1,0,0,0,1214,1215,1,0,0,0,1215,1217,1,0,0,0,1216,1218,3,158,
  	79,0,1217,1216,1,0,0,0,1217,1218,1,0,0,0,1218,1219,1,0,0,0,1219,1220,
  	3,128,64,0,1220,75,1,0,0,0,1221,1223,5,118,0,0,1222,1224,3,92,46,0,1223,
  	1222,1,0,0,0,1223,1224,1,0,0,0,1224,1226,1,0,0,0,1225,1227,5,150,0,0,
  	1226,1225,1,0,0,0,1226,1227,1,0,0,0,1227,1229,1,0,0,0,1228,1230,3,158,
  	79,0,1229,1228,1,0,0,0,1229,1230,1,0,0,0,1230,1231,1,0,0,0,1231,1246,
  	3,128,64,0,1232,1233,5,118,0,0,1233,1235,5,138,0,0,1234,1236,5,150,0,
  	0,1235,1234,1,0,0,0,1235,1236,1,0,0,0,1236,1238,1,0,0,0,1237,1239,3,158,
  	79,0,1238,1237,1,0,0,0,1238,1239,1,0,0,0,1239,1240,1,0,0,0,1240,1246,
  	3,136,68,0,1241,1242,5,118,0,0,1242,1243,3,94,47,0,1243,1244,3,136,68,
  	0,1244,1246,1,0,0,0,1245,1221,1,0,0,0,1245,1232,1,0,0,0,1245,1241,1,0,
  	0,0,1246,77,1,0,0,0,1247,1248,5,65,0,0,1248,1249,3,116,58,0,1249,1250,
  	5,147,0,0,1250,79,1,0,0,0,1251,1252,5,88,0,0,1252,1253,3,134,67,0,1253,
  	1254,5,147,0,0,1254,81,1,0,0,0,1255,1257,3,92,46,0,1256,1258,5,150,0,
  	0,1257,1256,1,0,0,0,1257,1258,1,0,0,0,1258,1260,1,0,0,0,1259,1261,3,108,
  	54,0,1260,1259,1,0,0,0,1260,1261,1,0,0,0,1261,1262,1,0,0,0,1262,1263,
  	3,122,61,0,1263,1264,5,147,0,0,1264,1370,1,0,0,0,1265,1267,3,92,46,0,
  	1266,1268,3,100,50,0,1267,1266,1,0,0,0,1267,1268,1,0,0,0,1268,1270,1,
  	0,0,0,1269,1271,5,150,0,0,1270,1269,1,0,0,0,1270,1271,1,0,0,0,1271,1273,
  	1,0,0,0,1272,1274,3,108,54,0,1273,1272,1,0,0,0,1273,1274,1,0,0,0,1274,
  	1275,1,0,0,0,1275,1276,3,120,60,0,1276,1277,5,147,0,0,1277,1370,1,0,0,
  	0,1278,1280,3,92,46,0,1279,1281,7,2,0,0,1280,1279,1,0,0,0,1280,1281,1,
  	0,0,0,1281,1283,1,0,0,0,1282,1284,5,150,0,0,1283,1282,1,0,0,0,1283,1284,
  	1,0,0,0,1284,1285,1,0,0,0,1285,1287,3,158,79,0,1286,1288,3,108,54,0,1287,
  	1286,1,0,0,0,1287,1288,1,0,0,0,1288,1289,1,0,0,0,1289,1290,3,122,61,0,
  	1290,1291,5,147,0,0,1291,1370,1,0,0,0,1292,1294,3,92,46,0,1293,1295,3,
  	100,50,0,1294,1293,1,0,0,0,1294,1295,1,0,0,0,1295,1297,1,0,0,0,1296,1298,
  	7,2,0,0,1297,1296,1,0,0,0,1297,1298,1,0,0,0,1298,1300,1,0,0,0,1299,1301,
  	5,150,0,0,1300,1299,1,0,0,0,1300,1301,1,0,0,0,1301,1302,1,0,0,0,1302,
  	1304,3,158,79,0,1303,1305,3,108,54,0,1304,1303,1,0,0,0,1304,1305,1,0,
  	0,0,1305,1306,1,0,0,0,1306,1307,3,120,60,0,1307,1308,5,147,0,0,1308,1370,
  	1,0,0,0,1309,1311,5,173,0,0,1310,1312,3,106,53,0,1311,1310,1,0,0,0,1311,
  	1312,1,0,0,0,1312,1314,1,0,0,0,1313,1315,5,150,0,0,1314,1313,1,0,0,0,
  	1314,1315,1,0,0,0,1315,1317,1,0,0,0,1316,1318,3,108,54,0,1317,1316,1,
  	0,0,0,1317,1318,1,0,0,0,1318,1319,1,0,0,0,1319,1320,3,122,61,0,1320,1321,
  	5,147,0,0,1321,1370,1,0,0,0,1322,1324,5,173,0,0,1323,1325,3,100,50,0,
  	1324,1323,1,0,0,0,1324,1325,1,0,0,0,1325,1327,1,0,0,0,1326,1328,5,150,
  	0,0,1327,1326,1,0,0,0,1327,1328,1,0,0,0,1328,1330,1,0,0,0,1329,1331,3,
  	108,54,0,1330,1329,1,0,0,0,1330,1331,1,0,0,0,1331,1332,1,0,0,0,1332,1333,
  	3,120,60,0,1333,1334,5,147,0,0,1334,1370,1,0,0,0,1335,1337,5,173,0,0,
  	1336,1338,3,106,53,0,1337,1336,1,0,0,0,1337,1338,1,0,0,0,1338,1340,1,
  	0,0,0,1339,1341,7,2,0,0,1340,1339,1,0,0,0,1340,1341,1,0,0,0,1341,1343,
  	1,0,0,0,1342,1344,5,150,0,0,1343,1342,1,0,0,0,1343,1344,1,0,0,0,1344,
  	1345,1,0,0,0,1345,1347,3,158,79,0,1346,1348,3,108,54,0,1347,1346,1,0,
  	0,0,1347,1348,1,0,0,0,1348,1349,1,0,0,0,1349,1350,3,122,61,0,1350,1351,
  	5,147,0,0,1351,1370,1,0,0,0,1352,1354,5,173,0,0,1353,1355,3,100,50,0,
  	1354,1353,1,0,0,0,1354,1355,1,0,0,0,1355,1357,1,0,0,0,1356,1358,7,2,0,
  	0,1357,1356,1,0,0,0,1357,1358,1,0,0,0,1358,1360,1,0,0,0,1359,1361,5,150,
  	0,0,1360,1359,1,0,0,0,1360,1361,1,0,0,0,1361,1362,1,0,0,0,1362,1364,3,
  	158,79,0,1363,1365,3,108,54,0,1364,1363,1,0,0,0,1364,1365,1,0,0,0,1365,
  	1366,1,0,0,0,1366,1367,3,120,60,0,1367,1368,5,147,0,0,1368,1370,1,0,0,
  	0,1369,1255,1,0,0,0,1369,1265,1,0,0,0,1369,1278,1,0,0,0,1369,1292,1,0,
  	0,0,1369,1309,1,0,0,0,1369,1322,1,0,0,0,1369,1335,1,0,0,0,1369,1352,1,
  	0,0,0,1370,83,1,0,0,0,1371,1372,5,136,0,0,1372,1373,3,130,65,0,1373,1374,
  	5,147,0,0,1374,85,1,0,0,0,1375,1376,5,137,0,0,1376,1377,3,130,65,0,1377,
  	1378,5,147,0,0,1378,87,1,0,0,0,1379,1381,5,138,0,0,1380,1382,5,150,0,
  	0,1381,1380,1,0,0,0,1381,1382,1,0,0,0,1382,1384,1,0,0,0,1383,1385,3,158,
  	79,0,1384,1383,1,0,0,0,1384,1385,1,0,0,0,1385,1386,1,0,0,0,1386,1387,
  	3,134,67,0,1387,1388,5,147,0,0,1388,89,1,0,0,0,1389,1390,5,164,0,0,1390,
  	1391,3,134,67,0,1391,1392,5,147,0,0,1392,91,1,0,0,0,1393,1394,7,3,0,0,
  	1394,93,1,0,0,0,1395,1396,7,4,0,0,1396,95,1,0,0,0,1397,1401,3,742,371,
  	0,1398,1400,3,156,78,0,1399,1398,1,0,0,0,1400,1403,1,0,0,0,1401,1399,
  	1,0,0,0,1401,1402,1,0,0,0,1402,1409,1,0,0,0,1403,1401,1,0,0,0,1404,1405,
  	3,742,371,0,1405,1406,5,61,0,0,1406,1407,3,610,305,0,1407,1409,1,0,0,
  	0,1408,1397,1,0,0,0,1408,1404,1,0,0,0,1409,97,1,0,0,0,1410,1414,3,762,
  	381,0,1411,1413,3,156,78,0,1412,1411,1,0,0,0,1413,1416,1,0,0,0,1414,1412,
  	1,0,0,0,1414,1415,1,0,0,0,1415,1422,1,0,0,0,1416,1414,1,0,0,0,1417,1418,
  	3,762,381,0,1418,1419,5,61,0,0,1419,1420,3,610,305,0,1420,1422,1,0,0,
  	0,1421,1410,1,0,0,0,1421,1417,1,0,0,0,1422,99,1,0,0,0,1423,1424,5,96,
  	0,0,1424,1425,3,102,51,0,1425,1426,5,24,0,0,1426,1427,3,104,52,0,1427,
  	1428,5,142,0,0,1428,1460,1,0,0,0,1429,1430,5,96,0,0,1430,1431,3,104,52,
  	0,1431,1432,5,24,0,0,1432,1433,3,102,51,0,1433,1434,5,142,0,0,1434,1460,
  	1,0,0,0,1435,1436,5,96,0,0,1436,1437,3,102,51,0,1437,1438,5,24,0,0,1438,
  	1439,5,79,0,0,1439,1440,5,142,0,0,1440,1460,1,0,0,0,1441,1442,5,96,0,
  	0,1442,1443,3,104,52,0,1443,1444,5,24,0,0,1444,1445,5,80,0,0,1445,1446,
  	5,142,0,0,1446,1460,1,0,0,0,1447,1448,5,96,0,0,1448,1449,5,80,0,0,1449,
  	1450,5,24,0,0,1450,1451,3,104,52,0,1451,1452,5,142,0,0,1452,1460,1,0,
  	0,0,1453,1454,5,96,0,0,1454,1455,5,79,0,0,1455,1456,5,24,0,0,1456,1457,
  	3,102,51,0,1457,1458,5,142,0,0,1458,1460,1,0,0,0,1459,1423,1,0,0,0,1459,
  	1429,1,0,0,0,1459,1435,1,0,0,0,1459,1441,1,0,0,0,1459,1447,1,0,0,0,1459,
  	1453,1,0,0,0,1460,101,1,0,0,0,1461,1462,7,5,0,0,1462,103,1,0,0,0,1463,
  	1464,7,6,0,0,1464,105,1,0,0,0,1465,1466,5,96,0,0,1466,1467,5,152,0,0,
  	1467,1475,5,142,0,0,1468,1469,5,96,0,0,1469,1470,5,102,0,0,1470,1475,
  	5,142,0,0,1471,1472,5,96,0,0,1472,1473,5,90,0,0,1473,1475,5,142,0,0,1474,
  	1465,1,0,0,0,1474,1468,1,0,0,0,1474,1471,1,0,0,0,1475,107,1,0,0,0,1476,
  	1477,5,78,0,0,1477,1492,3,112,56,0,1478,1479,5,78,0,0,1479,1480,5,96,
  	0,0,1480,1487,3,622,311,0,1481,1482,5,24,0,0,1482,1485,3,622,311,0,1483,
  	1484,5,24,0,0,1484,1486,3,622,311,0,1485,1483,1,0,0,0,1485,1486,1,0,0,
  	0,1486,1488,1,0,0,0,1487,1481,1,0,0,0,1487,1488,1,0,0,0,1488,1489,1,0,
  	0,0,1489,1490,5,142,0,0,1490,1492,1,0,0,0,1491,1476,1,0,0,0,1491,1478,
  	1,0,0,0,1492,109,1,0,0,0,1493,1494,5,78,0,0,1494,1505,3,112,56,0,1495,
  	1496,5,78,0,0,1496,1497,5,96,0,0,1497,1500,3,622,311,0,1498,1499,5,24,
  	0,0,1499,1501,3,622,311,0,1500,1498,1,0,0,0,1500,1501,1,0,0,0,1501,1502,
  	1,0,0,0,1502,1503,5,142,0,0,1503,1505,1,0,0,0,1504,1493,1,0,0,0,1504,
  	1495,1,0,0,0,1505,111,1,0,0,0,1506,1510,3,674,337,0,1507,1510,3,658,329,
  	0,1508,1510,3,722,361,0,1509,1506,1,0,0,0,1509,1507,1,0,0,0,1509,1508,
  	1,0,0,0,1510,113,1,0,0,0,1511,1516,3,140,70,0,1512,1513,5,24,0,0,1513,
  	1515,3,140,70,0,1514,1512,1,0,0,0,1515,1518,1,0,0,0,1516,1514,1,0,0,0,
  	1516,1517,1,0,0,0,1517,115,1,0,0,0,1518,1516,1,0,0,0,1519,1524,3,118,
  	59,0,1520,1521,5,24,0,0,1521,1523,3,118,59,0,1522,1520,1,0,0,0,1523,1526,
  	1,0,0,0,1524,1522,1,0,0,0,1524,1525,1,0,0,0,1525,117,1,0,0,0,1526,1524,
  	1,0,0,0,1527,1531,3,708,354,0,1528,1530,3,156,78,0,1529,1528,1,0,0,0,
  	1530,1533,1,0,0,0,1531,1529,1,0,0,0,1531,1532,1,0,0,0,1532,119,1,0,0,
  	0,1533,1531,1,0,0,0,1534,1539,3,142,71,0,1535,1536,5,24,0,0,1536,1538,
  	3,142,71,0,1537,1535,1,0,0,0,1538,1541,1,0,0,0,1539,1537,1,0,0,0,1539,
  	1540,1,0,0,0,1540,121,1,0,0,0,1541,1539,1,0,0,0,1542,1547,3,124,62,0,
  	1543,1544,5,24,0,0,1544,1546,3,124,62,0,1545,1543,1,0,0,0,1546,1549,1,
  	0,0,0,1547,1545,1,0,0,0,1547,1548,1,0,0,0,1548,123,1,0,0,0,1549,1547,
  	1,0,0,0,1550,1554,3,734,367,0,1551,1553,3,156,78,0,1552,1551,1,0,0,0,
  	1553,1556,1,0,0,0,1554,1552,1,0,0,0,1554,1555,1,0,0,0,1555,125,1,0,0,
  	0,1556,1554,1,0,0,0,1557,1562,3,144,72,0,1558,1559,5,24,0,0,1559,1561,
  	3,144,72,0,1560,1558,1,0,0,0,1561,1564,1,0,0,0,1562,1560,1,0,0,0,1562,
  	1563,1,0,0,0,1563,127,1,0,0,0,1564,1562,1,0,0,0,1565,1570,3,740,370,0,
  	1566,1567,5,24,0,0,1567,1569,3,740,370,0,1568,1566,1,0,0,0,1569,1572,
  	1,0,0,0,1570,1568,1,0,0,0,1570,1571,1,0,0,0,1571,129,1,0,0,0,1572,1570,
  	1,0,0,0,1573,1578,3,96,48,0,1574,1575,5,24,0,0,1575,1577,3,96,48,0,1576,
  	1574,1,0,0,0,1577,1580,1,0,0,0,1578,1576,1,0,0,0,1578,1579,1,0,0,0,1579,
  	131,1,0,0,0,1580,1578,1,0,0,0,1581,1586,3,146,73,0,1582,1583,5,24,0,0,
  	1583,1585,3,146,73,0,1584,1582,1,0,0,0,1585,1588,1,0,0,0,1586,1584,1,
  	0,0,0,1586,1587,1,0,0,0,1587,133,1,0,0,0,1588,1586,1,0,0,0,1589,1594,
  	3,98,49,0,1590,1591,5,24,0,0,1591,1593,3,98,49,0,1592,1590,1,0,0,0,1593,
  	1596,1,0,0,0,1594,1592,1,0,0,0,1594,1595,1,0,0,0,1595,135,1,0,0,0,1596,
  	1594,1,0,0,0,1597,1602,3,138,69,0,1598,1599,5,24,0,0,1599,1601,3,138,
  	69,0,1600,1598,1,0,0,0,1601,1604,1,0,0,0,1602,1600,1,0,0,0,1602,1603,
  	1,0,0,0,1603,137,1,0,0,0,1604,1602,1,0,0,0,1605,1608,3,740,370,0,1606,
  	1607,5,61,0,0,1607,1609,3,610,305,0,1608,1606,1,0,0,0,1608,1609,1,0,0,
  	0,1609,139,1,0,0,0,1610,1611,3,718,359,0,1611,1612,5,61,0,0,1612,1613,
  	3,612,306,0,1613,141,1,0,0,0,1614,1615,3,734,367,0,1615,1616,5,61,0,0,
  	1616,1617,3,618,309,0,1617,143,1,0,0,0,1618,1619,3,738,369,0,1619,1620,
  	5,61,0,0,1620,1621,3,612,306,0,1621,145,1,0,0,0,1622,1623,3,746,373,0,
  	1623,1624,5,61,0,0,1624,1625,3,612,306,0,1625,1628,1,0,0,0,1626,1628,
  	3,148,74,0,1627,1622,1,0,0,0,1627,1626,1,0,0,0,1628,147,1,0,0,0,1629,
  	1630,5,120,0,0,1630,1631,5,61,0,0,1631,1632,5,96,0,0,1632,1635,3,152,
  	76,0,1633,1634,5,24,0,0,1634,1636,3,150,75,0,1635,1633,1,0,0,0,1635,1636,
  	1,0,0,0,1636,1637,1,0,0,0,1637,1638,5,142,0,0,1638,1653,1,0,0,0,1639,
  	1640,5,120,0,0,1640,1641,3,432,216,0,1641,1642,5,31,0,0,1642,1643,3,434,
  	217,0,1643,1644,5,61,0,0,1644,1645,5,96,0,0,1645,1648,3,152,76,0,1646,
  	1647,5,24,0,0,1647,1649,3,150,75,0,1648,1646,1,0,0,0,1648,1649,1,0,0,
  	0,1649,1650,1,0,0,0,1650,1651,5,142,0,0,1651,1653,1,0,0,0,1652,1629,1,
  	0,0,0,1652,1639,1,0,0,0,1653,149,1,0,0,0,1654,1655,3,154,77,0,1655,151,
  	1,0,0,0,1656,1657,3,154,77,0,1657,153,1,0,0,0,1658,1659,3,612,306,0,1659,
  	155,1,0,0,0,1660,1661,5,91,0,0,1661,1662,3,616,308,0,1662,1663,5,22,0,
  	0,1663,1664,3,616,308,0,1664,1665,5,133,0,0,1665,157,1,0,0,0,1666,1667,
  	5,91,0,0,1667,1668,3,628,314,0,1668,1669,5,22,0,0,1669,1670,3,620,310,
  	0,1670,1671,5,133,0,0,1671,159,1,0,0,0,1672,1674,5,70,0,0,1673,1675,5,
  	11,0,0,1674,1673,1,0,0,0,1674,1675,1,0,0,0,1675,1677,1,0,0,0,1676,1678,
  	3,168,84,0,1677,1676,1,0,0,0,1677,1678,1,0,0,0,1678,1679,1,0,0,0,1679,
  	1680,3,710,355,0,1680,1682,5,147,0,0,1681,1683,3,162,81,0,1682,1681,1,
  	0,0,0,1683,1684,1,0,0,0,1684,1682,1,0,0,0,1684,1685,1,0,0,0,1685,1686,
  	1,0,0,0,1686,1687,3,374,187,0,1687,1688,5,54,0,0,1688,1711,1,0,0,0,1689,
  	1691,5,70,0,0,1690,1692,5,11,0,0,1691,1690,1,0,0,0,1691,1692,1,0,0,0,
  	1692,1694,1,0,0,0,1693,1695,3,168,84,0,1694,1693,1,0,0,0,1694,1695,1,
  	0,0,0,1695,1696,1,0,0,0,1696,1697,3,710,355,0,1697,1698,5,96,0,0,1698,
  	1699,3,164,82,0,1699,1700,5,142,0,0,1700,1704,5,147,0,0,1701,1703,3,186,
  	93,0,1702,1701,1,0,0,0,1703,1706,1,0,0,0,1704,1702,1,0,0,0,1704,1705,
  	1,0,0,0,1705,1707,1,0,0,0,1706,1704,1,0,0,0,1707,1708,3,374,187,0,1708,
  	1709,5,54,0,0,1709,1711,1,0,0,0,1710,1672,1,0,0,0,1710,1689,1,0,0,0,1711,
  	161,1,0,0,0,1712,1723,3,186,93,0,1713,1715,3,694,347,0,1714,1713,1,0,
  	0,0,1715,1718,1,0,0,0,1716,1714,1,0,0,0,1716,1717,1,0,0,0,1717,1719,1,
  	0,0,0,1718,1716,1,0,0,0,1719,1720,3,178,89,0,1720,1721,5,147,0,0,1721,
  	1723,1,0,0,0,1722,1712,1,0,0,0,1722,1716,1,0,0,0,1723,163,1,0,0,0,1724,
  	1729,3,166,83,0,1725,1726,5,24,0,0,1726,1728,3,166,83,0,1727,1725,1,0,
  	0,0,1728,1731,1,0,0,0,1729,1727,1,0,0,0,1729,1730,1,0,0,0,1730,165,1,
  	0,0,0,1731,1729,1,0,0,0,1732,1734,3,694,347,0,1733,1732,1,0,0,0,1734,
  	1737,1,0,0,0,1735,1733,1,0,0,0,1735,1736,1,0,0,0,1736,1738,1,0,0,0,1737,
  	1735,1,0,0,0,1738,1739,3,178,89,0,1739,167,1,0,0,0,1740,1750,3,158,79,
  	0,1741,1743,5,150,0,0,1742,1744,3,158,79,0,1743,1742,1,0,0,0,1743,1744,
  	1,0,0,0,1744,1750,1,0,0,0,1745,1750,5,88,0,0,1746,1750,5,136,0,0,1747,
  	1750,5,137,0,0,1748,1750,5,164,0,0,1749,1740,1,0,0,0,1749,1741,1,0,0,
  	0,1749,1745,1,0,0,0,1749,1746,1,0,0,0,1749,1747,1,0,0,0,1749,1748,1,0,
  	0,0,1750,169,1,0,0,0,1751,1753,5,160,0,0,1752,1754,5,11,0,0,1753,1752,
  	1,0,0,0,1753,1754,1,0,0,0,1754,1755,1,0,0,0,1755,1756,3,752,376,0,1756,
  	1760,5,147,0,0,1757,1759,3,172,86,0,1758,1757,1,0,0,0,1759,1762,1,0,0,
  	0,1760,1758,1,0,0,0,1760,1761,1,0,0,0,1761,1763,1,0,0,0,1762,1760,1,0,
  	0,0,1763,1764,3,372,186,0,1764,1765,5,60,0,0,1765,1787,1,0,0,0,1766,1768,
  	5,160,0,0,1767,1769,5,11,0,0,1768,1767,1,0,0,0,1768,1769,1,0,0,0,1769,
  	1770,1,0,0,0,1770,1771,3,752,376,0,1771,1773,5,96,0,0,1772,1774,3,174,
  	87,0,1773,1772,1,0,0,0,1773,1774,1,0,0,0,1774,1775,1,0,0,0,1775,1776,
  	5,142,0,0,1776,1780,5,147,0,0,1777,1779,3,186,93,0,1778,1777,1,0,0,0,
  	1779,1782,1,0,0,0,1780,1778,1,0,0,0,1780,1781,1,0,0,0,1781,1783,1,0,0,
  	0,1782,1780,1,0,0,0,1783,1784,3,372,186,0,1784,1785,5,60,0,0,1785,1787,
  	1,0,0,0,1786,1751,1,0,0,0,1786,1766,1,0,0,0,1787,171,1,0,0,0,1788,1817,
  	3,186,93,0,1789,1791,3,694,347,0,1790,1789,1,0,0,0,1791,1794,1,0,0,0,
  	1792,1790,1,0,0,0,1792,1793,1,0,0,0,1793,1795,1,0,0,0,1794,1792,1,0,0,
  	0,1795,1796,3,178,89,0,1796,1797,5,147,0,0,1797,1817,1,0,0,0,1798,1800,
  	3,694,347,0,1799,1798,1,0,0,0,1800,1803,1,0,0,0,1801,1799,1,0,0,0,1801,
  	1802,1,0,0,0,1802,1804,1,0,0,0,1803,1801,1,0,0,0,1804,1805,3,180,90,0,
  	1805,1806,5,147,0,0,1806,1817,1,0,0,0,1807,1809,3,694,347,0,1808,1807,
  	1,0,0,0,1809,1812,1,0,0,0,1810,1808,1,0,0,0,1810,1811,1,0,0,0,1811,1813,
  	1,0,0,0,1812,1810,1,0,0,0,1813,1814,3,182,91,0,1814,1815,5,147,0,0,1815,
  	1817,1,0,0,0,1816,1788,1,0,0,0,1816,1792,1,0,0,0,1816,1801,1,0,0,0,1816,
  	1810,1,0,0,0,1817,173,1,0,0,0,1818,1823,3,176,88,0,1819,1820,5,24,0,0,
  	1820,1822,3,176,88,0,1821,1819,1,0,0,0,1822,1825,1,0,0,0,1823,1821,1,
  	0,0,0,1823,1824,1,0,0,0,1824,175,1,0,0,0,1825,1823,1,0,0,0,1826,1828,
  	3,694,347,0,1827,1826,1,0,0,0,1828,1831,1,0,0,0,1829,1827,1,0,0,0,1829,
  	1830,1,0,0,0,1830,1832,1,0,0,0,1831,1829,1,0,0,0,1832,1848,3,178,89,0,
  	1833,1835,3,694,347,0,1834,1833,1,0,0,0,1835,1838,1,0,0,0,1836,1834,1,
  	0,0,0,1836,1837,1,0,0,0,1837,1839,1,0,0,0,1838,1836,1,0,0,0,1839,1848,
  	3,180,90,0,1840,1842,3,694,347,0,1841,1840,1,0,0,0,1842,1845,1,0,0,0,
  	1843,1841,1,0,0,0,1843,1844,1,0,0,0,1844,1846,1,0,0,0,1845,1843,1,0,0,
  	0,1846,1848,3,182,91,0,1847,1829,1,0,0,0,1847,1836,1,0,0,0,1847,1843,
  	1,0,0,0,1848,177,1,0,0,0,1849,1851,5,86,0,0,1850,1852,5,138,0,0,1851,
  	1850,1,0,0,0,1851,1852,1,0,0,0,1852,1854,1,0,0,0,1853,1855,5,150,0,0,
  	1854,1853,1,0,0,0,1854,1855,1,0,0,0,1855,1857,1,0,0,0,1856,1858,3,158,
  	79,0,1857,1856,1,0,0,0,1857,1858,1,0,0,0,1858,1859,1,0,0,0,1859,1865,
  	3,128,64,0,1860,1861,5,86,0,0,1861,1862,3,184,92,0,1862,1863,3,128,64,
  	0,1863,1865,1,0,0,0,1864,1849,1,0,0,0,1864,1860,1,0,0,0,1865,179,1,0,
  	0,0,1866,1868,5,118,0,0,1867,1869,5,138,0,0,1868,1867,1,0,0,0,1868,1869,
  	1,0,0,0,1869,1871,1,0,0,0,1870,1872,5,150,0,0,1871,1870,1,0,0,0,1871,
  	1872,1,0,0,0,1872,1874,1,0,0,0,1873,1875,3,158,79,0,1874,1873,1,0,0,0,
  	1874,1875,1,0,0,0,1875,1876,1,0,0,0,1876,1882,3,128,64,0,1877,1878,5,
  	118,0,0,1878,1879,3,184,92,0,1879,1880,3,128,64,0,1880,1882,1,0,0,0,1881,
  	1866,1,0,0,0,1881,1877,1,0,0,0,1882,181,1,0,0,0,1883,1885,5,85,0,0,1884,
  	1886,5,138,0,0,1885,1884,1,0,0,0,1885,1886,1,0,0,0,1886,1888,1,0,0,0,
  	1887,1889,5,150,0,0,1888,1887,1,0,0,0,1888,1889,1,0,0,0,1889,1891,1,0,
  	0,0,1890,1892,3,158,79,0,1891,1890,1,0,0,0,1891,1892,1,0,0,0,1892,1893,
  	1,0,0,0,1893,1899,3,128,64,0,1894,1895,5,85,0,0,1895,1896,3,184,92,0,
  	1896,1897,3,128,64,0,1897,1899,1,0,0,0,1898,1883,1,0,0,0,1898,1894,1,
  	0,0,0,1899,183,1,0,0,0,1900,1901,7,1,0,0,1901,185,1,0,0,0,1902,1904,3,
  	694,347,0,1903,1902,1,0,0,0,1904,1907,1,0,0,0,1905,1903,1,0,0,0,1905,
  	1906,1,0,0,0,1906,1908,1,0,0,0,1907,1905,1,0,0,0,1908,1910,5,138,0,0,
  	1909,1911,5,150,0,0,1910,1909,1,0,0,0,1910,1911,1,0,0,0,1911,1913,1,0,
  	0,0,1912,1914,3,158,79,0,1913,1912,1,0,0,0,1913,1914,1,0,0,0,1914,1915,
  	1,0,0,0,1915,1916,3,188,94,0,1916,1917,5,147,0,0,1917,1984,1,0,0,0,1918,
  	1920,3,694,347,0,1919,1918,1,0,0,0,1920,1923,1,0,0,0,1921,1919,1,0,0,
  	0,1921,1922,1,0,0,0,1922,1924,1,0,0,0,1923,1921,1,0,0,0,1924,1925,5,88,
  	0,0,1925,1926,3,188,94,0,1926,1927,5,147,0,0,1927,1984,1,0,0,0,1928,1930,
  	3,694,347,0,1929,1928,1,0,0,0,1930,1933,1,0,0,0,1931,1929,1,0,0,0,1931,
  	1932,1,0,0,0,1932,1934,1,0,0,0,1933,1931,1,0,0,0,1934,1935,5,164,0,0,
  	1935,1936,3,188,94,0,1936,1937,5,147,0,0,1937,1984,1,0,0,0,1938,1940,
  	3,694,347,0,1939,1938,1,0,0,0,1940,1943,1,0,0,0,1941,1939,1,0,0,0,1941,
  	1942,1,0,0,0,1942,1944,1,0,0,0,1943,1941,1,0,0,0,1944,1945,5,136,0,0,
  	1945,1946,3,190,95,0,1946,1947,5,147,0,0,1947,1984,1,0,0,0,1948,1950,
  	3,694,347,0,1949,1948,1,0,0,0,1950,1953,1,0,0,0,1951,1949,1,0,0,0,1951,
  	1952,1,0,0,0,1952,1954,1,0,0,0,1953,1951,1,0,0,0,1954,1955,5,137,0,0,
  	1955,1956,3,190,95,0,1956,1957,5,147,0,0,1957,1984,1,0,0,0,1958,1960,
  	3,694,347,0,1959,1958,1,0,0,0,1960,1963,1,0,0,0,1961,1959,1,0,0,0,1961,
  	1962,1,0,0,0,1962,1964,1,0,0,0,1963,1961,1,0,0,0,1964,1984,3,78,39,0,
  	1965,1967,3,694,347,0,1966,1965,1,0,0,0,1967,1970,1,0,0,0,1968,1966,1,
  	0,0,0,1968,1969,1,0,0,0,1969,1971,1,0,0,0,1970,1968,1,0,0,0,1971,1972,
  	3,64,32,0,1972,1973,5,147,0,0,1973,1984,1,0,0,0,1974,1976,3,694,347,0,
  	1975,1974,1,0,0,0,1976,1979,1,0,0,0,1977,1975,1,0,0,0,1977,1978,1,0,0,
  	0,1978,1980,1,0,0,0,1979,1977,1,0,0,0,1980,1981,3,66,33,0,1981,1982,5,
  	147,0,0,1982,1984,1,0,0,0,1983,1905,1,0,0,0,1983,1921,1,0,0,0,1983,1931,
  	1,0,0,0,1983,1941,1,0,0,0,1983,1951,1,0,0,0,1983,1961,1,0,0,0,1983,1968,
  	1,0,0,0,1983,1977,1,0,0,0,1984,187,1,0,0,0,1985,1990,3,192,96,0,1986,
  	1987,5,24,0,0,1987,1989,3,192,96,0,1988,1986,1,0,0,0,1989,1992,1,0,0,
  	0,1990,1988,1,0,0,0,1990,1991,1,0,0,0,1991,189,1,0,0,0,1992,1990,1,0,
  	0,0,1993,1998,3,194,97,0,1994,1995,5,24,0,0,1995,1997,3,194,97,0,1996,
  	1994,1,0,0,0,1997,2000,1,0,0,0,1998,1996,1,0,0,0,1998,1999,1,0,0,0,1999,
  	191,1,0,0,0,2000,1998,1,0,0,0,2001,2005,3,762,381,0,2002,2004,3,156,78,
  	0,2003,2002,1,0,0,0,2004,2007,1,0,0,0,2005,2003,1,0,0,0,2005,2006,1,0,
  	0,0,2006,193,1,0,0,0,2007,2005,1,0,0,0,2008,2012,3,742,371,0,2009,2011,
  	3,156,78,0,2010,2009,1,0,0,0,2011,2014,1,0,0,0,2012,2010,1,0,0,0,2012,
  	2013,1,0,0,0,2013,195,1,0,0,0,2014,2012,1,0,0,0,2015,2017,3,232,116,0,
  	2016,2018,3,108,54,0,2017,2016,1,0,0,0,2017,2018,1,0,0,0,2018,2019,1,
  	0,0,0,2019,2024,3,198,99,0,2020,2021,5,24,0,0,2021,2023,3,198,99,0,2022,
  	2020,1,0,0,0,2023,2026,1,0,0,0,2024,2022,1,0,0,0,2024,2025,1,0,0,0,2025,
  	2027,1,0,0,0,2026,2024,1,0,0,0,2027,2028,5,147,0,0,2028,2148,1,0,0,0,
  	2029,2031,3,234,117,0,2030,2032,3,100,50,0,2031,2030,1,0,0,0,2031,2032,
  	1,0,0,0,2032,2034,1,0,0,0,2033,2035,3,108,54,0,2034,2033,1,0,0,0,2034,
  	2035,1,0,0,0,2035,2036,1,0,0,0,2036,2041,3,200,100,0,2037,2038,5,24,0,
  	0,2038,2040,3,200,100,0,2039,2037,1,0,0,0,2040,2043,1,0,0,0,2041,2039,
  	1,0,0,0,2041,2042,1,0,0,0,2042,2044,1,0,0,0,2043,2041,1,0,0,0,2044,2045,
  	5,147,0,0,2045,2148,1,0,0,0,2046,2048,3,236,118,0,2047,2049,3,108,54,
  	0,2048,2047,1,0,0,0,2048,2049,1,0,0,0,2049,2050,1,0,0,0,2050,2055,3,202,
  	101,0,2051,2052,5,24,0,0,2052,2054,3,202,101,0,2053,2051,1,0,0,0,2054,
  	2057,1,0,0,0,2055,2053,1,0,0,0,2055,2056,1,0,0,0,2056,2058,1,0,0,0,2057,
  	2055,1,0,0,0,2058,2059,5,147,0,0,2059,2148,1,0,0,0,2060,2062,3,238,119,
  	0,2061,2063,3,100,50,0,2062,2061,1,0,0,0,2062,2063,1,0,0,0,2063,2065,
  	1,0,0,0,2064,2066,3,110,55,0,2065,2064,1,0,0,0,2065,2066,1,0,0,0,2066,
  	2067,1,0,0,0,2067,2072,3,204,102,0,2068,2069,5,24,0,0,2069,2071,3,204,
  	102,0,2070,2068,1,0,0,0,2071,2074,1,0,0,0,2072,2070,1,0,0,0,2072,2073,
  	1,0,0,0,2073,2075,1,0,0,0,2074,2072,1,0,0,0,2075,2076,5,147,0,0,2076,
  	2148,1,0,0,0,2077,2079,3,240,120,0,2078,2080,3,100,50,0,2079,2078,1,0,
  	0,0,2079,2080,1,0,0,0,2080,2082,1,0,0,0,2081,2083,3,110,55,0,2082,2081,
  	1,0,0,0,2082,2083,1,0,0,0,2083,2084,1,0,0,0,2084,2089,3,206,103,0,2085,
  	2086,5,24,0,0,2086,2088,3,206,103,0,2087,2085,1,0,0,0,2088,2091,1,0,0,
  	0,2089,2087,1,0,0,0,2089,2090,1,0,0,0,2090,2092,1,0,0,0,2091,2089,1,0,
  	0,0,2092,2093,5,147,0,0,2093,2148,1,0,0,0,2094,2096,3,242,121,0,2095,
  	2097,3,110,55,0,2096,2095,1,0,0,0,2096,2097,1,0,0,0,2097,2098,1,0,0,0,
  	2098,2103,3,210,105,0,2099,2100,5,24,0,0,2100,2102,3,210,105,0,2101,2099,
  	1,0,0,0,2102,2105,1,0,0,0,2103,2101,1,0,0,0,2103,2104,1,0,0,0,2104,2106,
  	1,0,0,0,2105,2103,1,0,0,0,2106,2107,5,147,0,0,2107,2148,1,0,0,0,2108,
  	2109,3,244,122,0,2109,2114,3,208,104,0,2110,2111,5,24,0,0,2111,2113,3,
  	208,104,0,2112,2110,1,0,0,0,2113,2116,1,0,0,0,2114,2112,1,0,0,0,2114,
  	2115,1,0,0,0,2115,2117,1,0,0,0,2116,2114,1,0,0,0,2117,2118,5,147,0,0,
  	2118,2148,1,0,0,0,2119,2121,5,126,0,0,2120,2122,3,216,108,0,2121,2120,
  	1,0,0,0,2121,2122,1,0,0,0,2122,2123,1,0,0,0,2123,2128,3,212,106,0,2124,
  	2125,5,24,0,0,2125,2127,3,212,106,0,2126,2124,1,0,0,0,2127,2130,1,0,0,
  	0,2128,2126,1,0,0,0,2128,2129,1,0,0,0,2129,2131,1,0,0,0,2130,2128,1,0,
  	0,0,2131,2132,5,147,0,0,2132,2148,1,0,0,0,2133,2135,5,128,0,0,2134,2136,
  	3,218,109,0,2135,2134,1,0,0,0,2135,2136,1,0,0,0,2136,2137,1,0,0,0,2137,
  	2142,3,212,106,0,2138,2139,5,24,0,0,2139,2141,3,212,106,0,2140,2138,1,
  	0,0,0,2141,2144,1,0,0,0,2142,2140,1,0,0,0,2142,2143,1,0,0,0,2143,2145,
  	1,0,0,0,2144,2142,1,0,0,0,2145,2146,5,147,0,0,2146,2148,1,0,0,0,2147,
  	2015,1,0,0,0,2147,2029,1,0,0,0,2147,2046,1,0,0,0,2147,2060,1,0,0,0,2147,
  	2077,1,0,0,0,2147,2094,1,0,0,0,2147,2108,1,0,0,0,2147,2119,1,0,0,0,2147,
  	2133,1,0,0,0,2148,197,1,0,0,0,2149,2151,3,214,107,0,2150,2149,1,0,0,0,
  	2150,2151,1,0,0,0,2151,2152,1,0,0,0,2152,2153,5,96,0,0,2153,2154,3,228,
  	114,0,2154,2155,5,24,0,0,2155,2156,3,224,112,0,2156,2157,5,24,0,0,2157,
  	2158,3,226,113,0,2158,2159,5,24,0,0,2159,2160,3,230,115,0,2160,2161,5,
  	142,0,0,2161,199,1,0,0,0,2162,2164,3,214,107,0,2163,2162,1,0,0,0,2163,
  	2164,1,0,0,0,2164,2165,1,0,0,0,2165,2166,5,96,0,0,2166,2167,3,228,114,
  	0,2167,2168,5,24,0,0,2168,2169,3,224,112,0,2169,2170,5,24,0,0,2170,2171,
  	3,220,110,0,2171,2172,5,142,0,0,2172,201,1,0,0,0,2173,2175,3,214,107,
  	0,2174,2173,1,0,0,0,2174,2175,1,0,0,0,2175,2176,1,0,0,0,2176,2177,5,96,
  	0,0,2177,2178,3,228,114,0,2178,2179,5,24,0,0,2179,2180,3,224,112,0,2180,
  	2181,5,24,0,0,2181,2182,3,220,110,0,2182,2183,5,142,0,0,2183,203,1,0,
  	0,0,2184,2186,3,214,107,0,2185,2184,1,0,0,0,2185,2186,1,0,0,0,2186,2187,
  	1,0,0,0,2187,2188,5,96,0,0,2188,2189,3,228,114,0,2189,2190,5,24,0,0,2190,
  	2195,3,224,112,0,2191,2192,5,24,0,0,2192,2194,3,224,112,0,2193,2191,1,
  	0,0,0,2194,2197,1,0,0,0,2195,2193,1,0,0,0,2195,2196,1,0,0,0,2196,2198,
  	1,0,0,0,2197,2195,1,0,0,0,2198,2199,5,142,0,0,2199,205,1,0,0,0,2200,2202,
  	3,214,107,0,2201,2200,1,0,0,0,2201,2202,1,0,0,0,2202,2203,1,0,0,0,2203,
  	2204,5,96,0,0,2204,2209,3,228,114,0,2205,2206,5,24,0,0,2206,2208,3,228,
  	114,0,2207,2205,1,0,0,0,2208,2211,1,0,0,0,2209,2207,1,0,0,0,2209,2210,
  	1,0,0,0,2210,2212,1,0,0,0,2211,2209,1,0,0,0,2212,2213,5,24,0,0,2213,2214,
  	3,224,112,0,2214,2215,5,142,0,0,2215,207,1,0,0,0,2216,2218,3,214,107,
  	0,2217,2216,1,0,0,0,2217,2218,1,0,0,0,2218,2219,1,0,0,0,2219,2220,5,96,
  	0,0,2220,2221,3,222,111,0,2221,2222,5,24,0,0,2222,2223,3,222,111,0,2223,
  	2224,5,142,0,0,2224,209,1,0,0,0,2225,2227,3,214,107,0,2226,2225,1,0,0,
  	0,2226,2227,1,0,0,0,2227,2228,1,0,0,0,2228,2229,5,96,0,0,2229,2230,3,
  	222,111,0,2230,2231,5,24,0,0,2231,2232,3,222,111,0,2232,2233,5,24,0,0,
  	2233,2234,3,220,110,0,2234,2235,5,142,0,0,2235,211,1,0,0,0,2236,2238,
  	3,214,107,0,2237,2236,1,0,0,0,2237,2238,1,0,0,0,2238,2239,1,0,0,0,2239,
  	2240,5,96,0,0,2240,2241,3,228,114,0,2241,2242,5,142,0,0,2242,213,1,0,
  	0,0,2243,2245,3,712,356,0,2244,2246,3,158,79,0,2245,2244,1,0,0,0,2245,
  	2246,1,0,0,0,2246,215,1,0,0,0,2247,2248,5,96,0,0,2248,2249,3,102,51,0,
  	2249,2250,5,24,0,0,2250,2251,3,104,52,0,2251,2252,5,142,0,0,2252,2264,
  	1,0,0,0,2253,2254,5,96,0,0,2254,2255,3,104,52,0,2255,2256,5,24,0,0,2256,
  	2257,3,102,51,0,2257,2258,5,142,0,0,2258,2264,1,0,0,0,2259,2260,5,96,
  	0,0,2260,2261,3,102,51,0,2261,2262,5,142,0,0,2262,2264,1,0,0,0,2263,2247,
  	1,0,0,0,2263,2253,1,0,0,0,2263,2259,1,0,0,0,2264,217,1,0,0,0,2265,2266,
  	5,96,0,0,2266,2267,3,102,51,0,2267,2268,5,24,0,0,2268,2269,3,104,52,0,
  	2269,2270,5,142,0,0,2270,2282,1,0,0,0,2271,2272,5,96,0,0,2272,2273,3,
  	104,52,0,2273,2274,5,24,0,0,2274,2275,3,102,51,0,2275,2276,5,142,0,0,
  	2276,2282,1,0,0,0,2277,2278,5,96,0,0,2278,2279,3,104,52,0,2279,2280,5,
  	142,0,0,2280,2282,1,0,0,0,2281,2265,1,0,0,0,2281,2271,1,0,0,0,2281,2277,
  	1,0,0,0,2282,219,1,0,0,0,2283,2284,3,618,309,0,2284,221,1,0,0,0,2285,
  	2286,3,644,322,0,2286,223,1,0,0,0,2287,2288,3,618,309,0,2288,225,1,0,
  	0,0,2289,2290,3,618,309,0,2290,227,1,0,0,0,2291,2292,3,644,322,0,2292,
  	229,1,0,0,0,2293,2294,3,618,309,0,2294,231,1,0,0,0,2295,2296,7,7,0,0,
  	2296,233,1,0,0,0,2297,2298,7,8,0,0,2298,235,1,0,0,0,2299,2300,7,9,0,0,
  	2300,237,1,0,0,0,2301,2302,7,10,0,0,2302,239,1,0,0,0,2303,2304,7,11,0,
  	0,2304,241,1,0,0,0,2305,2306,7,12,0,0,2306,243,1,0,0,0,2307,2308,7,13,
  	0,0,2308,245,1,0,0,0,2309,2311,3,730,365,0,2310,2312,3,248,124,0,2311,
  	2310,1,0,0,0,2311,2312,1,0,0,0,2312,2313,1,0,0,0,2313,2318,3,256,128,
  	0,2314,2315,5,24,0,0,2315,2317,3,256,128,0,2316,2314,1,0,0,0,2317,2320,
  	1,0,0,0,2318,2316,1,0,0,0,2318,2319,1,0,0,0,2319,2321,1,0,0,0,2320,2318,
  	1,0,0,0,2321,2322,5,147,0,0,2322,247,1,0,0,0,2323,2324,5,78,0,0,2324,
  	2325,5,96,0,0,2325,2326,3,250,125,0,2326,2327,5,142,0,0,2327,249,1,0,
  	0,0,2328,2333,3,252,126,0,2329,2330,5,24,0,0,2330,2332,3,252,126,0,2331,
  	2329,1,0,0,0,2332,2335,1,0,0,0,2333,2331,1,0,0,0,2333,2334,1,0,0,0,2334,
  	2345,1,0,0,0,2335,2333,1,0,0,0,2336,2341,3,254,127,0,2337,2338,5,24,0,
  	0,2338,2340,3,254,127,0,2339,2337,1,0,0,0,2340,2343,1,0,0,0,2341,2339,
  	1,0,0,0,2341,2342,1,0,0,0,2342,2345,1,0,0,0,2343,2341,1,0,0,0,2344,2328,
  	1,0,0,0,2344,2336,1,0,0,0,2345,251,1,0,0,0,2346,2347,3,618,309,0,2347,
  	253,1,0,0,0,2348,2349,5,45,0,0,2349,2350,3,738,369,0,2350,2352,5,96,0,
  	0,2351,2353,3,622,311,0,2352,2351,1,0,0,0,2352,2353,1,0,0,0,2353,2354,
  	1,0,0,0,2354,2355,5,142,0,0,2355,255,1,0,0,0,2356,2357,3,258,129,0,2357,
  	2358,5,96,0,0,2358,2359,3,260,130,0,2359,2360,5,142,0,0,2360,257,1,0,
  	0,0,2361,2363,3,732,366,0,2362,2364,3,158,79,0,2363,2362,1,0,0,0,2363,
  	2364,1,0,0,0,2364,259,1,0,0,0,2365,2370,3,262,131,0,2366,2367,5,24,0,
  	0,2367,2369,3,262,131,0,2368,2366,1,0,0,0,2369,2372,1,0,0,0,2370,2368,
  	1,0,0,0,2370,2371,1,0,0,0,2371,2382,1,0,0,0,2372,2370,1,0,0,0,2373,2378,
  	3,264,132,0,2374,2375,5,24,0,0,2375,2377,3,264,132,0,2376,2374,1,0,0,
  	0,2377,2380,1,0,0,0,2378,2376,1,0,0,0,2378,2379,1,0,0,0,2379,2382,1,0,
  	0,0,2380,2378,1,0,0,0,2381,2365,1,0,0,0,2381,2373,1,0,0,0,2382,261,1,
  	0,0,0,2383,2385,3,694,347,0,2384,2383,1,0,0,0,2385,2388,1,0,0,0,2386,
  	2384,1,0,0,0,2386,2387,1,0,0,0,2387,2390,1,0,0,0,2388,2386,1,0,0,0,2389,
  	2391,3,618,309,0,2390,2389,1,0,0,0,2390,2391,1,0,0,0,2391,263,1,0,0,0,
  	2392,2394,3,694,347,0,2393,2392,1,0,0,0,2394,2397,1,0,0,0,2395,2393,1,
  	0,0,0,2395,2396,1,0,0,0,2396,2398,1,0,0,0,2397,2395,1,0,0,0,2398,2399,
  	5,45,0,0,2399,2400,3,740,370,0,2400,2402,5,96,0,0,2401,2403,3,618,309,
  	0,2402,2401,1,0,0,0,2402,2403,1,0,0,0,2403,2404,1,0,0,0,2404,2405,5,142,
  	0,0,2405,265,1,0,0,0,2406,2410,5,72,0,0,2407,2409,3,38,19,0,2408,2407,
  	1,0,0,0,2409,2412,1,0,0,0,2410,2408,1,0,0,0,2410,2411,1,0,0,0,2411,2413,
  	1,0,0,0,2412,2410,1,0,0,0,2413,2414,5,55,0,0,2414,267,1,0,0,0,2415,2416,
  	5,73,0,0,2416,2417,3,270,135,0,2417,2418,5,147,0,0,2418,269,1,0,0,0,2419,
  	2424,3,716,358,0,2420,2421,5,24,0,0,2421,2423,3,716,358,0,2422,2420,1,
  	0,0,0,2423,2426,1,0,0,0,2424,2422,1,0,0,0,2424,2425,1,0,0,0,2425,271,
  	1,0,0,0,2426,2424,1,0,0,0,2427,2428,5,66,0,0,2428,2429,5,96,0,0,2429,
  	2430,3,274,137,0,2430,2431,5,147,0,0,2431,2432,3,276,138,0,2432,2433,
  	5,147,0,0,2433,2434,3,278,139,0,2434,2435,5,142,0,0,2435,2436,3,288,144,
  	0,2436,273,1,0,0,0,2437,2438,3,716,358,0,2438,2439,5,61,0,0,2439,2440,
  	3,610,305,0,2440,275,1,0,0,0,2441,2442,3,610,305,0,2442,277,1,0,0,0,2443,
  	2444,3,716,358,0,2444,2445,5,61,0,0,2445,2446,3,276,138,0,2446,279,1,
  	0,0,0,2447,2450,3,282,141,0,2448,2450,3,284,142,0,2449,2447,1,0,0,0,2449,
  	2448,1,0,0,0,2450,281,1,0,0,0,2451,2452,5,81,0,0,2452,2453,5,96,0,0,2453,
  	2454,3,610,305,0,2454,2455,5,142,0,0,2455,2458,3,292,146,0,2456,2457,
  	5,47,0,0,2457,2459,3,292,146,0,2458,2456,1,0,0,0,2458,2459,1,0,0,0,2459,
  	283,1,0,0,0,2460,2461,5,17,0,0,2461,2462,5,96,0,0,2462,2463,3,610,305,
  	0,2463,2465,5,142,0,0,2464,2466,3,286,143,0,2465,2464,1,0,0,0,2466,2467,
  	1,0,0,0,2467,2465,1,0,0,0,2467,2468,1,0,0,0,2468,2469,1,0,0,0,2469,2470,
  	5,52,0,0,2470,285,1,0,0,0,2471,2476,3,610,305,0,2472,2473,5,24,0,0,2473,
  	2475,3,610,305,0,2474,2472,1,0,0,0,2475,2478,1,0,0,0,2476,2474,1,0,0,
  	0,2476,2477,1,0,0,0,2477,2479,1,0,0,0,2478,2476,1,0,0,0,2479,2480,5,22,
  	0,0,2480,2481,3,292,146,0,2481,2488,1,0,0,0,2482,2484,5,27,0,0,2483,2485,
  	5,22,0,0,2484,2483,1,0,0,0,2484,2485,1,0,0,0,2485,2486,1,0,0,0,2486,2488,
  	3,292,146,0,2487,2471,1,0,0,0,2487,2482,1,0,0,0,2488,287,1,0,0,0,2489,
  	2502,3,38,19,0,2490,2492,5,12,0,0,2491,2493,3,290,145,0,2492,2491,1,0,
  	0,0,2492,2493,1,0,0,0,2493,2497,1,0,0,0,2494,2496,3,38,19,0,2495,2494,
  	1,0,0,0,2496,2499,1,0,0,0,2497,2495,1,0,0,0,2497,2498,1,0,0,0,2498,2500,
  	1,0,0,0,2499,2497,1,0,0,0,2500,2502,5,51,0,0,2501,2489,1,0,0,0,2501,2490,
  	1,0,0,0,2502,289,1,0,0,0,2503,2504,5,22,0,0,2504,2505,3,714,357,0,2505,
  	291,1,0,0,0,2506,2509,3,288,144,0,2507,2509,5,147,0,0,2508,2506,1,0,0,
  	0,2508,2507,1,0,0,0,2509,293,1,0,0,0,2510,2512,3,694,347,0,2511,2510,
  	1,0,0,0,2512,2515,1,0,0,0,2513,2511,1,0,0,0,2513,2514,1,0,0,0,2514,2516,
  	1,0,0,0,2515,2513,1,0,0,0,2516,2517,5,125,0,0,2517,2518,3,758,379,0,2518,
  	2519,5,96,0,0,2519,2520,3,296,148,0,2520,2521,5,142,0,0,2521,2523,5,147,
  	0,0,2522,2524,3,300,150,0,2523,2522,1,0,0,0,2524,2525,1,0,0,0,2525,2523,
  	1,0,0,0,2525,2526,1,0,0,0,2526,2527,1,0,0,0,2527,2528,3,308,154,0,2528,
  	2529,5,57,0,0,2529,2546,1,0,0,0,2530,2532,3,694,347,0,2531,2530,1,0,0,
  	0,2532,2535,1,0,0,0,2533,2531,1,0,0,0,2533,2534,1,0,0,0,2534,2536,1,0,
  	0,0,2535,2533,1,0,0,0,2536,2537,5,125,0,0,2537,2538,3,758,379,0,2538,
  	2539,5,96,0,0,2539,2540,3,298,149,0,2540,2541,5,142,0,0,2541,2542,5,147,
  	0,0,2542,2543,3,308,154,0,2543,2544,5,57,0,0,2544,2546,1,0,0,0,2545,2513,
  	1,0,0,0,2545,2533,1,0,0,0,2546,295,1,0,0,0,2547,2548,3,736,368,0,2548,
  	2549,5,24,0,0,2549,2554,3,724,362,0,2550,2551,5,24,0,0,2551,2553,3,724,
  	362,0,2552,2550,1,0,0,0,2553,2556,1,0,0,0,2554,2552,1,0,0,0,2554,2555,
  	1,0,0,0,2555,297,1,0,0,0,2556,2554,1,0,0,0,2557,2558,3,302,151,0,2558,
  	2559,5,24,0,0,2559,2564,3,304,152,0,2560,2561,5,24,0,0,2561,2563,3,304,
  	152,0,2562,2560,1,0,0,0,2563,2566,1,0,0,0,2564,2562,1,0,0,0,2564,2565,
  	1,0,0,0,2565,299,1,0,0,0,2566,2564,1,0,0,0,2567,2568,3,302,151,0,2568,
  	2569,5,147,0,0,2569,2577,1,0,0,0,2570,2571,3,304,152,0,2571,2572,5,147,
  	0,0,2572,2577,1,0,0,0,2573,2574,3,306,153,0,2574,2575,5,147,0,0,2575,
  	2577,1,0,0,0,2576,2567,1,0,0,0,2576,2570,1,0,0,0,2576,2573,1,0,0,0,2577,
  	301,1,0,0,0,2578,2580,3,694,347,0,2579,2578,1,0,0,0,2580,2583,1,0,0,0,
  	2581,2579,1,0,0,0,2581,2582,1,0,0,0,2582,2584,1,0,0,0,2583,2581,1,0,0,
  	0,2584,2585,5,118,0,0,2585,2600,3,740,370,0,2586,2588,3,694,347,0,2587,
  	2586,1,0,0,0,2588,2591,1,0,0,0,2589,2587,1,0,0,0,2589,2590,1,0,0,0,2590,
  	2592,1,0,0,0,2591,2589,1,0,0,0,2592,2593,5,118,0,0,2593,2594,5,138,0,
  	0,2594,2597,3,740,370,0,2595,2596,5,61,0,0,2596,2598,3,610,305,0,2597,
  	2595,1,0,0,0,2597,2598,1,0,0,0,2598,2600,1,0,0,0,2599,2581,1,0,0,0,2599,
  	2589,1,0,0,0,2600,303,1,0,0,0,2601,2603,3,694,347,0,2602,2601,1,0,0,0,
  	2603,2606,1,0,0,0,2604,2602,1,0,0,0,2604,2605,1,0,0,0,2605,2607,1,0,0,
  	0,2606,2604,1,0,0,0,2607,2608,5,86,0,0,2608,2609,3,128,64,0,2609,305,
  	1,0,0,0,2610,2612,3,694,347,0,2611,2610,1,0,0,0,2612,2615,1,0,0,0,2613,
  	2611,1,0,0,0,2613,2614,1,0,0,0,2614,2616,1,0,0,0,2615,2613,1,0,0,0,2616,
  	2617,5,138,0,0,2617,2618,3,762,381,0,2618,307,1,0,0,0,2619,2622,3,310,
  	155,0,2620,2622,3,314,157,0,2621,2619,1,0,0,0,2621,2620,1,0,0,0,2622,
  	309,1,0,0,0,2623,2625,5,159,0,0,2624,2626,3,312,156,0,2625,2624,1,0,0,
  	0,2626,2627,1,0,0,0,2627,2625,1,0,0,0,2627,2628,1,0,0,0,2628,2629,1,0,
  	0,0,2629,2630,5,59,0,0,2630,311,1,0,0,0,2631,2632,3,324,162,0,2632,2633,
  	5,22,0,0,2633,2634,3,334,167,0,2634,2635,5,147,0,0,2635,313,1,0,0,0,2636,
  	2638,3,316,158,0,2637,2636,1,0,0,0,2637,2638,1,0,0,0,2638,2639,1,0,0,
  	0,2639,2641,5,159,0,0,2640,2642,3,320,160,0,2641,2640,1,0,0,0,2642,2643,
  	1,0,0,0,2643,2641,1,0,0,0,2643,2644,1,0,0,0,2644,2645,1,0,0,0,2645,2646,
  	5,59,0,0,2646,315,1,0,0,0,2647,2648,5,84,0,0,2648,2649,3,736,368,0,2649,
  	2650,5,61,0,0,2650,2651,3,318,159,0,2651,2652,5,147,0,0,2652,317,1,0,
  	0,0,2653,2656,3,662,331,0,2654,2656,3,674,337,0,2655,2653,1,0,0,0,2655,
  	2654,1,0,0,0,2656,319,1,0,0,0,2657,2658,3,322,161,0,2658,2659,5,22,0,
  	0,2659,2660,3,330,165,0,2660,2661,5,22,0,0,2661,2662,3,332,166,0,2662,
  	2663,5,147,0,0,2663,321,1,0,0,0,2664,2667,3,324,162,0,2665,2667,3,326,
  	163,0,2666,2664,1,0,0,0,2666,2665,1,0,0,0,2667,323,1,0,0,0,2668,2670,
  	3,336,168,0,2669,2668,1,0,0,0,2670,2671,1,0,0,0,2671,2669,1,0,0,0,2671,
  	2672,1,0,0,0,2672,325,1,0,0,0,2673,2675,3,336,168,0,2674,2673,1,0,0,0,
  	2675,2678,1,0,0,0,2676,2674,1,0,0,0,2676,2677,1,0,0,0,2677,2679,1,0,0,
  	0,2678,2676,1,0,0,0,2679,2683,3,328,164,0,2680,2682,3,336,168,0,2681,
  	2680,1,0,0,0,2682,2685,1,0,0,0,2683,2681,1,0,0,0,2683,2684,1,0,0,0,2684,
  	327,1,0,0,0,2685,2683,1,0,0,0,2686,2687,5,96,0,0,2687,2688,3,336,168,
  	0,2688,2689,3,336,168,0,2689,2690,5,142,0,0,2690,2693,1,0,0,0,2691,2693,
  	3,338,169,0,2692,2686,1,0,0,0,2692,2691,1,0,0,0,2693,329,1,0,0,0,2694,
  	2695,3,336,168,0,2695,331,1,0,0,0,2696,2699,3,334,167,0,2697,2699,5,103,
  	0,0,2698,2696,1,0,0,0,2698,2697,1,0,0,0,2699,333,1,0,0,0,2700,2701,5,
  	210,0,0,2701,335,1,0,0,0,2702,2703,7,14,0,0,2703,337,1,0,0,0,2704,2705,
  	5,208,0,0,2705,339,1,0,0,0,2706,2708,3,758,379,0,2707,2709,3,100,50,0,
  	2708,2707,1,0,0,0,2708,2709,1,0,0,0,2709,2711,1,0,0,0,2710,2712,3,110,
  	55,0,2711,2710,1,0,0,0,2711,2712,1,0,0,0,2712,2713,1,0,0,0,2713,2718,
  	3,342,171,0,2714,2715,5,24,0,0,2715,2717,3,342,171,0,2716,2714,1,0,0,
  	0,2717,2720,1,0,0,0,2718,2716,1,0,0,0,2718,2719,1,0,0,0,2719,2721,1,0,
  	0,0,2720,2718,1,0,0,0,2721,2722,5,147,0,0,2722,341,1,0,0,0,2723,2725,
  	3,344,172,0,2724,2723,1,0,0,0,2724,2725,1,0,0,0,2725,2726,1,0,0,0,2726,
  	2727,5,96,0,0,2727,2728,3,228,114,0,2728,2729,5,24,0,0,2729,2734,3,224,
  	112,0,2730,2731,5,24,0,0,2731,2733,3,224,112,0,2732,2730,1,0,0,0,2733,
  	2736,1,0,0,0,2734,2732,1,0,0,0,2734,2735,1,0,0,0,2735,2737,1,0,0,0,2736,
  	2734,1,0,0,0,2737,2738,5,142,0,0,2738,343,1,0,0,0,2739,2741,3,760,380,
  	0,2740,2742,3,158,79,0,2741,2740,1,0,0,0,2741,2742,1,0,0,0,2742,345,1,
  	0,0,0,2743,2745,5,9,0,0,2744,2746,3,100,50,0,2745,2744,1,0,0,0,2745,2746,
  	1,0,0,0,2746,2748,1,0,0,0,2747,2749,3,108,54,0,2748,2747,1,0,0,0,2748,
  	2749,1,0,0,0,2749,2750,1,0,0,0,2750,2751,3,348,174,0,2751,2752,5,147,
  	0,0,2752,347,1,0,0,0,2753,2758,3,350,175,0,2754,2755,5,24,0,0,2755,2757,
  	3,350,175,0,2756,2754,1,0,0,0,2757,2760,1,0,0,0,2758,2756,1,0,0,0,2758,
  	2759,1,0,0,0,2759,349,1,0,0,0,2760,2758,1,0,0,0,2761,2762,3,644,322,0,
  	2762,2763,5,61,0,0,2763,2764,3,618,309,0,2764,351,1,0,0,0,2765,2766,5,
  	84,0,0,2766,2767,3,370,185,0,2767,353,1,0,0,0,2768,2769,5,1,0,0,2769,
  	2770,3,370,185,0,2770,355,1,0,0,0,2771,2772,3,650,325,0,2772,2774,5,61,
  	0,0,2773,2775,3,378,189,0,2774,2773,1,0,0,0,2774,2775,1,0,0,0,2775,2776,
  	1,0,0,0,2776,2777,3,618,309,0,2777,357,1,0,0,0,2778,2779,3,650,325,0,
  	2779,2781,5,98,0,0,2780,2782,3,378,189,0,2781,2780,1,0,0,0,2781,2782,
  	1,0,0,0,2782,2783,1,0,0,0,2783,2784,3,618,309,0,2784,359,1,0,0,0,2785,
  	2786,5,9,0,0,2786,2794,3,362,181,0,2787,2788,5,26,0,0,2788,2794,3,650,
  	325,0,2789,2790,5,67,0,0,2790,2794,3,362,181,0,2791,2792,5,139,0,0,2792,
  	2794,3,650,325,0,2793,2785,1,0,0,0,2793,2787,1,0,0,0,2793,2789,1,0,0,
  	0,2793,2791,1,0,0,0,2794,361,1,0,0,0,2795,2796,3,650,325,0,2796,2797,
  	5,61,0,0,2797,2798,3,618,309,0,2798,363,1,0,0,0,2799,2807,5,69,0,0,2800,
  	2804,3,366,183,0,2801,2803,3,186,93,0,2802,2801,1,0,0,0,2803,2806,1,0,
  	0,0,2804,2802,1,0,0,0,2804,2805,1,0,0,0,2805,2808,1,0,0,0,2806,2804,1,
  	0,0,0,2807,2800,1,0,0,0,2807,2808,1,0,0,0,2808,2812,1,0,0,0,2809,2811,
  	3,370,185,0,2810,2809,1,0,0,0,2811,2814,1,0,0,0,2812,2810,1,0,0,0,2812,
  	2813,1,0,0,0,2813,2815,1,0,0,0,2814,2812,1,0,0,0,2815,2816,5,89,0,0,2816,
  	365,1,0,0,0,2817,2818,5,22,0,0,2818,2819,3,700,350,0,2819,367,1,0,0,0,
  	2820,2828,5,12,0,0,2821,2825,3,366,183,0,2822,2824,3,186,93,0,2823,2822,
  	1,0,0,0,2824,2827,1,0,0,0,2825,2823,1,0,0,0,2825,2826,1,0,0,0,2826,2829,
  	1,0,0,0,2827,2825,1,0,0,0,2828,2821,1,0,0,0,2828,2829,1,0,0,0,2829,2833,
  	1,0,0,0,2830,2832,3,370,185,0,2831,2830,1,0,0,0,2832,2835,1,0,0,0,2833,
  	2831,1,0,0,0,2833,2834,1,0,0,0,2834,2836,1,0,0,0,2835,2833,1,0,0,0,2836,
  	2837,5,51,0,0,2837,369,1,0,0,0,2838,2840,3,694,347,0,2839,2838,1,0,0,
  	0,2840,2843,1,0,0,0,2841,2839,1,0,0,0,2841,2842,1,0,0,0,2842,2844,1,0,
  	0,0,2843,2841,1,0,0,0,2844,2845,3,356,178,0,2845,2846,5,147,0,0,2846,
  	2943,1,0,0,0,2847,2849,3,694,347,0,2848,2847,1,0,0,0,2849,2852,1,0,0,
  	0,2850,2848,1,0,0,0,2850,2851,1,0,0,0,2851,2853,1,0,0,0,2852,2850,1,0,
  	0,0,2853,2943,3,396,198,0,2854,2856,3,694,347,0,2855,2854,1,0,0,0,2856,
  	2859,1,0,0,0,2857,2855,1,0,0,0,2857,2858,1,0,0,0,2858,2860,1,0,0,0,2859,
  	2857,1,0,0,0,2860,2943,3,394,197,0,2861,2863,3,694,347,0,2862,2861,1,
  	0,0,0,2863,2866,1,0,0,0,2864,2862,1,0,0,0,2864,2865,1,0,0,0,2865,2867,
  	1,0,0,0,2866,2864,1,0,0,0,2867,2943,3,380,190,0,2868,2870,3,694,347,0,
  	2869,2868,1,0,0,0,2870,2873,1,0,0,0,2871,2869,1,0,0,0,2871,2872,1,0,0,
  	0,2872,2874,1,0,0,0,2873,2871,1,0,0,0,2874,2943,3,384,192,0,2875,2877,
  	3,694,347,0,2876,2875,1,0,0,0,2877,2880,1,0,0,0,2878,2876,1,0,0,0,2878,
  	2879,1,0,0,0,2879,2881,1,0,0,0,2880,2878,1,0,0,0,2881,2943,3,400,200,
  	0,2882,2884,3,694,347,0,2883,2882,1,0,0,0,2884,2887,1,0,0,0,2885,2883,
  	1,0,0,0,2885,2886,1,0,0,0,2886,2888,1,0,0,0,2887,2885,1,0,0,0,2888,2889,
  	3,358,179,0,2889,2890,5,147,0,0,2890,2943,1,0,0,0,2891,2893,3,694,347,
  	0,2892,2891,1,0,0,0,2893,2896,1,0,0,0,2894,2892,1,0,0,0,2894,2895,1,0,
  	0,0,2895,2897,1,0,0,0,2896,2894,1,0,0,0,2897,2943,3,364,182,0,2898,2900,
  	3,694,347,0,2899,2898,1,0,0,0,2900,2903,1,0,0,0,2901,2899,1,0,0,0,2901,
  	2902,1,0,0,0,2902,2904,1,0,0,0,2903,2901,1,0,0,0,2904,2905,3,360,180,
  	0,2905,2906,5,147,0,0,2906,2943,1,0,0,0,2907,2909,3,694,347,0,2908,2907,
  	1,0,0,0,2909,2912,1,0,0,0,2910,2908,1,0,0,0,2910,2911,1,0,0,0,2911,2913,
  	1,0,0,0,2912,2910,1,0,0,0,2913,2943,3,390,195,0,2914,2916,3,694,347,0,
  	2915,2914,1,0,0,0,2916,2919,1,0,0,0,2917,2915,1,0,0,0,2917,2918,1,0,0,
  	0,2918,2920,1,0,0,0,2919,2917,1,0,0,0,2920,2943,3,368,184,0,2921,2923,
  	3,694,347,0,2922,2921,1,0,0,0,2923,2926,1,0,0,0,2924,2922,1,0,0,0,2924,
  	2925,1,0,0,0,2925,2927,1,0,0,0,2926,2924,1,0,0,0,2927,2943,3,402,201,
  	0,2928,2930,3,694,347,0,2929,2928,1,0,0,0,2930,2933,1,0,0,0,2931,2929,
  	1,0,0,0,2931,2932,1,0,0,0,2932,2934,1,0,0,0,2933,2931,1,0,0,0,2934,2943,
  	3,408,204,0,2935,2937,3,694,347,0,2936,2935,1,0,0,0,2937,2940,1,0,0,0,
  	2938,2936,1,0,0,0,2938,2939,1,0,0,0,2939,2941,1,0,0,0,2940,2938,1,0,0,
  	0,2941,2943,3,392,196,0,2942,2841,1,0,0,0,2942,2850,1,0,0,0,2942,2857,
  	1,0,0,0,2942,2864,1,0,0,0,2942,2871,1,0,0,0,2942,2878,1,0,0,0,2942,2885,
  	1,0,0,0,2942,2894,1,0,0,0,2942,2901,1,0,0,0,2942,2910,1,0,0,0,2942,2917,
  	1,0,0,0,2942,2924,1,0,0,0,2942,2931,1,0,0,0,2942,2938,1,0,0,0,2943,371,
  	1,0,0,0,2944,2953,3,370,185,0,2945,2947,3,694,347,0,2946,2945,1,0,0,0,
  	2947,2950,1,0,0,0,2948,2946,1,0,0,0,2948,2949,1,0,0,0,2949,2951,1,0,0,
  	0,2950,2948,1,0,0,0,2951,2953,5,147,0,0,2952,2944,1,0,0,0,2952,2948,1,
  	0,0,0,2953,373,1,0,0,0,2954,2955,3,370,185,0,2955,375,1,0,0,0,2956,2957,
  	5,78,0,0,2957,2964,3,112,56,0,2958,2959,5,78,0,0,2959,2960,5,96,0,0,2960,
  	2961,3,622,311,0,2961,2962,5,142,0,0,2962,2964,1,0,0,0,2963,2956,1,0,
  	0,0,2963,2958,1,0,0,0,2964,377,1,0,0,0,2965,2974,3,376,188,0,2966,2974,
  	3,382,191,0,2967,2968,5,140,0,0,2968,2969,5,96,0,0,2969,2970,3,618,309,
  	0,2970,2971,5,142,0,0,2971,2972,3,382,191,0,2972,2974,1,0,0,0,2973,2965,
  	1,0,0,0,2973,2966,1,0,0,0,2973,2967,1,0,0,0,2974,379,1,0,0,0,2975,2976,
  	5,30,0,0,2976,2977,3,718,359,0,2977,2978,5,147,0,0,2978,381,1,0,0,0,2979,
  	2980,5,10,0,0,2980,2993,3,718,359,0,2981,2982,5,10,0,0,2982,2983,5,96,
  	0,0,2983,2984,3,386,193,0,2984,2985,5,142,0,0,2985,2993,1,0,0,0,2986,
  	2987,5,10,0,0,2987,2993,5,6,0,0,2988,2989,5,10,0,0,2989,2990,5,96,0,0,
  	2990,2991,5,6,0,0,2991,2993,5,142,0,0,2992,2979,1,0,0,0,2992,2981,1,0,
  	0,0,2992,2986,1,0,0,0,2992,2988,1,0,0,0,2993,383,1,0,0,0,2994,2995,5,
  	105,0,0,2995,2997,3,718,359,0,2996,2998,3,642,321,0,2997,2996,1,0,0,0,
  	2997,2998,1,0,0,0,2998,2999,1,0,0,0,2999,3000,5,147,0,0,3000,385,1,0,
  	0,0,3001,3002,6,193,-1,0,3002,3008,3,618,309,0,3003,3004,5,124,0,0,3004,
  	3008,3,618,309,0,3005,3006,5,110,0,0,3006,3008,3,618,309,0,3007,3001,
  	1,0,0,0,3007,3003,1,0,0,0,3007,3005,1,0,0,0,3008,3017,1,0,0,0,3009,3010,
  	10,2,0,0,3010,3011,5,117,0,0,3011,3016,3,386,193,3,3012,3013,10,1,0,0,
  	3013,3014,5,24,0,0,3014,3016,3,386,193,2,3015,3009,1,0,0,0,3015,3012,
  	1,0,0,0,3016,3019,1,0,0,0,3017,3015,1,0,0,0,3017,3018,1,0,0,0,3018,387,
  	1,0,0,0,3019,3017,1,0,0,0,3020,3023,3,376,188,0,3021,3023,3,382,191,0,
  	3022,3020,1,0,0,0,3022,3021,1,0,0,0,3023,389,1,0,0,0,3024,3025,3,388,
  	194,0,3025,3026,3,372,186,0,3026,391,1,0,0,0,3027,3028,5,180,0,0,3028,
  	3029,5,96,0,0,3029,3030,3,618,309,0,3030,3031,5,142,0,0,3031,3032,3,372,
  	186,0,3032,393,1,0,0,0,3033,3034,5,81,0,0,3034,3035,5,96,0,0,3035,3036,
  	3,618,309,0,3036,3037,5,142,0,0,3037,3040,3,372,186,0,3038,3039,5,47,
  	0,0,3039,3041,3,372,186,0,3040,3038,1,0,0,0,3040,3041,1,0,0,0,3041,395,
  	1,0,0,0,3042,3043,5,17,0,0,3043,3044,5,96,0,0,3044,3045,3,618,309,0,3045,
  	3047,5,142,0,0,3046,3048,3,398,199,0,3047,3046,1,0,0,0,3048,3049,1,0,
  	0,0,3049,3047,1,0,0,0,3049,3050,1,0,0,0,3050,3051,1,0,0,0,3051,3052,5,
  	52,0,0,3052,3076,1,0,0,0,3053,3054,5,19,0,0,3054,3055,5,96,0,0,3055,3056,
  	3,618,309,0,3056,3058,5,142,0,0,3057,3059,3,398,199,0,3058,3057,1,0,0,
  	0,3059,3060,1,0,0,0,3060,3058,1,0,0,0,3060,3061,1,0,0,0,3061,3062,1,0,
  	0,0,3062,3063,5,52,0,0,3063,3076,1,0,0,0,3064,3065,5,18,0,0,3065,3066,
  	5,96,0,0,3066,3067,3,618,309,0,3067,3069,5,142,0,0,3068,3070,3,398,199,
  	0,3069,3068,1,0,0,0,3070,3071,1,0,0,0,3071,3069,1,0,0,0,3071,3072,1,0,
  	0,0,3072,3073,1,0,0,0,3073,3074,5,52,0,0,3074,3076,1,0,0,0,3075,3042,
  	1,0,0,0,3075,3053,1,0,0,0,3075,3064,1,0,0,0,3076,397,1,0,0,0,3077,3082,
  	3,618,309,0,3078,3079,5,24,0,0,3079,3081,3,618,309,0,3080,3078,1,0,0,
  	0,3081,3084,1,0,0,0,3082,3080,1,0,0,0,3082,3083,1,0,0,0,3083,3085,1,0,
  	0,0,3084,3082,1,0,0,0,3085,3086,5,22,0,0,3086,3087,3,372,186,0,3087,3094,
  	1,0,0,0,3088,3090,5,27,0,0,3089,3091,5,22,0,0,3090,3089,1,0,0,0,3090,
  	3091,1,0,0,0,3091,3092,1,0,0,0,3092,3094,3,372,186,0,3093,3077,1,0,0,
  	0,3093,3088,1,0,0,0,3094,399,1,0,0,0,3095,3096,5,68,0,0,3096,3120,3,370,
  	185,0,3097,3098,5,140,0,0,3098,3099,5,96,0,0,3099,3100,3,618,309,0,3100,
  	3101,5,142,0,0,3101,3102,3,370,185,0,3102,3120,1,0,0,0,3103,3104,5,184,
  	0,0,3104,3105,5,96,0,0,3105,3106,3,618,309,0,3106,3107,5,142,0,0,3107,
  	3108,3,370,185,0,3108,3120,1,0,0,0,3109,3110,5,66,0,0,3110,3111,5,96,
  	0,0,3111,3112,3,362,181,0,3112,3113,5,147,0,0,3113,3114,3,618,309,0,3114,
  	3115,5,147,0,0,3115,3116,3,362,181,0,3116,3117,5,142,0,0,3117,3118,3,
  	370,185,0,3118,3120,1,0,0,0,3119,3095,1,0,0,0,3119,3097,1,0,0,0,3119,
  	3103,1,0,0,0,3119,3109,1,0,0,0,3120,401,1,0,0,0,3121,3123,3,750,375,0,
  	3122,3124,3,404,202,0,3123,3122,1,0,0,0,3123,3124,1,0,0,0,3124,3125,1,
  	0,0,0,3125,3126,5,147,0,0,3126,403,1,0,0,0,3127,3128,5,96,0,0,3128,3133,
  	3,406,203,0,3129,3130,5,24,0,0,3130,3132,3,406,203,0,3131,3129,1,0,0,
  	0,3132,3135,1,0,0,0,3133,3131,1,0,0,0,3133,3134,1,0,0,0,3134,3136,1,0,
  	0,0,3135,3133,1,0,0,0,3136,3137,5,142,0,0,3137,405,1,0,0,0,3138,3140,
  	3,618,309,0,3139,3138,1,0,0,0,3139,3140,1,0,0,0,3140,407,1,0,0,0,3141,
  	3143,3,718,359,0,3142,3144,3,410,205,0,3143,3142,1,0,0,0,3143,3144,1,
  	0,0,0,3144,3145,1,0,0,0,3145,3146,5,147,0,0,3146,409,1,0,0,0,3147,3148,
  	5,96,0,0,3148,3153,3,618,309,0,3149,3150,5,24,0,0,3150,3152,3,618,309,
  	0,3151,3149,1,0,0,0,3152,3155,1,0,0,0,3153,3151,1,0,0,0,3153,3154,1,0,
  	0,0,3154,3156,1,0,0,0,3155,3153,1,0,0,0,3156,3157,5,142,0,0,3157,411,
  	1,0,0,0,3158,3162,5,153,0,0,3159,3161,3,414,207,0,3160,3159,1,0,0,0,3161,
  	3164,1,0,0,0,3162,3160,1,0,0,0,3162,3163,1,0,0,0,3163,3165,1,0,0,0,3164,
  	3162,1,0,0,0,3165,3166,5,58,0,0,3166,413,1,0,0,0,3167,3173,3,68,34,0,
  	3168,3173,3,416,208,0,3169,3173,3,418,209,0,3170,3173,3,420,210,0,3171,
  	3173,3,492,246,0,3172,3167,1,0,0,0,3172,3168,1,0,0,0,3172,3169,1,0,0,
  	0,3172,3170,1,0,0,0,3172,3171,1,0,0,0,3173,415,1,0,0,0,3174,3175,5,131,
  	0,0,3175,3176,3,430,215,0,3176,3177,5,147,0,0,3177,3183,1,0,0,0,3178,
  	3179,5,130,0,0,3179,3180,3,430,215,0,3180,3181,5,147,0,0,3181,3183,1,
  	0,0,0,3182,3174,1,0,0,0,3182,3178,1,0,0,0,3183,417,1,0,0,0,3184,3185,
  	5,149,0,0,3185,3186,3,430,215,0,3186,3187,5,147,0,0,3187,3193,1,0,0,0,
  	3188,3189,5,113,0,0,3189,3190,3,430,215,0,3190,3191,5,147,0,0,3191,3193,
  	1,0,0,0,3192,3184,1,0,0,0,3192,3188,1,0,0,0,3193,419,1,0,0,0,3194,3195,
  	3,422,211,0,3195,3196,5,147,0,0,3196,3204,1,0,0,0,3197,3198,3,478,239,
  	0,3198,3199,5,147,0,0,3199,3204,1,0,0,0,3200,3201,3,488,244,0,3201,3202,
  	5,147,0,0,3202,3204,1,0,0,0,3203,3194,1,0,0,0,3203,3197,1,0,0,0,3203,
  	3200,1,0,0,0,3204,421,1,0,0,0,3205,3206,3,424,212,0,3206,3207,5,61,0,
  	0,3207,3208,3,440,220,0,3208,3214,1,0,0,0,3209,3210,3,426,213,0,3210,
  	3211,5,61,0,0,3211,3212,3,440,220,0,3212,3214,1,0,0,0,3213,3205,1,0,0,
  	0,3213,3209,1,0,0,0,3214,423,1,0,0,0,3215,3216,5,96,0,0,3216,3218,3,432,
  	216,0,3217,3219,3,490,245,0,3218,3217,1,0,0,0,3218,3219,1,0,0,0,3219,
  	3220,1,0,0,0,3220,3221,5,64,0,0,3221,3222,3,434,217,0,3222,3223,5,142,
  	0,0,3223,425,1,0,0,0,3224,3225,5,96,0,0,3225,3227,3,428,214,0,3226,3228,
  	3,490,245,0,3227,3226,1,0,0,0,3227,3228,1,0,0,0,3228,3229,1,0,0,0,3229,
  	3230,5,8,0,0,3230,3231,3,430,215,0,3231,3232,5,142,0,0,3232,427,1,0,0,
  	0,3233,3238,3,432,216,0,3234,3235,5,24,0,0,3235,3237,3,432,216,0,3236,
  	3234,1,0,0,0,3237,3240,1,0,0,0,3238,3236,1,0,0,0,3238,3239,1,0,0,0,3239,
  	429,1,0,0,0,3240,3238,1,0,0,0,3241,3246,3,434,217,0,3242,3243,5,24,0,
  	0,3243,3245,3,434,217,0,3244,3242,1,0,0,0,3245,3248,1,0,0,0,3246,3244,
  	1,0,0,0,3246,3247,1,0,0,0,3247,431,1,0,0,0,3248,3246,1,0,0,0,3249,3254,
  	3,436,218,0,3250,3251,5,91,0,0,3251,3252,3,614,307,0,3252,3253,5,133,
  	0,0,3253,3255,1,0,0,0,3254,3250,1,0,0,0,3254,3255,1,0,0,0,3255,433,1,
  	0,0,0,3256,3261,3,438,219,0,3257,3258,5,91,0,0,3258,3259,3,614,307,0,
  	3259,3260,5,133,0,0,3260,3262,1,0,0,0,3261,3257,1,0,0,0,3261,3262,1,0,
  	0,0,3262,435,1,0,0,0,3263,3264,3,740,370,0,3264,437,1,0,0,0,3265,3266,
  	3,740,370,0,3266,439,1,0,0,0,3267,3273,3,442,221,0,3268,3269,5,96,0,0,
  	3269,3270,3,442,221,0,3270,3271,5,142,0,0,3271,3273,1,0,0,0,3272,3267,
  	1,0,0,0,3272,3268,1,0,0,0,3273,441,1,0,0,0,3274,3309,3,444,222,0,3275,
  	3276,3,446,223,0,3276,3277,5,24,0,0,3277,3280,3,448,224,0,3278,3279,5,
  	24,0,0,3279,3281,3,450,225,0,3280,3278,1,0,0,0,3280,3281,1,0,0,0,3281,
  	3309,1,0,0,0,3282,3283,3,452,226,0,3283,3284,5,24,0,0,3284,3285,3,454,
  	227,0,3285,3286,5,24,0,0,3286,3287,3,456,228,0,3287,3288,5,24,0,0,3288,
  	3289,3,458,229,0,3289,3290,5,24,0,0,3290,3291,3,460,230,0,3291,3292,5,
  	24,0,0,3292,3306,3,462,231,0,3293,3294,5,24,0,0,3294,3295,3,464,232,0,
  	3295,3296,5,24,0,0,3296,3297,3,466,233,0,3297,3298,5,24,0,0,3298,3299,
  	3,468,234,0,3299,3300,5,24,0,0,3300,3301,3,470,235,0,3301,3302,5,24,0,
  	0,3302,3303,3,472,236,0,3303,3304,5,24,0,0,3304,3305,3,474,237,0,3305,
  	3307,1,0,0,0,3306,3293,1,0,0,0,3306,3307,1,0,0,0,3307,3309,1,0,0,0,3308,
  	3274,1,0,0,0,3308,3275,1,0,0,0,3308,3282,1,0,0,0,3309,443,1,0,0,0,3310,
  	3311,3,476,238,0,3311,445,1,0,0,0,3312,3313,3,476,238,0,3313,447,1,0,
  	0,0,3314,3315,3,476,238,0,3315,449,1,0,0,0,3316,3317,3,476,238,0,3317,
  	451,1,0,0,0,3318,3319,3,476,238,0,3319,453,1,0,0,0,3320,3321,3,476,238,
  	0,3321,455,1,0,0,0,3322,3323,3,476,238,0,3323,457,1,0,0,0,3324,3325,3,
  	476,238,0,3325,459,1,0,0,0,3326,3327,3,476,238,0,3327,461,1,0,0,0,3328,
  	3329,3,476,238,0,3329,463,1,0,0,0,3330,3331,3,476,238,0,3331,465,1,0,
  	0,0,3332,3333,3,476,238,0,3333,467,1,0,0,0,3334,3335,3,476,238,0,3335,
  	469,1,0,0,0,3336,3337,3,476,238,0,3337,471,1,0,0,0,3338,3339,3,476,238,
  	0,3339,473,1,0,0,0,3340,3341,3,476,238,0,3341,475,1,0,0,0,3342,3343,3,
  	612,306,0,3343,477,1,0,0,0,3344,3345,3,480,240,0,3345,3346,5,61,0,0,3346,
  	3347,3,440,220,0,3347,3353,1,0,0,0,3348,3349,3,482,241,0,3349,3350,5,
  	61,0,0,3350,3351,3,440,220,0,3351,3353,1,0,0,0,3352,3344,1,0,0,0,3352,
  	3348,1,0,0,0,3353,479,1,0,0,0,3354,3356,5,96,0,0,3355,3357,3,486,243,
  	0,3356,3355,1,0,0,0,3356,3357,1,0,0,0,3357,3358,1,0,0,0,3358,3359,3,432,
  	216,0,3359,3360,5,64,0,0,3360,3361,5,96,0,0,3361,3363,3,434,217,0,3362,
  	3364,3,490,245,0,3363,3362,1,0,0,0,3363,3364,1,0,0,0,3364,3365,1,0,0,
  	0,3365,3366,5,22,0,0,3366,3367,3,484,242,0,3367,3368,5,142,0,0,3368,3369,
  	5,142,0,0,3369,481,1,0,0,0,3370,3372,5,96,0,0,3371,3373,3,486,243,0,3372,
  	3371,1,0,0,0,3372,3373,1,0,0,0,3373,3374,1,0,0,0,3374,3375,3,428,214,
  	0,3375,3376,5,8,0,0,3376,3377,5,96,0,0,3377,3379,3,430,215,0,3378,3380,
  	3,490,245,0,3379,3378,1,0,0,0,3379,3380,1,0,0,0,3380,3381,1,0,0,0,3381,
  	3382,5,22,0,0,3382,3383,3,484,242,0,3383,3384,5,142,0,0,3384,3385,5,142,
  	0,0,3385,483,1,0,0,0,3386,3387,3,618,309,0,3387,485,1,0,0,0,3388,3389,
  	7,15,0,0,3389,487,1,0,0,0,3390,3391,5,81,0,0,3391,3392,5,96,0,0,3392,
  	3393,3,624,312,0,3393,3394,5,142,0,0,3394,3395,3,422,211,0,3395,3405,
  	1,0,0,0,3396,3397,5,81,0,0,3397,3398,5,96,0,0,3398,3399,3,624,312,0,3399,
  	3400,5,142,0,0,3400,3401,3,478,239,0,3401,3405,1,0,0,0,3402,3403,5,82,
  	0,0,3403,3405,3,422,211,0,3404,3390,1,0,0,0,3404,3396,1,0,0,0,3404,3402,
  	1,0,0,0,3405,489,1,0,0,0,3406,3407,7,16,0,0,3407,491,1,0,0,0,3408,3421,
  	3,494,247,0,3409,3421,3,498,249,0,3410,3421,3,500,250,0,3411,3421,3,512,
  	256,0,3412,3421,3,514,257,0,3413,3421,3,516,258,0,3414,3421,3,518,259,
  	0,3415,3421,3,520,260,0,3416,3421,3,528,264,0,3417,3421,3,530,265,0,3418,
  	3421,3,532,266,0,3419,3421,3,536,268,0,3420,3408,1,0,0,0,3420,3409,1,
  	0,0,0,3420,3410,1,0,0,0,3420,3411,1,0,0,0,3420,3412,1,0,0,0,3420,3413,
  	1,0,0,0,3420,3414,1,0,0,0,3420,3415,1,0,0,0,3420,3416,1,0,0,0,3420,3417,
  	1,0,0,0,3420,3418,1,0,0,0,3420,3419,1,0,0,0,3421,493,1,0,0,0,3422,3423,
  	5,39,0,0,3423,3424,5,96,0,0,3424,3425,3,542,271,0,3425,3426,5,24,0,0,
  	3426,3427,3,554,277,0,3427,3428,5,24,0,0,3428,3430,3,564,282,0,3429,3431,
  	3,496,248,0,3430,3429,1,0,0,0,3430,3431,1,0,0,0,3431,3432,1,0,0,0,3432,
  	3433,5,142,0,0,3433,3434,5,147,0,0,3434,495,1,0,0,0,3435,3437,5,24,0,
  	0,3436,3438,3,552,276,0,3437,3436,1,0,0,0,3437,3438,1,0,0,0,3438,497,
  	1,0,0,0,3439,3440,5,33,0,0,3440,3441,5,96,0,0,3441,3442,3,554,277,0,3442,
  	3443,5,24,0,0,3443,3444,3,542,271,0,3444,3445,5,24,0,0,3445,3447,3,564,
  	282,0,3446,3448,3,496,248,0,3447,3446,1,0,0,0,3447,3448,1,0,0,0,3448,
  	3449,1,0,0,0,3449,3450,5,142,0,0,3450,3451,5,147,0,0,3451,499,1,0,0,0,
  	3452,3453,5,40,0,0,3453,3454,5,96,0,0,3454,3455,3,554,277,0,3455,3456,
  	5,24,0,0,3456,3457,3,542,271,0,3457,3458,5,24,0,0,3458,3459,3,564,282,
  	0,3459,3460,5,24,0,0,3460,3462,3,564,282,0,3461,3463,3,502,251,0,3462,
  	3461,1,0,0,0,3462,3463,1,0,0,0,3463,3464,1,0,0,0,3464,3465,5,142,0,0,
  	3465,3466,5,147,0,0,3466,501,1,0,0,0,3467,3469,5,24,0,0,3468,3470,3,552,
  	276,0,3469,3468,1,0,0,0,3469,3470,1,0,0,0,3470,3472,1,0,0,0,3471,3473,
  	3,504,252,0,3472,3471,1,0,0,0,3472,3473,1,0,0,0,3473,503,1,0,0,0,3474,
  	3476,5,24,0,0,3475,3477,3,558,279,0,3476,3475,1,0,0,0,3476,3477,1,0,0,
  	0,3477,3479,1,0,0,0,3478,3480,3,506,253,0,3479,3478,1,0,0,0,3479,3480,
  	1,0,0,0,3480,505,1,0,0,0,3481,3483,5,24,0,0,3482,3484,3,538,269,0,3483,
  	3482,1,0,0,0,3483,3484,1,0,0,0,3484,3486,1,0,0,0,3485,3487,3,508,254,
  	0,3486,3485,1,0,0,0,3486,3487,1,0,0,0,3487,507,1,0,0,0,3488,3490,5,24,
  	0,0,3489,3491,3,546,273,0,3490,3489,1,0,0,0,3490,3491,1,0,0,0,3491,3493,
  	1,0,0,0,3492,3494,3,510,255,0,3493,3492,1,0,0,0,3493,3494,1,0,0,0,3494,
  	509,1,0,0,0,3495,3497,5,24,0,0,3496,3498,3,544,272,0,3497,3496,1,0,0,
  	0,3497,3498,1,0,0,0,3498,511,1,0,0,0,3499,3500,5,36,0,0,3500,3501,5,96,
  	0,0,3501,3502,3,554,277,0,3502,3503,5,24,0,0,3503,3504,3,542,271,0,3504,
  	3505,5,24,0,0,3505,3507,3,564,282,0,3506,3508,3,496,248,0,3507,3506,1,
  	0,0,0,3507,3508,1,0,0,0,3508,3509,1,0,0,0,3509,3510,5,142,0,0,3510,3511,
  	5,147,0,0,3511,513,1,0,0,0,3512,3513,5,38,0,0,3513,3514,5,96,0,0,3514,
  	3515,3,554,277,0,3515,3516,5,24,0,0,3516,3517,3,542,271,0,3517,3518,5,
  	24,0,0,3518,3520,3,564,282,0,3519,3521,3,496,248,0,3520,3519,1,0,0,0,
  	3520,3521,1,0,0,0,3521,3522,1,0,0,0,3522,3523,5,142,0,0,3523,3524,5,147,
  	0,0,3524,515,1,0,0,0,3525,3526,5,37,0,0,3526,3527,5,96,0,0,3527,3528,
  	3,554,277,0,3528,3529,5,24,0,0,3529,3530,3,542,271,0,3530,3531,5,24,0,
  	0,3531,3532,3,564,282,0,3532,3533,5,24,0,0,3533,3535,3,564,282,0,3534,
  	3536,3,502,251,0,3535,3534,1,0,0,0,3535,3536,1,0,0,0,3536,3537,1,0,0,
  	0,3537,3538,5,142,0,0,3538,3539,5,147,0,0,3539,517,1,0,0,0,3540,3541,
  	5,41,0,0,3541,3542,5,96,0,0,3542,3543,3,554,277,0,3543,3544,5,24,0,0,
  	3544,3545,3,542,271,0,3545,3546,5,24,0,0,3546,3548,3,564,282,0,3547,3549,
  	3,496,248,0,3548,3547,1,0,0,0,3548,3549,1,0,0,0,3549,3550,1,0,0,0,3550,
  	3551,5,142,0,0,3551,3552,5,147,0,0,3552,519,1,0,0,0,3553,3554,5,42,0,
  	0,3554,3555,5,96,0,0,3555,3556,3,554,277,0,3556,3557,5,24,0,0,3557,3558,
  	3,542,271,0,3558,3559,5,24,0,0,3559,3561,3,564,282,0,3560,3562,3,522,
  	261,0,3561,3560,1,0,0,0,3561,3562,1,0,0,0,3562,3563,1,0,0,0,3563,3564,
  	5,142,0,0,3564,3565,5,147,0,0,3565,521,1,0,0,0,3566,3568,5,24,0,0,3567,
  	3569,3,552,276,0,3568,3567,1,0,0,0,3568,3569,1,0,0,0,3569,3571,1,0,0,
  	0,3570,3572,3,524,262,0,3571,3570,1,0,0,0,3571,3572,1,0,0,0,3572,523,
  	1,0,0,0,3573,3575,5,24,0,0,3574,3576,3,550,275,0,3575,3574,1,0,0,0,3575,
  	3576,1,0,0,0,3576,3578,1,0,0,0,3577,3579,3,526,263,0,3578,3577,1,0,0,
  	0,3578,3579,1,0,0,0,3579,525,1,0,0,0,3580,3582,5,24,0,0,3581,3583,3,556,
  	278,0,3582,3581,1,0,0,0,3582,3583,1,0,0,0,3583,527,1,0,0,0,3584,3585,
  	5,32,0,0,3585,3586,5,96,0,0,3586,3587,3,554,277,0,3587,3588,5,24,0,0,
  	3588,3589,3,542,271,0,3589,3590,5,24,0,0,3590,3591,3,564,282,0,3591,3592,
  	5,24,0,0,3592,3594,3,564,282,0,3593,3595,3,522,261,0,3594,3593,1,0,0,
  	0,3594,3595,1,0,0,0,3595,3596,1,0,0,0,3596,3597,5,142,0,0,3597,3598,5,
  	147,0,0,3598,529,1,0,0,0,3599,3600,5,35,0,0,3600,3601,5,96,0,0,3601,3602,
  	3,540,270,0,3602,3603,5,24,0,0,3603,3605,3,564,282,0,3604,3606,3,496,
  	248,0,3605,3604,1,0,0,0,3605,3606,1,0,0,0,3606,3607,1,0,0,0,3607,3608,
  	5,142,0,0,3608,3609,5,147,0,0,3609,531,1,0,0,0,3610,3611,5,43,0,0,3611,
  	3612,5,96,0,0,3612,3613,3,540,270,0,3613,3614,5,24,0,0,3614,3616,3,564,
  	282,0,3615,3617,3,534,267,0,3616,3615,1,0,0,0,3616,3617,1,0,0,0,3617,
  	3618,1,0,0,0,3618,3619,5,142,0,0,3619,3620,5,147,0,0,3620,533,1,0,0,0,
  	3621,3622,5,24,0,0,3622,3625,3,562,281,0,3623,3624,5,24,0,0,3624,3626,
  	3,552,276,0,3625,3623,1,0,0,0,3625,3626,1,0,0,0,3626,535,1,0,0,0,3627,
  	3628,5,34,0,0,3628,3629,5,96,0,0,3629,3630,3,554,277,0,3630,3631,5,24,
  	0,0,3631,3632,3,542,271,0,3632,3633,5,24,0,0,3633,3634,3,560,280,0,3634,
  	3635,5,24,0,0,3635,3637,3,548,274,0,3636,3638,3,496,248,0,3637,3636,1,
  	0,0,0,3637,3638,1,0,0,0,3638,3639,1,0,0,0,3639,3640,5,142,0,0,3640,3641,
  	5,147,0,0,3641,537,1,0,0,0,3642,3643,3,622,311,0,3643,539,1,0,0,0,3644,
  	3645,3,568,284,0,3645,541,1,0,0,0,3646,3647,3,566,283,0,3647,543,1,0,
  	0,0,3648,3653,3,754,377,0,3649,3650,5,91,0,0,3650,3651,3,612,306,0,3651,
  	3652,5,133,0,0,3652,3654,1,0,0,0,3653,3649,1,0,0,0,3653,3654,1,0,0,0,
  	3654,545,1,0,0,0,3655,3660,3,754,377,0,3656,3657,5,91,0,0,3657,3658,3,
  	612,306,0,3658,3659,5,133,0,0,3659,3661,1,0,0,0,3660,3656,1,0,0,0,3660,
  	3661,1,0,0,0,3661,547,1,0,0,0,3662,3663,3,622,311,0,3663,549,1,0,0,0,
  	3664,3665,3,610,305,0,3665,551,1,0,0,0,3666,3667,3,762,381,0,3667,553,
  	1,0,0,0,3668,3669,3,566,283,0,3669,555,1,0,0,0,3670,3671,3,610,305,0,
  	3671,557,1,0,0,0,3672,3673,3,622,311,0,3673,559,1,0,0,0,3674,3675,3,622,
  	311,0,3675,561,1,0,0,0,3676,3677,3,610,305,0,3677,563,1,0,0,0,3678,3679,
  	3,618,309,0,3679,565,1,0,0,0,3680,3682,3,570,285,0,3681,3680,1,0,0,0,
  	3681,3682,1,0,0,0,3682,3683,1,0,0,0,3683,3686,3,572,286,0,3684,3685,5,
  	4,0,0,3685,3687,3,578,289,0,3686,3684,1,0,0,0,3686,3687,1,0,0,0,3687,
  	567,1,0,0,0,3688,3689,3,570,285,0,3689,3692,3,572,286,0,3690,3691,5,4,
  	0,0,3691,3693,3,578,289,0,3692,3690,1,0,0,0,3692,3693,1,0,0,0,3693,569,
  	1,0,0,0,3694,3698,5,124,0,0,3695,3698,5,110,0,0,3696,3698,3,574,287,0,
  	3697,3694,1,0,0,0,3697,3695,1,0,0,0,3697,3696,1,0,0,0,3698,571,1,0,0,
  	0,3699,3702,3,432,216,0,3700,3702,3,434,217,0,3701,3699,1,0,0,0,3701,
  	3700,1,0,0,0,3702,573,1,0,0,0,3703,3704,5,46,0,0,3704,3705,5,91,0,0,3705,
  	3710,3,576,288,0,3706,3707,5,24,0,0,3707,3709,3,576,288,0,3708,3706,1,
  	0,0,0,3709,3712,1,0,0,0,3710,3708,1,0,0,0,3710,3711,1,0,0,0,3711,3713,
  	1,0,0,0,3712,3710,1,0,0,0,3713,3714,5,133,0,0,3714,575,1,0,0,0,3715,3716,
  	5,204,0,0,3716,577,1,0,0,0,3717,3723,3,580,290,0,3718,3719,5,96,0,0,3719,
  	3720,3,580,290,0,3720,3721,5,142,0,0,3721,3723,1,0,0,0,3722,3717,1,0,
  	0,0,3722,3718,1,0,0,0,3723,579,1,0,0,0,3724,3744,3,618,309,0,3725,3726,
  	5,161,0,0,3726,3744,3,618,309,0,3727,3728,3,618,309,0,3728,3729,5,62,
  	0,0,3729,3730,3,582,291,0,3730,3744,1,0,0,0,3731,3732,3,618,309,0,3732,
  	3733,5,63,0,0,3733,3734,3,582,291,0,3734,3744,1,0,0,0,3735,3736,3,618,
  	309,0,3736,3737,5,49,0,0,3737,3738,3,582,291,0,3738,3744,1,0,0,0,3739,
  	3740,3,618,309,0,3740,3741,5,50,0,0,3741,3742,3,582,291,0,3742,3744,1,
  	0,0,0,3743,3724,1,0,0,0,3743,3725,1,0,0,0,3743,3727,1,0,0,0,3743,3731,
  	1,0,0,0,3743,3735,1,0,0,0,3743,3739,1,0,0,0,3744,581,1,0,0,0,3745,3748,
  	3,662,331,0,3746,3748,3,674,337,0,3747,3745,1,0,0,0,3747,3746,1,0,0,0,
  	3748,583,1,0,0,0,3749,3750,5,92,0,0,3750,3755,3,618,309,0,3751,3752,5,
  	24,0,0,3752,3754,3,618,309,0,3753,3751,1,0,0,0,3754,3757,1,0,0,0,3755,
  	3753,1,0,0,0,3755,3756,1,0,0,0,3756,3758,1,0,0,0,3757,3755,1,0,0,0,3758,
  	3759,5,134,0,0,3759,585,1,0,0,0,3760,3761,5,92,0,0,3761,3766,3,610,305,
  	0,3762,3763,5,24,0,0,3763,3765,3,610,305,0,3764,3762,1,0,0,0,3765,3768,
  	1,0,0,0,3766,3764,1,0,0,0,3766,3767,1,0,0,0,3767,3769,1,0,0,0,3768,3766,
  	1,0,0,0,3769,3770,5,134,0,0,3770,587,1,0,0,0,3771,3772,5,92,0,0,3772,
  	3773,3,610,305,0,3773,3774,3,586,293,0,3774,3775,5,134,0,0,3775,589,1,
  	0,0,0,3776,3777,5,92,0,0,3777,3782,3,624,312,0,3778,3779,5,24,0,0,3779,
  	3781,3,624,312,0,3780,3778,1,0,0,0,3781,3784,1,0,0,0,3782,3780,1,0,0,
  	0,3782,3783,1,0,0,0,3783,3785,1,0,0,0,3784,3782,1,0,0,0,3785,3786,5,134,
  	0,0,3786,591,1,0,0,0,3787,3788,5,92,0,0,3788,3789,3,610,305,0,3789,3790,
  	3,590,295,0,3790,3791,5,134,0,0,3791,593,1,0,0,0,3792,3793,5,92,0,0,3793,
  	3794,3,610,305,0,3794,3795,3,584,292,0,3795,3796,5,134,0,0,3796,595,1,
  	0,0,0,3797,3801,3,710,355,0,3798,3800,3,694,347,0,3799,3798,1,0,0,0,3800,
  	3803,1,0,0,0,3801,3799,1,0,0,0,3801,3802,1,0,0,0,3802,3804,1,0,0,0,3803,
  	3801,1,0,0,0,3804,3805,5,96,0,0,3805,3810,3,610,305,0,3806,3807,5,24,
  	0,0,3807,3809,3,610,305,0,3808,3806,1,0,0,0,3809,3812,1,0,0,0,3810,3808,
  	1,0,0,0,3810,3811,1,0,0,0,3811,3813,1,0,0,0,3812,3810,1,0,0,0,3813,3814,
  	5,142,0,0,3814,597,1,0,0,0,3815,3816,3,748,374,0,3816,3817,5,96,0,0,3817,
  	3822,3,610,305,0,3818,3819,5,24,0,0,3819,3821,3,610,305,0,3820,3818,1,
  	0,0,0,3821,3824,1,0,0,0,3822,3820,1,0,0,0,3822,3823,1,0,0,0,3823,3825,
  	1,0,0,0,3824,3822,1,0,0,0,3825,3826,5,142,0,0,3826,599,1,0,0,0,3827,3831,
  	3,718,359,0,3828,3830,3,694,347,0,3829,3828,1,0,0,0,3830,3833,1,0,0,0,
  	3831,3829,1,0,0,0,3831,3832,1,0,0,0,3832,3834,1,0,0,0,3833,3831,1,0,0,
  	0,3834,3835,5,96,0,0,3835,3840,3,618,309,0,3836,3837,5,24,0,0,3837,3839,
  	3,618,309,0,3838,3836,1,0,0,0,3839,3842,1,0,0,0,3840,3838,1,0,0,0,3840,
  	3841,1,0,0,0,3841,3843,1,0,0,0,3842,3840,1,0,0,0,3843,3844,5,142,0,0,
  	3844,601,1,0,0,0,3845,3847,3,748,374,0,3846,3848,3,604,302,0,3847,3846,
  	1,0,0,0,3847,3848,1,0,0,0,3848,603,1,0,0,0,3849,3850,5,96,0,0,3850,3855,
  	3,618,309,0,3851,3852,5,24,0,0,3852,3854,3,618,309,0,3853,3851,1,0,0,
  	0,3854,3857,1,0,0,0,3855,3853,1,0,0,0,3855,3856,1,0,0,0,3856,3858,1,0,
  	0,0,3857,3855,1,0,0,0,3858,3859,5,142,0,0,3859,605,1,0,0,0,3860,3861,
  	3,618,309,0,3861,607,1,0,0,0,3862,3863,3,610,305,0,3863,609,1,0,0,0,3864,
  	3865,6,305,-1,0,3865,3876,3,634,317,0,3866,3870,3,652,326,0,3867,3869,
  	3,694,347,0,3868,3867,1,0,0,0,3869,3872,1,0,0,0,3870,3868,1,0,0,0,3870,
  	3871,1,0,0,0,3871,3873,1,0,0,0,3872,3870,1,0,0,0,3873,3874,3,634,317,
  	0,3874,3876,1,0,0,0,3875,3864,1,0,0,0,3875,3866,1,0,0,0,3876,3990,1,0,
  	0,0,3877,3878,10,12,0,0,3878,3882,5,7,0,0,3879,3881,3,694,347,0,3880,
  	3879,1,0,0,0,3881,3884,1,0,0,0,3882,3880,1,0,0,0,3882,3883,1,0,0,0,3883,
  	3885,1,0,0,0,3884,3882,1,0,0,0,3885,3989,3,610,305,13,3886,3887,10,11,
  	0,0,3887,3891,7,17,0,0,3888,3890,3,694,347,0,3889,3888,1,0,0,0,3890,3893,
  	1,0,0,0,3891,3889,1,0,0,0,3891,3892,1,0,0,0,3892,3894,1,0,0,0,3893,3891,
  	1,0,0,0,3894,3989,3,610,305,12,3895,3896,10,10,0,0,3896,3900,7,16,0,0,
  	3897,3899,3,694,347,0,3898,3897,1,0,0,0,3899,3902,1,0,0,0,3900,3898,1,
  	0,0,0,3900,3901,1,0,0,0,3901,3903,1,0,0,0,3902,3900,1,0,0,0,3903,3989,
  	3,610,305,11,3904,3905,10,9,0,0,3905,3909,7,18,0,0,3906,3908,3,694,347,
  	0,3907,3906,1,0,0,0,3908,3911,1,0,0,0,3909,3907,1,0,0,0,3909,3910,1,0,
  	0,0,3910,3912,1,0,0,0,3911,3909,1,0,0,0,3912,3989,3,610,305,10,3913,3914,
  	10,8,0,0,3914,3918,7,19,0,0,3915,3917,3,694,347,0,3916,3915,1,0,0,0,3917,
  	3920,1,0,0,0,3918,3916,1,0,0,0,3918,3919,1,0,0,0,3919,3921,1,0,0,0,3920,
  	3918,1,0,0,0,3921,3989,3,610,305,9,3922,3923,10,7,0,0,3923,3927,7,20,
  	0,0,3924,3926,3,694,347,0,3925,3924,1,0,0,0,3926,3929,1,0,0,0,3927,3925,
  	1,0,0,0,3927,3928,1,0,0,0,3928,3930,1,0,0,0,3929,3927,1,0,0,0,3930,3989,
  	3,610,305,8,3931,3932,10,6,0,0,3932,3936,5,2,0,0,3933,3935,3,694,347,
  	0,3934,3933,1,0,0,0,3935,3938,1,0,0,0,3936,3934,1,0,0,0,3936,3937,1,0,
  	0,0,3937,3939,1,0,0,0,3938,3936,1,0,0,0,3939,3989,3,610,305,7,3940,3941,
  	10,5,0,0,3941,3945,7,21,0,0,3942,3944,3,694,347,0,3943,3942,1,0,0,0,3944,
  	3947,1,0,0,0,3945,3943,1,0,0,0,3945,3946,1,0,0,0,3946,3948,1,0,0,0,3947,
  	3945,1,0,0,0,3948,3989,3,610,305,6,3949,3950,10,4,0,0,3950,3954,5,178,
  	0,0,3951,3953,3,694,347,0,3952,3951,1,0,0,0,3953,3956,1,0,0,0,3954,3952,
  	1,0,0,0,3954,3955,1,0,0,0,3955,3957,1,0,0,0,3956,3954,1,0,0,0,3957,3989,
  	3,610,305,5,3958,3959,10,3,0,0,3959,3963,5,3,0,0,3960,3962,3,694,347,
  	0,3961,3960,1,0,0,0,3962,3965,1,0,0,0,3963,3961,1,0,0,0,3963,3964,1,0,
  	0,0,3964,3966,1,0,0,0,3965,3963,1,0,0,0,3966,3989,3,610,305,4,3967,3968,
  	10,2,0,0,3968,3972,5,179,0,0,3969,3971,3,694,347,0,3970,3969,1,0,0,0,
  	3971,3974,1,0,0,0,3972,3970,1,0,0,0,3972,3973,1,0,0,0,3973,3975,1,0,0,
  	0,3974,3972,1,0,0,0,3975,3989,3,610,305,3,3976,3977,10,1,0,0,3977,3981,
  	5,132,0,0,3978,3980,3,694,347,0,3979,3978,1,0,0,0,3980,3983,1,0,0,0,3981,
  	3979,1,0,0,0,3981,3982,1,0,0,0,3982,3984,1,0,0,0,3983,3981,1,0,0,0,3984,
  	3985,3,610,305,0,3985,3986,5,22,0,0,3986,3987,3,610,305,1,3987,3989,1,
  	0,0,0,3988,3877,1,0,0,0,3988,3886,1,0,0,0,3988,3895,1,0,0,0,3988,3904,
  	1,0,0,0,3988,3913,1,0,0,0,3988,3922,1,0,0,0,3988,3931,1,0,0,0,3988,3940,
  	1,0,0,0,3988,3949,1,0,0,0,3988,3958,1,0,0,0,3988,3967,1,0,0,0,3988,3976,
  	1,0,0,0,3989,3992,1,0,0,0,3990,3988,1,0,0,0,3990,3991,1,0,0,0,3991,611,
  	1,0,0,0,3992,3990,1,0,0,0,3993,3999,3,610,305,0,3994,3995,5,22,0,0,3995,
  	3996,3,610,305,0,3996,3997,5,22,0,0,3997,3998,3,610,305,0,3998,4000,1,
  	0,0,0,3999,3994,1,0,0,0,3999,4000,1,0,0,0,4000,613,1,0,0,0,4001,4015,
  	3,610,305,0,4002,4003,3,628,314,0,4003,4004,5,22,0,0,4004,4005,3,620,
  	310,0,4005,4015,1,0,0,0,4006,4007,3,608,304,0,4007,4008,5,122,0,0,4008,
  	4009,3,632,316,0,4009,4015,1,0,0,0,4010,4011,3,608,304,0,4011,4012,5,
  	104,0,0,4012,4013,3,632,316,0,4013,4015,1,0,0,0,4014,4001,1,0,0,0,4014,
  	4002,1,0,0,0,4014,4006,1,0,0,0,4014,4010,1,0,0,0,4015,615,1,0,0,0,4016,
  	4017,3,610,305,0,4017,617,1,0,0,0,4018,4019,6,309,-1,0,4019,4030,3,638,
  	319,0,4020,4024,3,652,326,0,4021,4023,3,694,347,0,4022,4021,1,0,0,0,4023,
  	4026,1,0,0,0,4024,4022,1,0,0,0,4024,4025,1,0,0,0,4025,4027,1,0,0,0,4026,
  	4024,1,0,0,0,4027,4028,3,638,319,0,4028,4030,1,0,0,0,4029,4018,1,0,0,
  	0,4029,4020,1,0,0,0,4030,4144,1,0,0,0,4031,4032,10,12,0,0,4032,4036,5,
  	7,0,0,4033,4035,3,694,347,0,4034,4033,1,0,0,0,4035,4038,1,0,0,0,4036,
  	4034,1,0,0,0,4036,4037,1,0,0,0,4037,4039,1,0,0,0,4038,4036,1,0,0,0,4039,
  	4143,3,618,309,13,4040,4041,10,11,0,0,4041,4045,7,17,0,0,4042,4044,3,
  	694,347,0,4043,4042,1,0,0,0,4044,4047,1,0,0,0,4045,4043,1,0,0,0,4045,
  	4046,1,0,0,0,4046,4048,1,0,0,0,4047,4045,1,0,0,0,4048,4143,3,618,309,
  	12,4049,4050,10,10,0,0,4050,4054,7,16,0,0,4051,4053,3,694,347,0,4052,
  	4051,1,0,0,0,4053,4056,1,0,0,0,4054,4052,1,0,0,0,4054,4055,1,0,0,0,4055,
  	4057,1,0,0,0,4056,4054,1,0,0,0,4057,4143,3,618,309,11,4058,4059,10,9,
  	0,0,4059,4063,7,18,0,0,4060,4062,3,694,347,0,4061,4060,1,0,0,0,4062,4065,
  	1,0,0,0,4063,4061,1,0,0,0,4063,4064,1,0,0,0,4064,4066,1,0,0,0,4065,4063,
  	1,0,0,0,4066,4143,3,618,309,10,4067,4068,10,8,0,0,4068,4072,7,19,0,0,
  	4069,4071,3,694,347,0,4070,4069,1,0,0,0,4071,4074,1,0,0,0,4072,4070,1,
  	0,0,0,4072,4073,1,0,0,0,4073,4075,1,0,0,0,4074,4072,1,0,0,0,4075,4143,
  	3,618,309,9,4076,4077,10,7,0,0,4077,4081,7,20,0,0,4078,4080,3,694,347,
  	0,4079,4078,1,0,0,0,4080,4083,1,0,0,0,4081,4079,1,0,0,0,4081,4082,1,0,
  	0,0,4082,4084,1,0,0,0,4083,4081,1,0,0,0,4084,4143,3,618,309,8,4085,4086,
  	10,6,0,0,4086,4090,5,2,0,0,4087,4089,3,694,347,0,4088,4087,1,0,0,0,4089,
  	4092,1,0,0,0,4090,4088,1,0,0,0,4090,4091,1,0,0,0,4091,4093,1,0,0,0,4092,
  	4090,1,0,0,0,4093,4143,3,618,309,7,4094,4095,10,5,0,0,4095,4099,7,21,
  	0,0,4096,4098,3,694,347,0,4097,4096,1,0,0,0,4098,4101,1,0,0,0,4099,4097,
  	1,0,0,0,4099,4100,1,0,0,0,4100,4102,1,0,0,0,4101,4099,1,0,0,0,4102,4143,
  	3,618,309,6,4103,4104,10,4,0,0,4104,4108,5,178,0,0,4105,4107,3,694,347,
  	0,4106,4105,1,0,0,0,4107,4110,1,0,0,0,4108,4106,1,0,0,0,4108,4109,1,0,
  	0,0,4109,4111,1,0,0,0,4110,4108,1,0,0,0,4111,4143,3,618,309,5,4112,4113,
  	10,3,0,0,4113,4117,5,3,0,0,4114,4116,3,694,347,0,4115,4114,1,0,0,0,4116,
  	4119,1,0,0,0,4117,4115,1,0,0,0,4117,4118,1,0,0,0,4118,4120,1,0,0,0,4119,
  	4117,1,0,0,0,4120,4143,3,618,309,4,4121,4122,10,2,0,0,4122,4126,5,179,
  	0,0,4123,4125,3,694,347,0,4124,4123,1,0,0,0,4125,4128,1,0,0,0,4126,4124,
  	1,0,0,0,4126,4127,1,0,0,0,4127,4129,1,0,0,0,4128,4126,1,0,0,0,4129,4143,
  	3,618,309,3,4130,4131,10,1,0,0,4131,4135,5,132,0,0,4132,4134,3,694,347,
  	0,4133,4132,1,0,0,0,4134,4137,1,0,0,0,4135,4133,1,0,0,0,4135,4136,1,0,
  	0,0,4136,4138,1,0,0,0,4137,4135,1,0,0,0,4138,4139,3,618,309,0,4139,4140,
  	5,22,0,0,4140,4141,3,618,309,1,4141,4143,1,0,0,0,4142,4031,1,0,0,0,4142,
  	4040,1,0,0,0,4142,4049,1,0,0,0,4142,4058,1,0,0,0,4142,4067,1,0,0,0,4142,
  	4076,1,0,0,0,4142,4085,1,0,0,0,4142,4094,1,0,0,0,4142,4103,1,0,0,0,4142,
  	4112,1,0,0,0,4142,4121,1,0,0,0,4142,4130,1,0,0,0,4143,4146,1,0,0,0,4144,
  	4142,1,0,0,0,4144,4145,1,0,0,0,4145,619,1,0,0,0,4146,4144,1,0,0,0,4147,
  	4148,3,610,305,0,4148,621,1,0,0,0,4149,4155,3,618,309,0,4150,4151,5,22,
  	0,0,4151,4152,3,618,309,0,4152,4153,5,22,0,0,4153,4154,3,618,309,0,4154,
  	4156,1,0,0,0,4155,4150,1,0,0,0,4155,4156,1,0,0,0,4156,623,1,0,0,0,4157,
  	4158,6,312,-1,0,4158,4169,3,636,318,0,4159,4163,3,654,327,0,4160,4162,
  	3,694,347,0,4161,4160,1,0,0,0,4162,4165,1,0,0,0,4163,4161,1,0,0,0,4163,
  	4164,1,0,0,0,4164,4166,1,0,0,0,4165,4163,1,0,0,0,4166,4167,3,636,318,
  	0,4167,4169,1,0,0,0,4168,4157,1,0,0,0,4168,4159,1,0,0,0,4169,4238,1,0,
  	0,0,4170,4171,10,7,0,0,4171,4175,7,22,0,0,4172,4174,3,694,347,0,4173,
  	4172,1,0,0,0,4174,4177,1,0,0,0,4175,4173,1,0,0,0,4175,4176,1,0,0,0,4176,
  	4178,1,0,0,0,4177,4175,1,0,0,0,4178,4237,3,624,312,8,4179,4180,10,6,0,
  	0,4180,4184,5,2,0,0,4181,4183,3,694,347,0,4182,4181,1,0,0,0,4183,4186,
  	1,0,0,0,4184,4182,1,0,0,0,4184,4185,1,0,0,0,4185,4187,1,0,0,0,4186,4184,
  	1,0,0,0,4187,4237,3,624,312,7,4188,4189,10,5,0,0,4189,4193,7,21,0,0,4190,
  	4192,3,694,347,0,4191,4190,1,0,0,0,4192,4195,1,0,0,0,4193,4191,1,0,0,
  	0,4193,4194,1,0,0,0,4194,4196,1,0,0,0,4195,4193,1,0,0,0,4196,4237,3,624,
  	312,6,4197,4198,10,4,0,0,4198,4202,5,178,0,0,4199,4201,3,694,347,0,4200,
  	4199,1,0,0,0,4201,4204,1,0,0,0,4202,4200,1,0,0,0,4202,4203,1,0,0,0,4203,
  	4205,1,0,0,0,4204,4202,1,0,0,0,4205,4237,3,624,312,5,4206,4207,10,3,0,
  	0,4207,4211,5,3,0,0,4208,4210,3,694,347,0,4209,4208,1,0,0,0,4210,4213,
  	1,0,0,0,4211,4209,1,0,0,0,4211,4212,1,0,0,0,4212,4214,1,0,0,0,4213,4211,
  	1,0,0,0,4214,4237,3,624,312,4,4215,4216,10,2,0,0,4216,4220,5,179,0,0,
  	4217,4219,3,694,347,0,4218,4217,1,0,0,0,4219,4222,1,0,0,0,4220,4218,1,
  	0,0,0,4220,4221,1,0,0,0,4221,4223,1,0,0,0,4222,4220,1,0,0,0,4223,4237,
  	3,624,312,3,4224,4225,10,1,0,0,4225,4229,5,132,0,0,4226,4228,3,694,347,
  	0,4227,4226,1,0,0,0,4228,4231,1,0,0,0,4229,4227,1,0,0,0,4229,4230,1,0,
  	0,0,4230,4232,1,0,0,0,4231,4229,1,0,0,0,4232,4233,3,624,312,0,4233,4234,
  	5,22,0,0,4234,4235,3,624,312,1,4235,4237,1,0,0,0,4236,4170,1,0,0,0,4236,
  	4179,1,0,0,0,4236,4188,1,0,0,0,4236,4197,1,0,0,0,4236,4206,1,0,0,0,4236,
  	4215,1,0,0,0,4236,4224,1,0,0,0,4237,4240,1,0,0,0,4238,4236,1,0,0,0,4238,
  	4239,1,0,0,0,4239,625,1,0,0,0,4240,4238,1,0,0,0,4241,4247,3,624,312,0,
  	4242,4243,5,22,0,0,4243,4244,3,624,312,0,4244,4245,5,22,0,0,4245,4246,
  	3,624,312,0,4246,4248,1,0,0,0,4247,4242,1,0,0,0,4247,4248,1,0,0,0,4248,
  	627,1,0,0,0,4249,4250,3,610,305,0,4250,629,1,0,0,0,4251,4265,3,618,309,
  	0,4252,4253,3,628,314,0,4253,4254,5,22,0,0,4254,4255,3,620,310,0,4255,
  	4265,1,0,0,0,4256,4257,3,606,303,0,4257,4258,5,122,0,0,4258,4259,3,632,
  	316,0,4259,4265,1,0,0,0,4260,4261,3,606,303,0,4261,4262,5,104,0,0,4262,
  	4263,3,632,316,0,4263,4265,1,0,0,0,4264,4251,1,0,0,0,4264,4252,1,0,0,
  	0,4264,4256,1,0,0,0,4264,4260,1,0,0,0,4265,631,1,0,0,0,4266,4267,3,610,
  	305,0,4267,633,1,0,0,0,4268,4286,3,656,328,0,4269,4274,3,722,361,0,4270,
  	4271,5,91,0,0,4271,4272,3,614,307,0,4272,4273,5,133,0,0,4273,4275,1,0,
  	0,0,4274,4270,1,0,0,0,4274,4275,1,0,0,0,4275,4286,1,0,0,0,4276,4286,3,
  	586,293,0,4277,4286,3,588,294,0,4278,4286,3,596,298,0,4279,4286,3,598,
  	299,0,4280,4281,5,96,0,0,4281,4282,3,612,306,0,4282,4283,5,142,0,0,4283,
  	4286,1,0,0,0,4284,4286,3,692,346,0,4285,4268,1,0,0,0,4285,4269,1,0,0,
  	0,4285,4276,1,0,0,0,4285,4277,1,0,0,0,4285,4278,1,0,0,0,4285,4279,1,0,
  	0,0,4285,4280,1,0,0,0,4285,4284,1,0,0,0,4286,635,1,0,0,0,4287,4298,3,
  	656,328,0,4288,4298,3,722,361,0,4289,4298,3,590,295,0,4290,4298,3,592,
  	296,0,4291,4298,3,600,300,0,4292,4298,3,602,301,0,4293,4294,5,96,0,0,
  	4294,4295,3,626,313,0,4295,4296,5,142,0,0,4296,4298,1,0,0,0,4297,4287,
  	1,0,0,0,4297,4288,1,0,0,0,4297,4289,1,0,0,0,4297,4290,1,0,0,0,4297,4291,
  	1,0,0,0,4297,4292,1,0,0,0,4297,4293,1,0,0,0,4298,637,1,0,0,0,4299,4314,
  	3,656,328,0,4300,4302,3,718,359,0,4301,4303,3,640,320,0,4302,4301,1,0,
  	0,0,4302,4303,1,0,0,0,4303,4314,1,0,0,0,4304,4314,3,584,292,0,4305,4314,
  	3,594,297,0,4306,4314,3,600,300,0,4307,4314,3,602,301,0,4308,4309,5,96,
  	0,0,4309,4310,3,622,311,0,4310,4311,5,142,0,0,4311,4314,1,0,0,0,4312,
  	4314,3,692,346,0,4313,4299,1,0,0,0,4313,4300,1,0,0,0,4313,4304,1,0,0,
  	0,4313,4305,1,0,0,0,4313,4306,1,0,0,0,4313,4307,1,0,0,0,4313,4308,1,0,
  	0,0,4313,4312,1,0,0,0,4314,639,1,0,0,0,4315,4317,3,642,321,0,4316,4315,
  	1,0,0,0,4316,4317,1,0,0,0,4317,4318,1,0,0,0,4318,4319,5,91,0,0,4319,4320,
  	3,630,315,0,4320,4321,5,133,0,0,4321,641,1,0,0,0,4322,4323,5,91,0,0,4323,
  	4324,3,618,309,0,4324,4325,5,133,0,0,4325,4327,1,0,0,0,4326,4322,1,0,
  	0,0,4327,4328,1,0,0,0,4328,4326,1,0,0,0,4328,4329,1,0,0,0,4329,643,1,
  	0,0,0,4330,4332,3,718,359,0,4331,4333,3,646,323,0,4332,4331,1,0,0,0,4332,
  	4333,1,0,0,0,4333,4346,1,0,0,0,4334,4335,5,92,0,0,4335,4340,3,644,322,
  	0,4336,4337,5,24,0,0,4337,4339,3,644,322,0,4338,4336,1,0,0,0,4339,4342,
  	1,0,0,0,4340,4338,1,0,0,0,4340,4341,1,0,0,0,4341,4343,1,0,0,0,4342,4340,
  	1,0,0,0,4343,4344,5,134,0,0,4344,4346,1,0,0,0,4345,4330,1,0,0,0,4345,
  	4334,1,0,0,0,4346,645,1,0,0,0,4347,4349,3,648,324,0,4348,4347,1,0,0,0,
  	4348,4349,1,0,0,0,4349,4350,1,0,0,0,4350,4351,5,91,0,0,4351,4352,3,614,
  	307,0,4352,4353,5,133,0,0,4353,647,1,0,0,0,4354,4355,5,91,0,0,4355,4356,
  	3,610,305,0,4356,4357,5,133,0,0,4357,4359,1,0,0,0,4358,4354,1,0,0,0,4359,
  	4360,1,0,0,0,4360,4358,1,0,0,0,4360,4361,1,0,0,0,4361,649,1,0,0,0,4362,
  	4364,3,718,359,0,4363,4365,3,640,320,0,4364,4363,1,0,0,0,4364,4365,1,
  	0,0,0,4365,4378,1,0,0,0,4366,4367,5,92,0,0,4367,4372,3,650,325,0,4368,
  	4369,5,24,0,0,4369,4371,3,650,325,0,4370,4368,1,0,0,0,4371,4374,1,0,0,
  	0,4372,4370,1,0,0,0,4372,4373,1,0,0,0,4373,4375,1,0,0,0,4374,4372,1,0,
  	0,0,4375,4376,5,134,0,0,4376,4378,1,0,0,0,4377,4362,1,0,0,0,4377,4366,
  	1,0,0,0,4378,651,1,0,0,0,4379,4380,7,23,0,0,4380,653,1,0,0,0,4381,4382,
  	7,24,0,0,4382,655,1,0,0,0,4383,4389,3,660,330,0,4384,4389,3,664,332,0,
  	4385,4389,3,662,331,0,4386,4389,3,666,333,0,4387,4389,3,658,329,0,4388,
  	4383,1,0,0,0,4388,4384,1,0,0,0,4388,4385,1,0,0,0,4388,4386,1,0,0,0,4388,
  	4387,1,0,0,0,4389,657,1,0,0,0,4390,4393,3,670,335,0,4391,4393,3,672,336,
  	0,4392,4390,1,0,0,0,4392,4391,1,0,0,0,4393,659,1,0,0,0,4394,4402,3,674,
  	337,0,4395,4397,3,668,334,0,4396,4395,1,0,0,0,4396,4397,1,0,0,0,4397,
  	4398,1,0,0,0,4398,4399,3,684,342,0,4399,4400,3,676,338,0,4400,4402,1,
  	0,0,0,4401,4394,1,0,0,0,4401,4396,1,0,0,0,4402,661,1,0,0,0,4403,4405,
  	3,668,334,0,4404,4403,1,0,0,0,4404,4405,1,0,0,0,4405,4406,1,0,0,0,4406,
  	4407,3,686,343,0,4407,4408,3,678,339,0,4408,663,1,0,0,0,4409,4411,3,668,
  	334,0,4410,4409,1,0,0,0,4410,4411,1,0,0,0,4411,4412,1,0,0,0,4412,4413,
  	3,688,344,0,4413,4414,3,680,340,0,4414,665,1,0,0,0,4415,4417,3,668,334,
  	0,4416,4415,1,0,0,0,4416,4417,1,0,0,0,4417,4418,1,0,0,0,4418,4419,3,690,
  	345,0,4419,4420,3,682,341,0,4420,667,1,0,0,0,4421,4422,5,200,0,0,4422,
  	669,1,0,0,0,4423,4424,5,194,0,0,4424,671,1,0,0,0,4425,4426,5,193,0,0,
  	4426,673,1,0,0,0,4427,4428,5,200,0,0,4428,675,1,0,0,0,4429,4430,7,25,
  	0,0,4430,677,1,0,0,0,4431,4432,5,202,0,0,4432,679,1,0,0,0,4433,4434,5,
  	207,0,0,4434,681,1,0,0,0,4435,4436,5,205,0,0,4436,683,1,0,0,0,4437,4438,
  	5,191,0,0,4438,685,1,0,0,0,4439,4440,5,189,0,0,4440,687,1,0,0,0,4441,
  	4442,5,196,0,0,4442,689,1,0,0,0,4443,4444,5,195,0,0,4444,691,1,0,0,0,
  	4445,4446,5,198,0,0,4446,693,1,0,0,0,4447,4448,5,96,0,0,4448,4449,5,6,
  	0,0,4449,4454,3,696,348,0,4450,4451,5,24,0,0,4451,4453,3,696,348,0,4452,
  	4450,1,0,0,0,4453,4456,1,0,0,0,4454,4452,1,0,0,0,4454,4455,1,0,0,0,4455,
  	4457,1,0,0,0,4456,4454,1,0,0,0,4457,4458,5,6,0,0,4458,4459,5,142,0,0,
  	4459,695,1,0,0,0,4460,4463,3,698,349,0,4461,4462,5,61,0,0,4462,4464,3,
  	610,305,0,4463,4461,1,0,0,0,4463,4464,1,0,0,0,4464,697,1,0,0,0,4465,4466,
  	3,722,361,0,4466,699,1,0,0,0,4467,4468,3,722,361,0,4468,701,1,0,0,0,4469,
  	4470,3,722,361,0,4470,703,1,0,0,0,4471,4472,3,722,361,0,4472,705,1,0,
  	0,0,4473,4474,5,192,0,0,4474,707,1,0,0,0,4475,4476,3,722,361,0,4476,709,
  	1,0,0,0,4477,4478,3,722,361,0,4478,711,1,0,0,0,4479,4480,3,722,361,0,
  	4480,713,1,0,0,0,4481,4482,3,722,361,0,4482,715,1,0,0,0,4483,4484,3,722,
  	361,0,4484,717,1,0,0,0,4485,4487,3,720,360,0,4486,4485,1,0,0,0,4487,4490,
  	1,0,0,0,4488,4486,1,0,0,0,4488,4489,1,0,0,0,4489,4491,1,0,0,0,4490,4488,
  	1,0,0,0,4491,4492,3,722,361,0,4492,719,1,0,0,0,4493,4495,3,722,361,0,
  	4494,4496,3,648,324,0,4495,4494,1,0,0,0,4495,4496,1,0,0,0,4496,4497,1,
  	0,0,0,4497,4498,5,45,0,0,4498,721,1,0,0,0,4499,4502,3,706,353,0,4500,
  	4502,3,744,372,0,4501,4499,1,0,0,0,4501,4500,1,0,0,0,4502,723,1,0,0,0,
  	4503,4504,3,722,361,0,4504,725,1,0,0,0,4505,4506,3,722,361,0,4506,727,
  	1,0,0,0,4507,4508,3,722,361,0,4508,729,1,0,0,0,4509,4510,3,722,361,0,
  	4510,731,1,0,0,0,4511,4512,3,722,361,0,4512,733,1,0,0,0,4513,4514,3,722,
  	361,0,4514,735,1,0,0,0,4515,4516,3,722,361,0,4516,737,1,0,0,0,4517,4518,
  	3,722,361,0,4518,739,1,0,0,0,4519,4520,3,722,361,0,4520,741,1,0,0,0,4521,
  	4522,3,722,361,0,4522,743,1,0,0,0,4523,4524,5,197,0,0,4524,745,1,0,0,
  	0,4525,4526,3,722,361,0,4526,747,1,0,0,0,4527,4528,5,199,0,0,4528,749,
  	1,0,0,0,4529,4530,5,199,0,0,4530,751,1,0,0,0,4531,4532,3,722,361,0,4532,
  	753,1,0,0,0,4533,4534,3,722,361,0,4534,755,1,0,0,0,4535,4536,3,722,361,
  	0,4536,757,1,0,0,0,4537,4538,3,722,361,0,4538,759,1,0,0,0,4539,4540,3,
  	722,361,0,4540,761,1,0,0,0,4541,4542,3,722,361,0,4542,763,1,0,0,0,470,
  	767,775,784,788,798,810,818,823,829,832,838,852,863,874,888,891,894,902,
  	913,918,925,930,937,944,948,959,968,972,977,984,993,1000,1007,1014,1021,
  	1028,1035,1042,1049,1053,1065,1078,1087,1095,1119,1131,1138,1146,1153,
  	1158,1162,1165,1172,1176,1179,1186,1190,1199,1202,1205,1211,1214,1217,
  	1223,1226,1229,1235,1238,1245,1257,1260,1267,1270,1273,1280,1283,1287,
  	1294,1297,1300,1304,1311,1314,1317,1324,1327,1330,1337,1340,1343,1347,
  	1354,1357,1360,1364,1369,1381,1384,1401,1408,1414,1421,1459,1474,1485,
  	1487,1491,1500,1504,1509,1516,1524,1531,1539,1547,1554,1562,1570,1578,
  	1586,1594,1602,1608,1627,1635,1648,1652,1674,1677,1684,1691,1694,1704,
  	1710,1716,1722,1729,1735,1743,1749,1753,1760,1768,1773,1780,1786,1792,
  	1801,1810,1816,1823,1829,1836,1843,1847,1851,1854,1857,1864,1868,1871,
  	1874,1881,1885,1888,1891,1898,1905,1910,1913,1921,1931,1941,1951,1961,
  	1968,1977,1983,1990,1998,2005,2012,2017,2024,2031,2034,2041,2048,2055,
  	2062,2065,2072,2079,2082,2089,2096,2103,2114,2121,2128,2135,2142,2147,
  	2150,2163,2174,2185,2195,2201,2209,2217,2226,2237,2245,2263,2281,2311,
  	2318,2333,2341,2344,2352,2363,2370,2378,2381,2386,2390,2395,2402,2410,
  	2424,2449,2458,2467,2476,2484,2487,2492,2497,2501,2508,2513,2525,2533,
  	2545,2554,2564,2576,2581,2589,2597,2599,2604,2613,2621,2627,2637,2643,
  	2655,2666,2671,2676,2683,2692,2698,2708,2711,2718,2724,2734,2741,2745,
  	2748,2758,2774,2781,2793,2804,2807,2812,2825,2828,2833,2841,2850,2857,
  	2864,2871,2878,2885,2894,2901,2910,2917,2924,2931,2938,2942,2948,2952,
  	2963,2973,2992,2997,3007,3015,3017,3022,3040,3049,3060,3071,3075,3082,
  	3090,3093,3119,3123,3133,3139,3143,3153,3162,3172,3182,3192,3203,3213,
  	3218,3227,3238,3246,3254,3261,3272,3280,3306,3308,3352,3356,3363,3372,
  	3379,3404,3420,3430,3437,3447,3462,3469,3472,3476,3479,3483,3486,3490,
  	3493,3497,3507,3520,3535,3548,3561,3568,3571,3575,3578,3582,3594,3605,
  	3616,3625,3637,3653,3660,3681,3686,3692,3697,3701,3710,3722,3743,3747,
  	3755,3766,3782,3801,3810,3822,3831,3840,3847,3855,3870,3875,3882,3891,
  	3900,3909,3918,3927,3936,3945,3954,3963,3972,3981,3988,3990,3999,4014,
  	4024,4029,4036,4045,4054,4063,4072,4081,4090,4099,4108,4117,4126,4135,
  	4142,4144,4155,4163,4168,4175,4184,4193,4202,4211,4220,4229,4236,4238,
  	4247,4264,4274,4285,4297,4302,4313,4316,4328,4332,4340,4345,4348,4360,
  	4364,4372,4377,4388,4392,4396,4401,4404,4410,4416,4454,4463,4488,4495,
  	4501
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  verilogparserParserStaticData = staticData.release();
}

}

VerilogParser::VerilogParser(TokenStream *input) : VerilogParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

VerilogParser::VerilogParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  VerilogParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *verilogparserParserStaticData->atn, verilogparserParserStaticData->decisionToDFA, verilogparserParserStaticData->sharedContextCache, options);
}

VerilogParser::~VerilogParser() {
  delete _interpreter;
}

const atn::ATN& VerilogParser::getATN() const {
  return *verilogparserParserStaticData->atn;
}

std::string VerilogParser::getGrammarFileName() const {
  return "VerilogParser.g4";
}

const std::vector<std::string>& VerilogParser::getRuleNames() const {
  return verilogparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& VerilogParser::getVocabulary() const {
  return verilogparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView VerilogParser::getSerializedATN() const {
  return verilogparserParserStaticData->serializedATN;
}


//----------------- Library_textContext ------------------------------------------------------------------

VerilogParser::Library_textContext::Library_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Library_textContext::EOF() {
  return getToken(VerilogParser::EOF, 0);
}

std::vector<VerilogParser::Library_descriptionContext *> VerilogParser::Library_textContext::library_description() {
  return getRuleContexts<VerilogParser::Library_descriptionContext>();
}

VerilogParser::Library_descriptionContext* VerilogParser::Library_textContext::library_description(size_t i) {
  return getRuleContext<VerilogParser::Library_descriptionContext>(i);
}


size_t VerilogParser::Library_textContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_text;
}


std::any VerilogParser::Library_textContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_text(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_textContext* VerilogParser::library_text() {
  Library_textContext *_localctx = _tracker.createInstance<Library_textContext>(_ctx, getState());
  enterRule(_localctx, 0, VerilogParser::RuleLibrary_text);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(767);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CONFIG || _la == VerilogParser::INCLUDE

    || _la == VerilogParser::LIBRARY) {
      setState(764);
      library_description();
      setState(769);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(770);
    match(VerilogParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_descriptionContext ------------------------------------------------------------------

VerilogParser::Library_descriptionContext::Library_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Library_declarationContext* VerilogParser::Library_descriptionContext::library_declaration() {
  return getRuleContext<VerilogParser::Library_declarationContext>(0);
}

VerilogParser::Include_statementContext* VerilogParser::Library_descriptionContext::include_statement() {
  return getRuleContext<VerilogParser::Include_statementContext>(0);
}

VerilogParser::Config_declarationContext* VerilogParser::Library_descriptionContext::config_declaration() {
  return getRuleContext<VerilogParser::Config_declarationContext>(0);
}


size_t VerilogParser::Library_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_description;
}


std::any VerilogParser::Library_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_descriptionContext* VerilogParser::library_description() {
  Library_descriptionContext *_localctx = _tracker.createInstance<Library_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 2, VerilogParser::RuleLibrary_description);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(775);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LIBRARY: {
        enterOuterAlt(_localctx, 1);
        setState(772);
        library_declaration();
        break;
      }

      case VerilogParser::INCLUDE: {
        enterOuterAlt(_localctx, 2);
        setState(773);
        include_statement();
        break;
      }

      case VerilogParser::CONFIG: {
        enterOuterAlt(_localctx, 3);
        setState(774);
        config_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_declarationContext ------------------------------------------------------------------

VerilogParser::Library_declarationContext::Library_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Library_declarationContext::LIBRARY() {
  return getToken(VerilogParser::LIBRARY, 0);
}

VerilogParser::Library_identifierContext* VerilogParser::Library_declarationContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

std::vector<VerilogParser::File_path_specContext *> VerilogParser::Library_declarationContext::file_path_spec() {
  return getRuleContexts<VerilogParser::File_path_specContext>();
}

VerilogParser::File_path_specContext* VerilogParser::Library_declarationContext::file_path_spec(size_t i) {
  return getRuleContext<VerilogParser::File_path_specContext>(i);
}

tree::TerminalNode* VerilogParser::Library_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Library_declarationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Library_declarationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Library_incdirContext* VerilogParser::Library_declarationContext::library_incdir() {
  return getRuleContext<VerilogParser::Library_incdirContext>(0);
}


size_t VerilogParser::Library_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_declaration;
}


std::any VerilogParser::Library_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_declarationContext* VerilogParser::library_declaration() {
  Library_declarationContext *_localctx = _tracker.createInstance<Library_declarationContext>(_ctx, getState());
  enterRule(_localctx, 4, VerilogParser::RuleLibrary_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(777);
    match(VerilogParser::LIBRARY);
    setState(778);
    library_identifier();
    setState(779);
    file_path_spec();
    setState(784);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(780);
      match(VerilogParser::CO);
      setState(781);
      file_path_spec();
      setState(786);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(788);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MIINCDIR) {
      setState(787);
      library_incdir();
    }
    setState(790);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_incdirContext ------------------------------------------------------------------

VerilogParser::Library_incdirContext::Library_incdirContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Library_incdirContext::MIINCDIR() {
  return getToken(VerilogParser::MIINCDIR, 0);
}

std::vector<VerilogParser::File_path_specContext *> VerilogParser::Library_incdirContext::file_path_spec() {
  return getRuleContexts<VerilogParser::File_path_specContext>();
}

VerilogParser::File_path_specContext* VerilogParser::Library_incdirContext::file_path_spec(size_t i) {
  return getRuleContext<VerilogParser::File_path_specContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Library_incdirContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Library_incdirContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Library_incdirContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_incdir;
}


std::any VerilogParser::Library_incdirContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_incdir(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_incdirContext* VerilogParser::library_incdir() {
  Library_incdirContext *_localctx = _tracker.createInstance<Library_incdirContext>(_ctx, getState());
  enterRule(_localctx, 6, VerilogParser::RuleLibrary_incdir);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(792);
    match(VerilogParser::MIINCDIR);
    setState(793);
    file_path_spec();
    setState(798);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(794);
      match(VerilogParser::CO);
      setState(795);
      file_path_spec();
      setState(800);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Include_statementContext ------------------------------------------------------------------

VerilogParser::Include_statementContext::Include_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Include_statementContext::INCLUDE() {
  return getToken(VerilogParser::INCLUDE, 0);
}

VerilogParser::File_path_specContext* VerilogParser::Include_statementContext::file_path_spec() {
  return getRuleContext<VerilogParser::File_path_specContext>(0);
}

tree::TerminalNode* VerilogParser::Include_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Include_statementContext::getRuleIndex() const {
  return VerilogParser::RuleInclude_statement;
}


std::any VerilogParser::Include_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInclude_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Include_statementContext* VerilogParser::include_statement() {
  Include_statementContext *_localctx = _tracker.createInstance<Include_statementContext>(_ctx, getState());
  enterRule(_localctx, 8, VerilogParser::RuleInclude_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(801);
    match(VerilogParser::INCLUDE);
    setState(802);
    file_path_spec();
    setState(803);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- File_path_specContext ------------------------------------------------------------------

VerilogParser::File_path_specContext::File_path_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::File_path_specContext::FILE_PATH_SPEC() {
  return getToken(VerilogParser::FILE_PATH_SPEC, 0);
}


size_t VerilogParser::File_path_specContext::getRuleIndex() const {
  return VerilogParser::RuleFile_path_spec;
}


std::any VerilogParser::File_path_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFile_path_spec(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::File_path_specContext* VerilogParser::file_path_spec() {
  File_path_specContext *_localctx = _tracker.createInstance<File_path_specContext>(_ctx, getState());
  enterRule(_localctx, 10, VerilogParser::RuleFile_path_spec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(805);
    match(VerilogParser::FILE_PATH_SPEC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Source_textContext ------------------------------------------------------------------

VerilogParser::Source_textContext::Source_textContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Source_textContext::EOF() {
  return getToken(VerilogParser::EOF, 0);
}

std::vector<VerilogParser::DescriptionContext *> VerilogParser::Source_textContext::description() {
  return getRuleContexts<VerilogParser::DescriptionContext>();
}

VerilogParser::DescriptionContext* VerilogParser::Source_textContext::description(size_t i) {
  return getRuleContext<VerilogParser::DescriptionContext>(i);
}


size_t VerilogParser::Source_textContext::getRuleIndex() const {
  return VerilogParser::RuleSource_text;
}


std::any VerilogParser::Source_textContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSource_text(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Source_textContext* VerilogParser::source_text() {
  Source_textContext *_localctx = _tracker.createInstance<Source_textContext>(_ctx, getState());
  enterRule(_localctx, 12, VerilogParser::RuleSource_text);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(810);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CONFIG || (((_la - 96) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 96)) & 536875041) != 0) {
      setState(807);
      description();
      setState(812);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(813);
    match(VerilogParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DescriptionContext ------------------------------------------------------------------

VerilogParser::DescriptionContext::DescriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_declarationContext* VerilogParser::DescriptionContext::module_declaration() {
  return getRuleContext<VerilogParser::Module_declarationContext>(0);
}

VerilogParser::Udp_declarationContext* VerilogParser::DescriptionContext::udp_declaration() {
  return getRuleContext<VerilogParser::Udp_declarationContext>(0);
}

VerilogParser::Config_declarationContext* VerilogParser::DescriptionContext::config_declaration() {
  return getRuleContext<VerilogParser::Config_declarationContext>(0);
}


size_t VerilogParser::DescriptionContext::getRuleIndex() const {
  return VerilogParser::RuleDescription;
}


std::any VerilogParser::DescriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDescription(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::DescriptionContext* VerilogParser::description() {
  DescriptionContext *_localctx = _tracker.createInstance<DescriptionContext>(_ctx, getState());
  enterRule(_localctx, 14, VerilogParser::RuleDescription);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(818);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(815);
      module_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(816);
      udp_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(817);
      config_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_declarationContext ------------------------------------------------------------------

VerilogParser::Module_declarationContext::Module_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_keywordContext* VerilogParser::Module_declarationContext::module_keyword() {
  return getRuleContext<VerilogParser::Module_keywordContext>(0);
}

VerilogParser::Module_identifierContext* VerilogParser::Module_declarationContext::module_identifier() {
  return getRuleContext<VerilogParser::Module_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Module_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Module_declarationContext::ENDMODULE() {
  return getToken(VerilogParser::ENDMODULE, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Module_parameter_port_listContext* VerilogParser::Module_declarationContext::module_parameter_port_list() {
  return getRuleContext<VerilogParser::Module_parameter_port_listContext>(0);
}

VerilogParser::List_of_port_declarationsContext* VerilogParser::Module_declarationContext::list_of_port_declarations() {
  return getRuleContext<VerilogParser::List_of_port_declarationsContext>(0);
}

std::vector<VerilogParser::Module_itemContext *> VerilogParser::Module_declarationContext::module_item() {
  return getRuleContexts<VerilogParser::Module_itemContext>();
}

VerilogParser::Module_itemContext* VerilogParser::Module_declarationContext::module_item(size_t i) {
  return getRuleContext<VerilogParser::Module_itemContext>(i);
}


size_t VerilogParser::Module_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_declaration;
}


std::any VerilogParser::Module_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_declarationContext* VerilogParser::module_declaration() {
  Module_declarationContext *_localctx = _tracker.createInstance<Module_declarationContext>(_ctx, getState());
  enterRule(_localctx, 16, VerilogParser::RuleModule_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(823);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(820);
      attribute_instance();
      setState(825);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(826);
    module_keyword();
    setState(827);
    module_identifier();
    setState(829);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(828);
      module_parameter_port_list();
    }
    setState(832);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(831);
      list_of_port_declarations();
    }
    setState(834);
    match(VerilogParser::SC);
    setState(838);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 277013026) != 0 || (((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & -6593604102771899997) != 0 || (((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 4772763370821259087) != 0) {
      setState(835);
      module_item();
      setState(840);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(841);
    match(VerilogParser::ENDMODULE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_keywordContext ------------------------------------------------------------------

VerilogParser::Module_keywordContext::Module_keywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_keywordContext::MODULE() {
  return getToken(VerilogParser::MODULE, 0);
}

tree::TerminalNode* VerilogParser::Module_keywordContext::MACROMODULE() {
  return getToken(VerilogParser::MACROMODULE, 0);
}


size_t VerilogParser::Module_keywordContext::getRuleIndex() const {
  return VerilogParser::RuleModule_keyword;
}


std::any VerilogParser::Module_keywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_keyword(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_keywordContext* VerilogParser::module_keyword() {
  Module_keywordContext *_localctx = _tracker.createInstance<Module_keywordContext>(_ctx, getState());
  enterRule(_localctx, 18, VerilogParser::RuleModule_keyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(843);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::MACROMODULE

    || _la == VerilogParser::MODULE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_parameter_port_listContext ------------------------------------------------------------------

VerilogParser::Module_parameter_port_listContext::Module_parameter_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::HA() {
  return getToken(VerilogParser::HA, 0);
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Parameter_declarationContext *> VerilogParser::Module_parameter_port_listContext::parameter_declaration() {
  return getRuleContexts<VerilogParser::Parameter_declarationContext>();
}

VerilogParser::Parameter_declarationContext* VerilogParser::Module_parameter_port_listContext::parameter_declaration(size_t i) {
  return getRuleContext<VerilogParser::Parameter_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_parameter_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Module_parameter_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Module_parameter_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleModule_parameter_port_list;
}


std::any VerilogParser::Module_parameter_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_parameter_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_parameter_port_listContext* VerilogParser::module_parameter_port_list() {
  Module_parameter_port_listContext *_localctx = _tracker.createInstance<Module_parameter_port_listContext>(_ctx, getState());
  enterRule(_localctx, 20, VerilogParser::RuleModule_parameter_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(845);
    match(VerilogParser::HA);
    setState(846);
    match(VerilogParser::LP);
    setState(847);
    parameter_declaration();
    setState(852);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(848);
      match(VerilogParser::CO);
      setState(849);
      parameter_declaration();
      setState(854);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(855);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_declarationsContext ------------------------------------------------------------------

VerilogParser::List_of_port_declarationsContext::List_of_port_declarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::List_of_port_declarationsContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Port_declarationContext *> VerilogParser::List_of_port_declarationsContext::port_declaration() {
  return getRuleContexts<VerilogParser::Port_declarationContext>();
}

VerilogParser::Port_declarationContext* VerilogParser::List_of_port_declarationsContext::port_declaration(size_t i) {
  return getRuleContext<VerilogParser::Port_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::List_of_port_declarationsContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_port_declarationsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_port_declarationsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::PortContext *> VerilogParser::List_of_port_declarationsContext::port() {
  return getRuleContexts<VerilogParser::PortContext>();
}

VerilogParser::PortContext* VerilogParser::List_of_port_declarationsContext::port(size_t i) {
  return getRuleContext<VerilogParser::PortContext>(i);
}

VerilogParser::Port_implicitContext* VerilogParser::List_of_port_declarationsContext::port_implicit() {
  return getRuleContext<VerilogParser::Port_implicitContext>(0);
}

VerilogParser::Port_explicitContext* VerilogParser::List_of_port_declarationsContext::port_explicit() {
  return getRuleContext<VerilogParser::Port_explicitContext>(0);
}


size_t VerilogParser::List_of_port_declarationsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_port_declarations;
}


std::any VerilogParser::List_of_port_declarationsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_port_declarations(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_port_declarationsContext* VerilogParser::list_of_port_declarations() {
  List_of_port_declarationsContext *_localctx = _tracker.createInstance<List_of_port_declarationsContext>(_ctx, getState());
  enterRule(_localctx, 22, VerilogParser::RuleList_of_port_declarations);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(888);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(857);
      match(VerilogParser::LP);
      setState(858);
      port_declaration();
      setState(863);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::CO) {
        setState(859);
        match(VerilogParser::CO);
        setState(860);
        port_declaration();
        setState(865);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(866);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(868);
      match(VerilogParser::LP);
      setState(869);
      port();
      setState(872); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(870);
        match(VerilogParser::CO);
        setState(871);
        port();
        setState(874); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == VerilogParser::CO);
      setState(876);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(878);
      match(VerilogParser::LP);
      setState(879);
      port_implicit();
      setState(880);
      match(VerilogParser::RP);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(882);
      match(VerilogParser::LP);
      setState(883);
      port_explicit();
      setState(884);
      match(VerilogParser::RP);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(886);
      match(VerilogParser::LP);
      setState(887);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PortContext ------------------------------------------------------------------

VerilogParser::PortContext::PortContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_implicitContext* VerilogParser::PortContext::port_implicit() {
  return getRuleContext<VerilogParser::Port_implicitContext>(0);
}

VerilogParser::Port_explicitContext* VerilogParser::PortContext::port_explicit() {
  return getRuleContext<VerilogParser::Port_explicitContext>(0);
}


size_t VerilogParser::PortContext::getRuleIndex() const {
  return VerilogParser::RulePort;
}


std::any VerilogParser::PortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::PortContext* VerilogParser::port() {
  PortContext *_localctx = _tracker.createInstance<PortContext>(_ctx, getState());
  enterRule(_localctx, 24, VerilogParser::RulePort);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(894);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CO:
      case VerilogParser::LC:
      case VerilogParser::RP:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(891);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::LC || _la == VerilogParser::ESCAPED_IDENTIFIER

        || _la == VerilogParser::SIMPLE_IDENTIFIER) {
          setState(890);
          port_implicit();
        }
        break;
      }

      case VerilogParser::DT: {
        enterOuterAlt(_localctx, 2);
        setState(893);
        port_explicit();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_implicitContext ------------------------------------------------------------------

VerilogParser::Port_implicitContext::Port_implicitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_expressionContext* VerilogParser::Port_implicitContext::port_expression() {
  return getRuleContext<VerilogParser::Port_expressionContext>(0);
}


size_t VerilogParser::Port_implicitContext::getRuleIndex() const {
  return VerilogParser::RulePort_implicit;
}


std::any VerilogParser::Port_implicitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_implicit(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_implicitContext* VerilogParser::port_implicit() {
  Port_implicitContext *_localctx = _tracker.createInstance<Port_implicitContext>(_ctx, getState());
  enterRule(_localctx, 26, VerilogParser::RulePort_implicit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(896);
    port_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_explicitContext ------------------------------------------------------------------

VerilogParser::Port_explicitContext::Port_explicitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Port_explicitContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Port_identifierContext* VerilogParser::Port_explicitContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Port_explicitContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Port_explicitContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Port_expressionContext* VerilogParser::Port_explicitContext::port_expression() {
  return getRuleContext<VerilogParser::Port_expressionContext>(0);
}


size_t VerilogParser::Port_explicitContext::getRuleIndex() const {
  return VerilogParser::RulePort_explicit;
}


std::any VerilogParser::Port_explicitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_explicit(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_explicitContext* VerilogParser::port_explicit() {
  Port_explicitContext *_localctx = _tracker.createInstance<Port_explicitContext>(_ctx, getState());
  enterRule(_localctx, 28, VerilogParser::RulePort_explicit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(898);
    match(VerilogParser::DT);
    setState(899);
    port_identifier();
    setState(900);
    match(VerilogParser::LP);
    setState(902);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LC || _la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(901);
      port_expression();
    }
    setState(904);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_expressionContext ------------------------------------------------------------------

VerilogParser::Port_expressionContext::Port_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Port_referenceContext *> VerilogParser::Port_expressionContext::port_reference() {
  return getRuleContexts<VerilogParser::Port_referenceContext>();
}

VerilogParser::Port_referenceContext* VerilogParser::Port_expressionContext::port_reference(size_t i) {
  return getRuleContext<VerilogParser::Port_referenceContext>(i);
}

tree::TerminalNode* VerilogParser::Port_expressionContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

tree::TerminalNode* VerilogParser::Port_expressionContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Port_expressionContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Port_expressionContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Port_expressionContext::getRuleIndex() const {
  return VerilogParser::RulePort_expression;
}


std::any VerilogParser::Port_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_expressionContext* VerilogParser::port_expression() {
  Port_expressionContext *_localctx = _tracker.createInstance<Port_expressionContext>(_ctx, getState());
  enterRule(_localctx, 30, VerilogParser::RulePort_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(918);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(906);
        port_reference();
        break;
      }

      case VerilogParser::LC: {
        enterOuterAlt(_localctx, 2);
        setState(907);
        match(VerilogParser::LC);
        setState(908);
        port_reference();
        setState(913);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(909);
          match(VerilogParser::CO);
          setState(910);
          port_reference();
          setState(915);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(916);
        match(VerilogParser::RC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_referenceContext ------------------------------------------------------------------

VerilogParser::Port_referenceContext::Port_referenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Port_referenceContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Port_referenceContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Port_referenceContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Port_referenceContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Port_referenceContext::getRuleIndex() const {
  return VerilogParser::RulePort_reference;
}


std::any VerilogParser::Port_referenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_reference(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_referenceContext* VerilogParser::port_reference() {
  Port_referenceContext *_localctx = _tracker.createInstance<Port_referenceContext>(_ctx, getState());
  enterRule(_localctx, 32, VerilogParser::RulePort_reference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(920);
    port_identifier();
    setState(925);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(921);
      match(VerilogParser::LB);
      setState(922);
      constant_range_expression();
      setState(923);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_declarationContext ------------------------------------------------------------------

VerilogParser::Port_declarationContext::Port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Inout_declarationContext* VerilogParser::Port_declarationContext::inout_declaration() {
  return getRuleContext<VerilogParser::Inout_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Port_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Port_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Input_declarationContext* VerilogParser::Port_declarationContext::input_declaration() {
  return getRuleContext<VerilogParser::Input_declarationContext>(0);
}

VerilogParser::Output_declarationContext* VerilogParser::Port_declarationContext::output_declaration() {
  return getRuleContext<VerilogParser::Output_declarationContext>(0);
}


size_t VerilogParser::Port_declarationContext::getRuleIndex() const {
  return VerilogParser::RulePort_declaration;
}


std::any VerilogParser::Port_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_declarationContext* VerilogParser::port_declaration() {
  Port_declarationContext *_localctx = _tracker.createInstance<Port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 34, VerilogParser::RulePort_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(948);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(930);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(927);
        attribute_instance();
        setState(932);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(933);
      inout_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(937);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(934);
        attribute_instance();
        setState(939);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(940);
      input_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(944);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(941);
        attribute_instance();
        setState(946);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(947);
      output_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_itemContext ------------------------------------------------------------------

VerilogParser::Module_itemContext::Module_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_declarationContext* VerilogParser::Module_itemContext::port_declaration() {
  return getRuleContext<VerilogParser::Port_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Module_itemContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::Module_itemContext::module_or_generate_item() {
  return getRuleContext<VerilogParser::Module_or_generate_itemContext>(0);
}

VerilogParser::Generate_regionContext* VerilogParser::Module_itemContext::generate_region() {
  return getRuleContext<VerilogParser::Generate_regionContext>(0);
}

VerilogParser::Specify_blockContext* VerilogParser::Module_itemContext::specify_block() {
  return getRuleContext<VerilogParser::Specify_blockContext>(0);
}

VerilogParser::Parameter_declarationContext* VerilogParser::Module_itemContext::parameter_declaration() {
  return getRuleContext<VerilogParser::Parameter_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Specparam_declarationContext* VerilogParser::Module_itemContext::specparam_declaration() {
  return getRuleContext<VerilogParser::Specparam_declarationContext>(0);
}


size_t VerilogParser::Module_itemContext::getRuleIndex() const {
  return VerilogParser::RuleModule_item;
}


std::any VerilogParser::Module_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_itemContext* VerilogParser::module_item() {
  Module_itemContext *_localctx = _tracker.createInstance<Module_itemContext>(_ctx, getState());
  enterRule(_localctx, 36, VerilogParser::RuleModule_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(972);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(950);
      port_declaration();
      setState(951);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(953);
      module_or_generate_item();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(954);
      generate_region();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(955);
      specify_block();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(959);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(956);
        attribute_instance();
        setState(961);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(962);
      parameter_declaration();
      setState(963);
      match(VerilogParser::SC);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(968);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(965);
        attribute_instance();
        setState(970);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(971);
      specparam_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_or_generate_itemContext ------------------------------------------------------------------

VerilogParser::Module_or_generate_itemContext::Module_or_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_or_generate_item_declarationContext* VerilogParser::Module_or_generate_itemContext::module_or_generate_item_declaration() {
  return getRuleContext<VerilogParser::Module_or_generate_item_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_or_generate_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_or_generate_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Local_parameter_declarationContext* VerilogParser::Module_or_generate_itemContext::local_parameter_declaration() {
  return getRuleContext<VerilogParser::Local_parameter_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Module_or_generate_itemContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Parameter_overrideContext* VerilogParser::Module_or_generate_itemContext::parameter_override() {
  return getRuleContext<VerilogParser::Parameter_overrideContext>(0);
}

VerilogParser::Continuous_assignContext* VerilogParser::Module_or_generate_itemContext::continuous_assign() {
  return getRuleContext<VerilogParser::Continuous_assignContext>(0);
}

VerilogParser::Gate_instantiationContext* VerilogParser::Module_or_generate_itemContext::gate_instantiation() {
  return getRuleContext<VerilogParser::Gate_instantiationContext>(0);
}

VerilogParser::Module_instantiationContext* VerilogParser::Module_or_generate_itemContext::module_instantiation() {
  return getRuleContext<VerilogParser::Module_instantiationContext>(0);
}

VerilogParser::Udp_instantiationContext* VerilogParser::Module_or_generate_itemContext::udp_instantiation() {
  return getRuleContext<VerilogParser::Udp_instantiationContext>(0);
}

VerilogParser::Initial_constructContext* VerilogParser::Module_or_generate_itemContext::initial_construct() {
  return getRuleContext<VerilogParser::Initial_constructContext>(0);
}

VerilogParser::Always_constructContext* VerilogParser::Module_or_generate_itemContext::always_construct() {
  return getRuleContext<VerilogParser::Always_constructContext>(0);
}

VerilogParser::Loop_generate_constructContext* VerilogParser::Module_or_generate_itemContext::loop_generate_construct() {
  return getRuleContext<VerilogParser::Loop_generate_constructContext>(0);
}

VerilogParser::Conditional_generate_constructContext* VerilogParser::Module_or_generate_itemContext::conditional_generate_construct() {
  return getRuleContext<VerilogParser::Conditional_generate_constructContext>(0);
}


size_t VerilogParser::Module_or_generate_itemContext::getRuleIndex() const {
  return VerilogParser::RuleModule_or_generate_item;
}


std::any VerilogParser::Module_or_generate_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_or_generate_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::module_or_generate_item() {
  Module_or_generate_itemContext *_localctx = _tracker.createInstance<Module_or_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 38, VerilogParser::RuleModule_or_generate_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1053);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(977);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(974);
        attribute_instance();
        setState(979);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(980);
      module_or_generate_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(984);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(981);
        attribute_instance();
        setState(986);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(987);
      local_parameter_declaration();
      setState(988);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(993);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(990);
        attribute_instance();
        setState(995);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(996);
      parameter_override();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1000);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(997);
        attribute_instance();
        setState(1002);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1003);
      continuous_assign();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1007);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1004);
        attribute_instance();
        setState(1009);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1010);
      gate_instantiation();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1014);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1011);
        attribute_instance();
        setState(1016);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1017);
      module_instantiation();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1021);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1018);
        attribute_instance();
        setState(1023);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1024);
      udp_instantiation();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1028);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1025);
        attribute_instance();
        setState(1030);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1031);
      initial_construct();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1035);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1032);
        attribute_instance();
        setState(1037);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1038);
      always_construct();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1042);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1039);
        attribute_instance();
        setState(1044);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1045);
      loop_generate_construct();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1049);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1046);
        attribute_instance();
        setState(1051);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1052);
      conditional_generate_construct();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_or_generate_item_declarationContext ------------------------------------------------------------------

VerilogParser::Module_or_generate_item_declarationContext::Module_or_generate_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::net_declaration() {
  return getRuleContext<VerilogParser::Net_declarationContext>(0);
}

VerilogParser::Reg_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::reg_declaration() {
  return getRuleContext<VerilogParser::Reg_declarationContext>(0);
}

VerilogParser::Integer_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::integer_declaration() {
  return getRuleContext<VerilogParser::Integer_declarationContext>(0);
}

VerilogParser::Real_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::real_declaration() {
  return getRuleContext<VerilogParser::Real_declarationContext>(0);
}

VerilogParser::Time_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::time_declaration() {
  return getRuleContext<VerilogParser::Time_declarationContext>(0);
}

VerilogParser::Realtime_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::realtime_declaration() {
  return getRuleContext<VerilogParser::Realtime_declarationContext>(0);
}

VerilogParser::Event_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::event_declaration() {
  return getRuleContext<VerilogParser::Event_declarationContext>(0);
}

VerilogParser::Genvar_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::genvar_declaration() {
  return getRuleContext<VerilogParser::Genvar_declarationContext>(0);
}

VerilogParser::Task_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::task_declaration() {
  return getRuleContext<VerilogParser::Task_declarationContext>(0);
}

VerilogParser::Function_declarationContext* VerilogParser::Module_or_generate_item_declarationContext::function_declaration() {
  return getRuleContext<VerilogParser::Function_declarationContext>(0);
}


size_t VerilogParser::Module_or_generate_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_or_generate_item_declaration;
}


std::any VerilogParser::Module_or_generate_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_or_generate_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_or_generate_item_declarationContext* VerilogParser::module_or_generate_item_declaration() {
  Module_or_generate_item_declarationContext *_localctx = _tracker.createInstance<Module_or_generate_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 40, VerilogParser::RuleModule_or_generate_item_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1065);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::SUPPLYONE:
      case VerilogParser::SUPPLYZERO:
      case VerilogParser::TRI:
      case VerilogParser::TRIAND:
      case VerilogParser::TRIONE:
      case VerilogParser::TRIOR:
      case VerilogParser::TRIREG:
      case VerilogParser::TRIZERO:
      case VerilogParser::UWIRE:
      case VerilogParser::WAND:
      case VerilogParser::WIRE:
      case VerilogParser::WOR: {
        enterOuterAlt(_localctx, 1);
        setState(1055);
        net_declaration();
        break;
      }

      case VerilogParser::REG: {
        enterOuterAlt(_localctx, 2);
        setState(1056);
        reg_declaration();
        break;
      }

      case VerilogParser::INTEGER: {
        enterOuterAlt(_localctx, 3);
        setState(1057);
        integer_declaration();
        break;
      }

      case VerilogParser::REAL: {
        enterOuterAlt(_localctx, 4);
        setState(1058);
        real_declaration();
        break;
      }

      case VerilogParser::TIME: {
        enterOuterAlt(_localctx, 5);
        setState(1059);
        time_declaration();
        break;
      }

      case VerilogParser::REALTIME: {
        enterOuterAlt(_localctx, 6);
        setState(1060);
        realtime_declaration();
        break;
      }

      case VerilogParser::EVENT: {
        enterOuterAlt(_localctx, 7);
        setState(1061);
        event_declaration();
        break;
      }

      case VerilogParser::GENVAR: {
        enterOuterAlt(_localctx, 8);
        setState(1062);
        genvar_declaration();
        break;
      }

      case VerilogParser::TASK: {
        enterOuterAlt(_localctx, 9);
        setState(1063);
        task_declaration();
        break;
      }

      case VerilogParser::FUNCTION: {
        enterOuterAlt(_localctx, 10);
        setState(1064);
        function_declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_overrideContext ------------------------------------------------------------------

VerilogParser::Parameter_overrideContext::Parameter_overrideContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_overrideContext::DEFPARAM() {
  return getToken(VerilogParser::DEFPARAM, 0);
}

VerilogParser::List_of_defparam_assignmentsContext* VerilogParser::Parameter_overrideContext::list_of_defparam_assignments() {
  return getRuleContext<VerilogParser::List_of_defparam_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Parameter_overrideContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Parameter_overrideContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_override;
}


std::any VerilogParser::Parameter_overrideContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_override(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_overrideContext* VerilogParser::parameter_override() {
  Parameter_overrideContext *_localctx = _tracker.createInstance<Parameter_overrideContext>(_ctx, getState());
  enterRule(_localctx, 42, VerilogParser::RuleParameter_override);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1067);
    match(VerilogParser::DEFPARAM);
    setState(1068);
    list_of_defparam_assignments();
    setState(1069);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_declarationContext ------------------------------------------------------------------

VerilogParser::Config_declarationContext::Config_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Config_declarationContext::CONFIG() {
  return getToken(VerilogParser::CONFIG, 0);
}

VerilogParser::Config_identifierContext* VerilogParser::Config_declarationContext::config_identifier() {
  return getRuleContext<VerilogParser::Config_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Config_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Design_statementContext* VerilogParser::Config_declarationContext::design_statement() {
  return getRuleContext<VerilogParser::Design_statementContext>(0);
}

tree::TerminalNode* VerilogParser::Config_declarationContext::ENDCONFIG() {
  return getToken(VerilogParser::ENDCONFIG, 0);
}

std::vector<VerilogParser::Config_rule_statementContext *> VerilogParser::Config_declarationContext::config_rule_statement() {
  return getRuleContexts<VerilogParser::Config_rule_statementContext>();
}

VerilogParser::Config_rule_statementContext* VerilogParser::Config_declarationContext::config_rule_statement(size_t i) {
  return getRuleContext<VerilogParser::Config_rule_statementContext>(i);
}


size_t VerilogParser::Config_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleConfig_declaration;
}


std::any VerilogParser::Config_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConfig_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Config_declarationContext* VerilogParser::config_declaration() {
  Config_declarationContext *_localctx = _tracker.createInstance<Config_declarationContext>(_ctx, getState());
  enterRule(_localctx, 44, VerilogParser::RuleConfig_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1071);
    match(VerilogParser::CONFIG);
    setState(1072);
    config_identifier();
    setState(1073);
    match(VerilogParser::SC);
    setState(1074);
    design_statement();
    setState(1078);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CELL

    || _la == VerilogParser::DEFAULT || _la == VerilogParser::INSTANCE) {
      setState(1075);
      config_rule_statement();
      setState(1080);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1081);
    match(VerilogParser::ENDCONFIG);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Design_statementContext ------------------------------------------------------------------

VerilogParser::Design_statementContext::Design_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Design_statementContext::DESIGN() {
  return getToken(VerilogParser::DESIGN, 0);
}

tree::TerminalNode* VerilogParser::Design_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Design_statement_itemContext *> VerilogParser::Design_statementContext::design_statement_item() {
  return getRuleContexts<VerilogParser::Design_statement_itemContext>();
}

VerilogParser::Design_statement_itemContext* VerilogParser::Design_statementContext::design_statement_item(size_t i) {
  return getRuleContext<VerilogParser::Design_statement_itemContext>(i);
}


size_t VerilogParser::Design_statementContext::getRuleIndex() const {
  return VerilogParser::RuleDesign_statement;
}


std::any VerilogParser::Design_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDesign_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Design_statementContext* VerilogParser::design_statement() {
  Design_statementContext *_localctx = _tracker.createInstance<Design_statementContext>(_ctx, getState());
  enterRule(_localctx, 46, VerilogParser::RuleDesign_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1083);
    match(VerilogParser::DESIGN);
    setState(1087);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(1084);
      design_statement_item();
      setState(1089);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1090);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Design_statement_itemContext ------------------------------------------------------------------

VerilogParser::Design_statement_itemContext::Design_statement_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Cell_identifierContext* VerilogParser::Design_statement_itemContext::cell_identifier() {
  return getRuleContext<VerilogParser::Cell_identifierContext>(0);
}

VerilogParser::Library_identifierContext* VerilogParser::Design_statement_itemContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Design_statement_itemContext::DT() {
  return getToken(VerilogParser::DT, 0);
}


size_t VerilogParser::Design_statement_itemContext::getRuleIndex() const {
  return VerilogParser::RuleDesign_statement_item;
}


std::any VerilogParser::Design_statement_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDesign_statement_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Design_statement_itemContext* VerilogParser::design_statement_item() {
  Design_statement_itemContext *_localctx = _tracker.createInstance<Design_statement_itemContext>(_ctx, getState());
  enterRule(_localctx, 48, VerilogParser::RuleDesign_statement_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1095);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(1092);
      library_identifier();
      setState(1093);
      match(VerilogParser::DT);
      break;
    }

    default:
      break;
    }
    setState(1097);
    cell_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_rule_statementContext ------------------------------------------------------------------

VerilogParser::Config_rule_statementContext::Config_rule_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Default_clauseContext* VerilogParser::Config_rule_statementContext::default_clause() {
  return getRuleContext<VerilogParser::Default_clauseContext>(0);
}

VerilogParser::Liblist_clauseContext* VerilogParser::Config_rule_statementContext::liblist_clause() {
  return getRuleContext<VerilogParser::Liblist_clauseContext>(0);
}

tree::TerminalNode* VerilogParser::Config_rule_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Inst_clauseContext* VerilogParser::Config_rule_statementContext::inst_clause() {
  return getRuleContext<VerilogParser::Inst_clauseContext>(0);
}

VerilogParser::Use_clauseContext* VerilogParser::Config_rule_statementContext::use_clause() {
  return getRuleContext<VerilogParser::Use_clauseContext>(0);
}

VerilogParser::Cell_clauseContext* VerilogParser::Config_rule_statementContext::cell_clause() {
  return getRuleContext<VerilogParser::Cell_clauseContext>(0);
}


size_t VerilogParser::Config_rule_statementContext::getRuleIndex() const {
  return VerilogParser::RuleConfig_rule_statement;
}


std::any VerilogParser::Config_rule_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConfig_rule_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Config_rule_statementContext* VerilogParser::config_rule_statement() {
  Config_rule_statementContext *_localctx = _tracker.createInstance<Config_rule_statementContext>(_ctx, getState());
  enterRule(_localctx, 50, VerilogParser::RuleConfig_rule_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1119);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1099);
      default_clause();
      setState(1100);
      liblist_clause();
      setState(1101);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1103);
      inst_clause();
      setState(1104);
      liblist_clause();
      setState(1105);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1107);
      inst_clause();
      setState(1108);
      use_clause();
      setState(1109);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1111);
      cell_clause();
      setState(1112);
      liblist_clause();
      setState(1113);
      match(VerilogParser::SC);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1115);
      cell_clause();
      setState(1116);
      use_clause();
      setState(1117);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_clauseContext ------------------------------------------------------------------

VerilogParser::Default_clauseContext::Default_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Default_clauseContext::DEFAULT() {
  return getToken(VerilogParser::DEFAULT, 0);
}


size_t VerilogParser::Default_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleDefault_clause;
}


std::any VerilogParser::Default_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDefault_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Default_clauseContext* VerilogParser::default_clause() {
  Default_clauseContext *_localctx = _tracker.createInstance<Default_clauseContext>(_ctx, getState());
  enterRule(_localctx, 52, VerilogParser::RuleDefault_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1121);
    match(VerilogParser::DEFAULT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inst_clauseContext ------------------------------------------------------------------

VerilogParser::Inst_clauseContext::Inst_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Inst_clauseContext::INSTANCE() {
  return getToken(VerilogParser::INSTANCE, 0);
}

VerilogParser::Inst_nameContext* VerilogParser::Inst_clauseContext::inst_name() {
  return getRuleContext<VerilogParser::Inst_nameContext>(0);
}


size_t VerilogParser::Inst_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleInst_clause;
}


std::any VerilogParser::Inst_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInst_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inst_clauseContext* VerilogParser::inst_clause() {
  Inst_clauseContext *_localctx = _tracker.createInstance<Inst_clauseContext>(_ctx, getState());
  enterRule(_localctx, 54, VerilogParser::RuleInst_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1123);
    match(VerilogParser::INSTANCE);
    setState(1124);
    inst_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inst_nameContext ------------------------------------------------------------------

VerilogParser::Inst_nameContext::Inst_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Topmodule_identifierContext* VerilogParser::Inst_nameContext::topmodule_identifier() {
  return getRuleContext<VerilogParser::Topmodule_identifierContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Inst_nameContext::DT() {
  return getTokens(VerilogParser::DT);
}

tree::TerminalNode* VerilogParser::Inst_nameContext::DT(size_t i) {
  return getToken(VerilogParser::DT, i);
}

std::vector<VerilogParser::Instance_identifierContext *> VerilogParser::Inst_nameContext::instance_identifier() {
  return getRuleContexts<VerilogParser::Instance_identifierContext>();
}

VerilogParser::Instance_identifierContext* VerilogParser::Inst_nameContext::instance_identifier(size_t i) {
  return getRuleContext<VerilogParser::Instance_identifierContext>(i);
}


size_t VerilogParser::Inst_nameContext::getRuleIndex() const {
  return VerilogParser::RuleInst_name;
}


std::any VerilogParser::Inst_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInst_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inst_nameContext* VerilogParser::inst_name() {
  Inst_nameContext *_localctx = _tracker.createInstance<Inst_nameContext>(_ctx, getState());
  enterRule(_localctx, 56, VerilogParser::RuleInst_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1126);
    topmodule_identifier();
    setState(1131);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::DT) {
      setState(1127);
      match(VerilogParser::DT);
      setState(1128);
      instance_identifier();
      setState(1133);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cell_clauseContext ------------------------------------------------------------------

VerilogParser::Cell_clauseContext::Cell_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Cell_clauseContext::CELL() {
  return getToken(VerilogParser::CELL, 0);
}

VerilogParser::Cell_identifierContext* VerilogParser::Cell_clauseContext::cell_identifier() {
  return getRuleContext<VerilogParser::Cell_identifierContext>(0);
}

VerilogParser::Library_identifierContext* VerilogParser::Cell_clauseContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Cell_clauseContext::DT() {
  return getToken(VerilogParser::DT, 0);
}


size_t VerilogParser::Cell_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleCell_clause;
}


std::any VerilogParser::Cell_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCell_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cell_clauseContext* VerilogParser::cell_clause() {
  Cell_clauseContext *_localctx = _tracker.createInstance<Cell_clauseContext>(_ctx, getState());
  enterRule(_localctx, 58, VerilogParser::RuleCell_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1134);
    match(VerilogParser::CELL);
    setState(1138);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
    case 1: {
      setState(1135);
      library_identifier();
      setState(1136);
      match(VerilogParser::DT);
      break;
    }

    default:
      break;
    }
    setState(1140);
    cell_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Liblist_clauseContext ------------------------------------------------------------------

VerilogParser::Liblist_clauseContext::Liblist_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Liblist_clauseContext::LIBLIST() {
  return getToken(VerilogParser::LIBLIST, 0);
}

std::vector<VerilogParser::Library_identifierContext *> VerilogParser::Liblist_clauseContext::library_identifier() {
  return getRuleContexts<VerilogParser::Library_identifierContext>();
}

VerilogParser::Library_identifierContext* VerilogParser::Liblist_clauseContext::library_identifier(size_t i) {
  return getRuleContext<VerilogParser::Library_identifierContext>(i);
}


size_t VerilogParser::Liblist_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleLiblist_clause;
}


std::any VerilogParser::Liblist_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLiblist_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Liblist_clauseContext* VerilogParser::liblist_clause() {
  Liblist_clauseContext *_localctx = _tracker.createInstance<Liblist_clauseContext>(_ctx, getState());
  enterRule(_localctx, 60, VerilogParser::RuleLiblist_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1142);
    match(VerilogParser::LIBLIST);
    setState(1146);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(1143);
      library_identifier();
      setState(1148);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Use_clauseContext ------------------------------------------------------------------

VerilogParser::Use_clauseContext::Use_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Use_clauseContext::USE() {
  return getToken(VerilogParser::USE, 0);
}

VerilogParser::Cell_identifierContext* VerilogParser::Use_clauseContext::cell_identifier() {
  return getRuleContext<VerilogParser::Cell_identifierContext>(0);
}

VerilogParser::Library_identifierContext* VerilogParser::Use_clauseContext::library_identifier() {
  return getRuleContext<VerilogParser::Library_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Use_clauseContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

tree::TerminalNode* VerilogParser::Use_clauseContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

tree::TerminalNode* VerilogParser::Use_clauseContext::CONFIG() {
  return getToken(VerilogParser::CONFIG, 0);
}


size_t VerilogParser::Use_clauseContext::getRuleIndex() const {
  return VerilogParser::RuleUse_clause;
}


std::any VerilogParser::Use_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUse_clause(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Use_clauseContext* VerilogParser::use_clause() {
  Use_clauseContext *_localctx = _tracker.createInstance<Use_clauseContext>(_ctx, getState());
  enterRule(_localctx, 62, VerilogParser::RuleUse_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1149);
    match(VerilogParser::USE);
    setState(1153);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      setState(1150);
      library_identifier();
      setState(1151);
      match(VerilogParser::DT);
      break;
    }

    default:
      break;
    }
    setState(1155);
    cell_identifier();
    setState(1158);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(1156);
      match(VerilogParser::CL);
      setState(1157);
      match(VerilogParser::CONFIG);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Local_parameter_declarationContext ------------------------------------------------------------------

VerilogParser::Local_parameter_declarationContext::Local_parameter_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Local_parameter_declarationContext::LOCALPARAM() {
  return getToken(VerilogParser::LOCALPARAM, 0);
}

VerilogParser::List_of_param_assignmentsContext* VerilogParser::Local_parameter_declarationContext::list_of_param_assignments() {
  return getRuleContext<VerilogParser::List_of_param_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Local_parameter_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Local_parameter_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Parameter_typeContext* VerilogParser::Local_parameter_declarationContext::parameter_type() {
  return getRuleContext<VerilogParser::Parameter_typeContext>(0);
}


size_t VerilogParser::Local_parameter_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleLocal_parameter_declaration;
}


std::any VerilogParser::Local_parameter_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLocal_parameter_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Local_parameter_declarationContext* VerilogParser::local_parameter_declaration() {
  Local_parameter_declarationContext *_localctx = _tracker.createInstance<Local_parameter_declarationContext>(_ctx, getState());
  enterRule(_localctx, 64, VerilogParser::RuleLocal_parameter_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1172);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1160);
      match(VerilogParser::LOCALPARAM);
      setState(1162);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1161);
        match(VerilogParser::SIGNED);
      }
      setState(1165);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1164);
        range_();
      }
      setState(1167);
      list_of_param_assignments();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1168);
      match(VerilogParser::LOCALPARAM);
      setState(1169);
      parameter_type();
      setState(1170);
      list_of_param_assignments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_declarationContext ------------------------------------------------------------------

VerilogParser::Parameter_declarationContext::Parameter_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_declarationContext::PARAMETER() {
  return getToken(VerilogParser::PARAMETER, 0);
}

VerilogParser::List_of_param_assignmentsContext* VerilogParser::Parameter_declarationContext::list_of_param_assignments() {
  return getRuleContext<VerilogParser::List_of_param_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Parameter_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Parameter_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Parameter_typeContext* VerilogParser::Parameter_declarationContext::parameter_type() {
  return getRuleContext<VerilogParser::Parameter_typeContext>(0);
}


size_t VerilogParser::Parameter_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_declaration;
}


std::any VerilogParser::Parameter_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_declarationContext* VerilogParser::parameter_declaration() {
  Parameter_declarationContext *_localctx = _tracker.createInstance<Parameter_declarationContext>(_ctx, getState());
  enterRule(_localctx, 66, VerilogParser::RuleParameter_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1186);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1174);
      match(VerilogParser::PARAMETER);
      setState(1176);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1175);
        match(VerilogParser::SIGNED);
      }
      setState(1179);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1178);
        range_();
      }
      setState(1181);
      list_of_param_assignments();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1182);
      match(VerilogParser::PARAMETER);
      setState(1183);
      parameter_type();
      setState(1184);
      list_of_param_assignments();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_declarationContext ------------------------------------------------------------------

VerilogParser::Specparam_declarationContext::Specparam_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Specparam_declarationContext::SPECPARAM() {
  return getToken(VerilogParser::SPECPARAM, 0);
}

VerilogParser::List_of_specparam_assignmentsContext* VerilogParser::Specparam_declarationContext::list_of_specparam_assignments() {
  return getRuleContext<VerilogParser::List_of_specparam_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Specparam_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Range_Context* VerilogParser::Specparam_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Specparam_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleSpecparam_declaration;
}


std::any VerilogParser::Specparam_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecparam_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specparam_declarationContext* VerilogParser::specparam_declaration() {
  Specparam_declarationContext *_localctx = _tracker.createInstance<Specparam_declarationContext>(_ctx, getState());
  enterRule(_localctx, 68, VerilogParser::RuleSpecparam_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1188);
    match(VerilogParser::SPECPARAM);
    setState(1190);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1189);
      range_();
    }
    setState(1192);
    list_of_specparam_assignments();
    setState(1193);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_typeContext ------------------------------------------------------------------

VerilogParser::Parameter_typeContext::Parameter_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

tree::TerminalNode* VerilogParser::Parameter_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Parameter_typeContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_type;
}


std::any VerilogParser::Parameter_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_typeContext* VerilogParser::parameter_type() {
  Parameter_typeContext *_localctx = _tracker.createInstance<Parameter_typeContext>(_ctx, getState());
  enterRule(_localctx, 70, VerilogParser::RuleParameter_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1195);
    _la = _input->LA(1);
    if (!((((_la - 88) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 88)) & 844424930131969) != 0 || _la == VerilogParser::TIME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inout_declarationContext ------------------------------------------------------------------

VerilogParser::Inout_declarationContext::Inout_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Inout_declarationContext::INOUT() {
  return getToken(VerilogParser::INOUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Inout_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

VerilogParser::Net_typeContext* VerilogParser::Inout_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

tree::TerminalNode* VerilogParser::Inout_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Inout_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Inout_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleInout_declaration;
}


std::any VerilogParser::Inout_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInout_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inout_declarationContext* VerilogParser::inout_declaration() {
  Inout_declarationContext *_localctx = _tracker.createInstance<Inout_declarationContext>(_ctx, getState());
  enterRule(_localctx, 72, VerilogParser::RuleInout_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1197);
    match(VerilogParser::INOUT);
    setState(1199);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 157) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 157)) & 822800387) != 0) {
      setState(1198);
      net_type();
    }
    setState(1202);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::SIGNED) {
      setState(1201);
      match(VerilogParser::SIGNED);
    }
    setState(1205);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1204);
      range_();
    }
    setState(1207);
    list_of_port_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_declarationContext ------------------------------------------------------------------

VerilogParser::Input_declarationContext::Input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Input_declarationContext::INPUT() {
  return getToken(VerilogParser::INPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Input_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

VerilogParser::Net_typeContext* VerilogParser::Input_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

tree::TerminalNode* VerilogParser::Input_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Input_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Input_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleInput_declaration;
}


std::any VerilogParser::Input_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_declarationContext* VerilogParser::input_declaration() {
  Input_declarationContext *_localctx = _tracker.createInstance<Input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 74, VerilogParser::RuleInput_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1209);
    match(VerilogParser::INPUT);
    setState(1211);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la - 157) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 157)) & 822800387) != 0) {
      setState(1210);
      net_type();
    }
    setState(1214);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::SIGNED) {
      setState(1213);
      match(VerilogParser::SIGNED);
    }
    setState(1217);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1216);
      range_();
    }
    setState(1219);
    list_of_port_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_declarationContext ------------------------------------------------------------------

VerilogParser::Output_declarationContext::Output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Output_declarationContext::OUTPUT() {
  return getToken(VerilogParser::OUTPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Output_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

VerilogParser::Net_typeContext* VerilogParser::Output_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

tree::TerminalNode* VerilogParser::Output_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Output_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Output_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::List_of_variable_port_identifiersContext* VerilogParser::Output_declarationContext::list_of_variable_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_port_identifiersContext>(0);
}

VerilogParser::Output_variable_typeContext* VerilogParser::Output_declarationContext::output_variable_type() {
  return getRuleContext<VerilogParser::Output_variable_typeContext>(0);
}


size_t VerilogParser::Output_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_declaration;
}


std::any VerilogParser::Output_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_declarationContext* VerilogParser::output_declaration() {
  Output_declarationContext *_localctx = _tracker.createInstance<Output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 76, VerilogParser::RuleOutput_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1245);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1221);
      match(VerilogParser::OUTPUT);
      setState(1223);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la - 157) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 157)) & 822800387) != 0) {
        setState(1222);
        net_type();
      }
      setState(1226);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1225);
        match(VerilogParser::SIGNED);
      }
      setState(1229);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1228);
        range_();
      }
      setState(1231);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1232);
      match(VerilogParser::OUTPUT);
      setState(1233);
      match(VerilogParser::REG);
      setState(1235);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1234);
        match(VerilogParser::SIGNED);
      }
      setState(1238);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1237);
        range_();
      }
      setState(1240);
      list_of_variable_port_identifiers();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1241);
      match(VerilogParser::OUTPUT);
      setState(1242);
      output_variable_type();
      setState(1243);
      list_of_variable_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_declarationContext ------------------------------------------------------------------

VerilogParser::Event_declarationContext::Event_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_declarationContext::EVENT() {
  return getToken(VerilogParser::EVENT, 0);
}

VerilogParser::List_of_event_identifiersContext* VerilogParser::Event_declarationContext::list_of_event_identifiers() {
  return getRuleContext<VerilogParser::List_of_event_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Event_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Event_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_declaration;
}


std::any VerilogParser::Event_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_declarationContext* VerilogParser::event_declaration() {
  Event_declarationContext *_localctx = _tracker.createInstance<Event_declarationContext>(_ctx, getState());
  enterRule(_localctx, 78, VerilogParser::RuleEvent_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1247);
    match(VerilogParser::EVENT);
    setState(1248);
    list_of_event_identifiers();
    setState(1249);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Integer_declarationContext ------------------------------------------------------------------

VerilogParser::Integer_declarationContext::Integer_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Integer_declarationContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::Integer_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Integer_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Integer_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleInteger_declaration;
}


std::any VerilogParser::Integer_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInteger_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Integer_declarationContext* VerilogParser::integer_declaration() {
  Integer_declarationContext *_localctx = _tracker.createInstance<Integer_declarationContext>(_ctx, getState());
  enterRule(_localctx, 80, VerilogParser::RuleInteger_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1251);
    match(VerilogParser::INTEGER);
    setState(1252);
    list_of_variable_identifiers();
    setState(1253);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_declarationContext ------------------------------------------------------------------

VerilogParser::Net_declarationContext::Net_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_typeContext* VerilogParser::Net_declarationContext::net_type() {
  return getRuleContext<VerilogParser::Net_typeContext>(0);
}

VerilogParser::List_of_net_identifiersContext* VerilogParser::Net_declarationContext::list_of_net_identifiers() {
  return getRuleContext<VerilogParser::List_of_net_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Delay3Context* VerilogParser::Net_declarationContext::delay3() {
  return getRuleContext<VerilogParser::Delay3Context>(0);
}

VerilogParser::List_of_net_decl_assignmentsContext* VerilogParser::Net_declarationContext::list_of_net_decl_assignments() {
  return getRuleContext<VerilogParser::List_of_net_decl_assignmentsContext>(0);
}

VerilogParser::Drive_strengthContext* VerilogParser::Net_declarationContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Net_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::VECTORED() {
  return getToken(VerilogParser::VECTORED, 0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::SCALARED() {
  return getToken(VerilogParser::SCALARED, 0);
}

tree::TerminalNode* VerilogParser::Net_declarationContext::TRIREG() {
  return getToken(VerilogParser::TRIREG, 0);
}

VerilogParser::Charge_strengthContext* VerilogParser::Net_declarationContext::charge_strength() {
  return getRuleContext<VerilogParser::Charge_strengthContext>(0);
}


size_t VerilogParser::Net_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleNet_declaration;
}


std::any VerilogParser::Net_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_declarationContext* VerilogParser::net_declaration() {
  Net_declarationContext *_localctx = _tracker.createInstance<Net_declarationContext>(_ctx, getState());
  enterRule(_localctx, 82, VerilogParser::RuleNet_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1369);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1255);
      net_type();
      setState(1257);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1256);
        match(VerilogParser::SIGNED);
      }
      setState(1260);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1259);
        delay3();
      }
      setState(1262);
      list_of_net_identifiers();
      setState(1263);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1265);
      net_type();
      setState(1267);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1266);
        drive_strength();
      }
      setState(1270);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1269);
        match(VerilogParser::SIGNED);
      }
      setState(1273);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1272);
        delay3();
      }
      setState(1275);
      list_of_net_decl_assignments();
      setState(1276);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1278);
      net_type();
      setState(1280);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1279);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1283);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1282);
        match(VerilogParser::SIGNED);
      }
      setState(1285);
      range_();
      setState(1287);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1286);
        delay3();
      }
      setState(1289);
      list_of_net_identifiers();
      setState(1290);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1292);
      net_type();
      setState(1294);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1293);
        drive_strength();
      }
      setState(1297);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1296);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1300);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1299);
        match(VerilogParser::SIGNED);
      }
      setState(1302);
      range_();
      setState(1304);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1303);
        delay3();
      }
      setState(1306);
      list_of_net_decl_assignments();
      setState(1307);
      match(VerilogParser::SC);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1309);
      match(VerilogParser::TRIREG);
      setState(1311);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1310);
        charge_strength();
      }
      setState(1314);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1313);
        match(VerilogParser::SIGNED);
      }
      setState(1317);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1316);
        delay3();
      }
      setState(1319);
      list_of_net_identifiers();
      setState(1320);
      match(VerilogParser::SC);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1322);
      match(VerilogParser::TRIREG);
      setState(1324);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1323);
        drive_strength();
      }
      setState(1327);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1326);
        match(VerilogParser::SIGNED);
      }
      setState(1330);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1329);
        delay3();
      }
      setState(1332);
      list_of_net_decl_assignments();
      setState(1333);
      match(VerilogParser::SC);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1335);
      match(VerilogParser::TRIREG);
      setState(1337);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1336);
        charge_strength();
      }
      setState(1340);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1339);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1343);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1342);
        match(VerilogParser::SIGNED);
      }
      setState(1345);
      range_();
      setState(1347);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1346);
        delay3();
      }
      setState(1349);
      list_of_net_identifiers();
      setState(1350);
      match(VerilogParser::SC);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1352);
      match(VerilogParser::TRIREG);
      setState(1354);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LP) {
        setState(1353);
        drive_strength();
      }
      setState(1357);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SCALARED

      || _la == VerilogParser::VECTORED) {
        setState(1356);
        _la = _input->LA(1);
        if (!(_la == VerilogParser::SCALARED

        || _la == VerilogParser::VECTORED)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(1360);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1359);
        match(VerilogParser::SIGNED);
      }
      setState(1362);
      range_();
      setState(1364);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::HA) {
        setState(1363);
        delay3();
      }
      setState(1366);
      list_of_net_decl_assignments();
      setState(1367);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_declarationContext ------------------------------------------------------------------

VerilogParser::Real_declarationContext::Real_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Real_declarationContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

VerilogParser::List_of_real_identifiersContext* VerilogParser::Real_declarationContext::list_of_real_identifiers() {
  return getRuleContext<VerilogParser::List_of_real_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Real_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Real_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleReal_declaration;
}


std::any VerilogParser::Real_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_declarationContext* VerilogParser::real_declaration() {
  Real_declarationContext *_localctx = _tracker.createInstance<Real_declarationContext>(_ctx, getState());
  enterRule(_localctx, 84, VerilogParser::RuleReal_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1371);
    match(VerilogParser::REAL);
    setState(1372);
    list_of_real_identifiers();
    setState(1373);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Realtime_declarationContext ------------------------------------------------------------------

VerilogParser::Realtime_declarationContext::Realtime_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Realtime_declarationContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

VerilogParser::List_of_real_identifiersContext* VerilogParser::Realtime_declarationContext::list_of_real_identifiers() {
  return getRuleContext<VerilogParser::List_of_real_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Realtime_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Realtime_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleRealtime_declaration;
}


std::any VerilogParser::Realtime_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRealtime_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Realtime_declarationContext* VerilogParser::realtime_declaration() {
  Realtime_declarationContext *_localctx = _tracker.createInstance<Realtime_declarationContext>(_ctx, getState());
  enterRule(_localctx, 86, VerilogParser::RuleRealtime_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1375);
    match(VerilogParser::REALTIME);
    setState(1376);
    list_of_real_identifiers();
    setState(1377);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reg_declarationContext ------------------------------------------------------------------

VerilogParser::Reg_declarationContext::Reg_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Reg_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::Reg_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Reg_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Reg_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Reg_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Reg_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleReg_declaration;
}


std::any VerilogParser::Reg_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReg_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Reg_declarationContext* VerilogParser::reg_declaration() {
  Reg_declarationContext *_localctx = _tracker.createInstance<Reg_declarationContext>(_ctx, getState());
  enterRule(_localctx, 88, VerilogParser::RuleReg_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1379);
    match(VerilogParser::REG);
    setState(1381);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::SIGNED) {
      setState(1380);
      match(VerilogParser::SIGNED);
    }
    setState(1384);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(1383);
      range_();
    }
    setState(1386);
    list_of_variable_identifiers();
    setState(1387);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Time_declarationContext ------------------------------------------------------------------

VerilogParser::Time_declarationContext::Time_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Time_declarationContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::Time_declarationContext::list_of_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Time_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Time_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTime_declaration;
}


std::any VerilogParser::Time_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTime_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Time_declarationContext* VerilogParser::time_declaration() {
  Time_declarationContext *_localctx = _tracker.createInstance<Time_declarationContext>(_ctx, getState());
  enterRule(_localctx, 90, VerilogParser::RuleTime_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1389);
    match(VerilogParser::TIME);
    setState(1390);
    list_of_variable_identifiers();
    setState(1391);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_typeContext ------------------------------------------------------------------

VerilogParser::Net_typeContext::Net_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Net_typeContext::SUPPLYZERO() {
  return getToken(VerilogParser::SUPPLYZERO, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::SUPPLYONE() {
  return getToken(VerilogParser::SUPPLYONE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRI() {
  return getToken(VerilogParser::TRI, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIAND() {
  return getToken(VerilogParser::TRIAND, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIOR() {
  return getToken(VerilogParser::TRIOR, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIZERO() {
  return getToken(VerilogParser::TRIZERO, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::TRIONE() {
  return getToken(VerilogParser::TRIONE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::UWIRE() {
  return getToken(VerilogParser::UWIRE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::WIRE() {
  return getToken(VerilogParser::WIRE, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::WAND() {
  return getToken(VerilogParser::WAND, 0);
}

tree::TerminalNode* VerilogParser::Net_typeContext::WOR() {
  return getToken(VerilogParser::WOR, 0);
}


size_t VerilogParser::Net_typeContext::getRuleIndex() const {
  return VerilogParser::RuleNet_type;
}


std::any VerilogParser::Net_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_typeContext* VerilogParser::net_type() {
  Net_typeContext *_localctx = _tracker.createInstance<Net_typeContext>(_ctx, getState());
  enterRule(_localctx, 92, VerilogParser::RuleNet_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1393);
    _la = _input->LA(1);
    if (!((((_la - 157) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 157)) & 822800387) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_variable_typeContext ------------------------------------------------------------------

VerilogParser::Output_variable_typeContext::Output_variable_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Output_variable_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Output_variable_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Output_variable_typeContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_variable_type;
}


std::any VerilogParser::Output_variable_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_variable_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_variable_typeContext* VerilogParser::output_variable_type() {
  Output_variable_typeContext *_localctx = _tracker.createInstance<Output_variable_typeContext>(_ctx, getState());
  enterRule(_localctx, 94, VerilogParser::RuleOutput_variable_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1395);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::INTEGER || _la == VerilogParser::TIME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_typeContext ------------------------------------------------------------------

VerilogParser::Real_typeContext::Real_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Real_identifierContext* VerilogParser::Real_typeContext::real_identifier() {
  return getRuleContext<VerilogParser::Real_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Real_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Real_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}

tree::TerminalNode* VerilogParser::Real_typeContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Real_typeContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Real_typeContext::getRuleIndex() const {
  return VerilogParser::RuleReal_type;
}


std::any VerilogParser::Real_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_typeContext* VerilogParser::real_type() {
  Real_typeContext *_localctx = _tracker.createInstance<Real_typeContext>(_ctx, getState());
  enterRule(_localctx, 96, VerilogParser::RuleReal_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1408);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1397);
      real_identifier();
      setState(1401);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LB) {
        setState(1398);
        dimension();
        setState(1403);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1404);
      real_identifier();
      setState(1405);
      match(VerilogParser::EQ);
      setState(1406);
      constant_expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_typeContext ------------------------------------------------------------------

VerilogParser::Variable_typeContext::Variable_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_identifierContext* VerilogParser::Variable_typeContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Variable_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Variable_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}

tree::TerminalNode* VerilogParser::Variable_typeContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Variable_typeContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Variable_typeContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_type;
}


std::any VerilogParser::Variable_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_typeContext* VerilogParser::variable_type() {
  Variable_typeContext *_localctx = _tracker.createInstance<Variable_typeContext>(_ctx, getState());
  enterRule(_localctx, 98, VerilogParser::RuleVariable_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1421);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1410);
      variable_identifier();
      setState(1414);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LB) {
        setState(1411);
        dimension();
        setState(1416);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1417);
      variable_identifier();
      setState(1418);
      match(VerilogParser::EQ);
      setState(1419);
      constant_expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drive_strengthContext ------------------------------------------------------------------

VerilogParser::Drive_strengthContext::Drive_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Strength0Context* VerilogParser::Drive_strengthContext::strength0() {
  return getRuleContext<VerilogParser::Strength0Context>(0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Strength1Context* VerilogParser::Drive_strengthContext::strength1() {
  return getRuleContext<VerilogParser::Strength1Context>(0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::HIGHZONE() {
  return getToken(VerilogParser::HIGHZONE, 0);
}

tree::TerminalNode* VerilogParser::Drive_strengthContext::HIGHZZERO() {
  return getToken(VerilogParser::HIGHZZERO, 0);
}


size_t VerilogParser::Drive_strengthContext::getRuleIndex() const {
  return VerilogParser::RuleDrive_strength;
}


std::any VerilogParser::Drive_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDrive_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Drive_strengthContext* VerilogParser::drive_strength() {
  Drive_strengthContext *_localctx = _tracker.createInstance<Drive_strengthContext>(_ctx, getState());
  enterRule(_localctx, 100, VerilogParser::RuleDrive_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1459);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1423);
      match(VerilogParser::LP);
      setState(1424);
      strength0();
      setState(1425);
      match(VerilogParser::CO);
      setState(1426);
      strength1();
      setState(1427);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1429);
      match(VerilogParser::LP);
      setState(1430);
      strength1();
      setState(1431);
      match(VerilogParser::CO);
      setState(1432);
      strength0();
      setState(1433);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1435);
      match(VerilogParser::LP);
      setState(1436);
      strength0();
      setState(1437);
      match(VerilogParser::CO);
      setState(1438);
      match(VerilogParser::HIGHZONE);
      setState(1439);
      match(VerilogParser::RP);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1441);
      match(VerilogParser::LP);
      setState(1442);
      strength1();
      setState(1443);
      match(VerilogParser::CO);
      setState(1444);
      match(VerilogParser::HIGHZZERO);
      setState(1445);
      match(VerilogParser::RP);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1447);
      match(VerilogParser::LP);
      setState(1448);
      match(VerilogParser::HIGHZZERO);
      setState(1449);
      match(VerilogParser::CO);
      setState(1450);
      strength1();
      setState(1451);
      match(VerilogParser::RP);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1453);
      match(VerilogParser::LP);
      setState(1454);
      match(VerilogParser::HIGHZONE);
      setState(1455);
      match(VerilogParser::CO);
      setState(1456);
      strength0();
      setState(1457);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Strength0Context ------------------------------------------------------------------

VerilogParser::Strength0Context::Strength0Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Strength0Context::SUPPLYZERO() {
  return getToken(VerilogParser::SUPPLYZERO, 0);
}

tree::TerminalNode* VerilogParser::Strength0Context::STRONGZERO() {
  return getToken(VerilogParser::STRONGZERO, 0);
}

tree::TerminalNode* VerilogParser::Strength0Context::PULLZERO() {
  return getToken(VerilogParser::PULLZERO, 0);
}

tree::TerminalNode* VerilogParser::Strength0Context::WEAKZERO() {
  return getToken(VerilogParser::WEAKZERO, 0);
}


size_t VerilogParser::Strength0Context::getRuleIndex() const {
  return VerilogParser::RuleStrength0;
}


std::any VerilogParser::Strength0Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStrength0(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Strength0Context* VerilogParser::strength0() {
  Strength0Context *_localctx = _tracker.createInstance<Strength0Context>(_ctx, getState());
  enterRule(_localctx, 102, VerilogParser::RuleStrength0);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1461);
    _la = _input->LA(1);
    if (!((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & 18014399180570625) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Strength1Context ------------------------------------------------------------------

VerilogParser::Strength1Context::Strength1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Strength1Context::SUPPLYONE() {
  return getToken(VerilogParser::SUPPLYONE, 0);
}

tree::TerminalNode* VerilogParser::Strength1Context::STRONGONE() {
  return getToken(VerilogParser::STRONGONE, 0);
}

tree::TerminalNode* VerilogParser::Strength1Context::PULLONE() {
  return getToken(VerilogParser::PULLONE, 0);
}

tree::TerminalNode* VerilogParser::Strength1Context::WEAKONE() {
  return getToken(VerilogParser::WEAKONE, 0);
}


size_t VerilogParser::Strength1Context::getRuleIndex() const {
  return VerilogParser::RuleStrength1;
}


std::any VerilogParser::Strength1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStrength1(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Strength1Context* VerilogParser::strength1() {
  Strength1Context *_localctx = _tracker.createInstance<Strength1Context>(_ctx, getState());
  enterRule(_localctx, 104, VerilogParser::RuleStrength1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1463);
    _la = _input->LA(1);
    if (!((((_la - 127) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 127)) & 36028798361141249) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Charge_strengthContext ------------------------------------------------------------------

VerilogParser::Charge_strengthContext::Charge_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::SMALL() {
  return getToken(VerilogParser::SMALL, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::MEDIUM() {
  return getToken(VerilogParser::MEDIUM, 0);
}

tree::TerminalNode* VerilogParser::Charge_strengthContext::LARGE() {
  return getToken(VerilogParser::LARGE, 0);
}


size_t VerilogParser::Charge_strengthContext::getRuleIndex() const {
  return VerilogParser::RuleCharge_strength;
}


std::any VerilogParser::Charge_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCharge_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Charge_strengthContext* VerilogParser::charge_strength() {
  Charge_strengthContext *_localctx = _tracker.createInstance<Charge_strengthContext>(_ctx, getState());
  enterRule(_localctx, 106, VerilogParser::RuleCharge_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1474);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1465);
      match(VerilogParser::LP);
      setState(1466);
      match(VerilogParser::SMALL);
      setState(1467);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1468);
      match(VerilogParser::LP);
      setState(1469);
      match(VerilogParser::MEDIUM);
      setState(1470);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1471);
      match(VerilogParser::LP);
      setState(1472);
      match(VerilogParser::LARGE);
      setState(1473);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay3Context ------------------------------------------------------------------

VerilogParser::Delay3Context::Delay3Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delay3Context::HA() {
  return getToken(VerilogParser::HA, 0);
}

VerilogParser::Delay_valueContext* VerilogParser::Delay3Context::delay_value() {
  return getRuleContext<VerilogParser::Delay_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Delay3Context::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Mintypmax_expressionContext *> VerilogParser::Delay3Context::mintypmax_expression() {
  return getRuleContexts<VerilogParser::Mintypmax_expressionContext>();
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Delay3Context::mintypmax_expression(size_t i) {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Delay3Context::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Delay3Context::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Delay3Context::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Delay3Context::getRuleIndex() const {
  return VerilogParser::RuleDelay3;
}


std::any VerilogParser::Delay3Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay3(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay3Context* VerilogParser::delay3() {
  Delay3Context *_localctx = _tracker.createInstance<Delay3Context>(_ctx, getState());
  enterRule(_localctx, 108, VerilogParser::RuleDelay3);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1491);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1476);
      match(VerilogParser::HA);
      setState(1477);
      delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1478);
      match(VerilogParser::HA);
      setState(1479);
      match(VerilogParser::LP);
      setState(1480);
      mintypmax_expression();
      setState(1487);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1481);
        match(VerilogParser::CO);
        setState(1482);
        mintypmax_expression();
        setState(1485);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CO) {
          setState(1483);
          match(VerilogParser::CO);
          setState(1484);
          mintypmax_expression();
        }
      }
      setState(1489);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay2Context ------------------------------------------------------------------

VerilogParser::Delay2Context::Delay2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delay2Context::HA() {
  return getToken(VerilogParser::HA, 0);
}

VerilogParser::Delay_valueContext* VerilogParser::Delay2Context::delay_value() {
  return getRuleContext<VerilogParser::Delay_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Delay2Context::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Mintypmax_expressionContext *> VerilogParser::Delay2Context::mintypmax_expression() {
  return getRuleContexts<VerilogParser::Mintypmax_expressionContext>();
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Delay2Context::mintypmax_expression(size_t i) {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Delay2Context::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Delay2Context::CO() {
  return getToken(VerilogParser::CO, 0);
}


size_t VerilogParser::Delay2Context::getRuleIndex() const {
  return VerilogParser::RuleDelay2;
}


std::any VerilogParser::Delay2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay2(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay2Context* VerilogParser::delay2() {
  Delay2Context *_localctx = _tracker.createInstance<Delay2Context>(_ctx, getState());
  enterRule(_localctx, 110, VerilogParser::RuleDelay2);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1504);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1493);
      match(VerilogParser::HA);
      setState(1494);
      delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1495);
      match(VerilogParser::HA);
      setState(1496);
      match(VerilogParser::LP);
      setState(1497);
      mintypmax_expression();
      setState(1500);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1498);
        match(VerilogParser::CO);
        setState(1499);
        mintypmax_expression();
      }
      setState(1502);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_valueContext ------------------------------------------------------------------

VerilogParser::Delay_valueContext::Delay_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Unsigned_numberContext* VerilogParser::Delay_valueContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}

VerilogParser::Real_numberContext* VerilogParser::Delay_valueContext::real_number() {
  return getRuleContext<VerilogParser::Real_numberContext>(0);
}

VerilogParser::IdentifierContext* VerilogParser::Delay_valueContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Delay_valueContext::getRuleIndex() const {
  return VerilogParser::RuleDelay_value;
}


std::any VerilogParser::Delay_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay_valueContext* VerilogParser::delay_value() {
  Delay_valueContext *_localctx = _tracker.createInstance<Delay_valueContext>(_ctx, getState());
  enterRule(_localctx, 112, VerilogParser::RuleDelay_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1509);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::UNSIGNED_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(1506);
        unsigned_number();
        break;
      }

      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(1507);
        real_number();
        break;
      }

      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 3);
        setState(1508);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_defparam_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_defparam_assignmentsContext::List_of_defparam_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Defparam_assignmentContext *> VerilogParser::List_of_defparam_assignmentsContext::defparam_assignment() {
  return getRuleContexts<VerilogParser::Defparam_assignmentContext>();
}

VerilogParser::Defparam_assignmentContext* VerilogParser::List_of_defparam_assignmentsContext::defparam_assignment(size_t i) {
  return getRuleContext<VerilogParser::Defparam_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_defparam_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_defparam_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_defparam_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_defparam_assignments;
}


std::any VerilogParser::List_of_defparam_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_defparam_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_defparam_assignmentsContext* VerilogParser::list_of_defparam_assignments() {
  List_of_defparam_assignmentsContext *_localctx = _tracker.createInstance<List_of_defparam_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 114, VerilogParser::RuleList_of_defparam_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1511);
    defparam_assignment();
    setState(1516);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1512);
      match(VerilogParser::CO);
      setState(1513);
      defparam_assignment();
      setState(1518);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_event_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_event_identifiersContext::List_of_event_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Event_idContext *> VerilogParser::List_of_event_identifiersContext::event_id() {
  return getRuleContexts<VerilogParser::Event_idContext>();
}

VerilogParser::Event_idContext* VerilogParser::List_of_event_identifiersContext::event_id(size_t i) {
  return getRuleContext<VerilogParser::Event_idContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_event_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_event_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_event_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_event_identifiers;
}


std::any VerilogParser::List_of_event_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_event_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_event_identifiersContext* VerilogParser::list_of_event_identifiers() {
  List_of_event_identifiersContext *_localctx = _tracker.createInstance<List_of_event_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 116, VerilogParser::RuleList_of_event_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1519);
    event_id();
    setState(1524);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1520);
      match(VerilogParser::CO);
      setState(1521);
      event_id();
      setState(1526);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_idContext ------------------------------------------------------------------

VerilogParser::Event_idContext::Event_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Event_identifierContext* VerilogParser::Event_idContext::event_identifier() {
  return getRuleContext<VerilogParser::Event_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Event_idContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Event_idContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Event_idContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_id;
}


std::any VerilogParser::Event_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_id(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_idContext* VerilogParser::event_id() {
  Event_idContext *_localctx = _tracker.createInstance<Event_idContext>(_ctx, getState());
  enterRule(_localctx, 118, VerilogParser::RuleEvent_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1527);
    event_identifier();
    setState(1531);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(1528);
      dimension();
      setState(1533);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_decl_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_net_decl_assignmentsContext::List_of_net_decl_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Net_decl_assignmentContext *> VerilogParser::List_of_net_decl_assignmentsContext::net_decl_assignment() {
  return getRuleContexts<VerilogParser::Net_decl_assignmentContext>();
}

VerilogParser::Net_decl_assignmentContext* VerilogParser::List_of_net_decl_assignmentsContext::net_decl_assignment(size_t i) {
  return getRuleContext<VerilogParser::Net_decl_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_net_decl_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_net_decl_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_net_decl_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_net_decl_assignments;
}


std::any VerilogParser::List_of_net_decl_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_net_decl_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_net_decl_assignmentsContext* VerilogParser::list_of_net_decl_assignments() {
  List_of_net_decl_assignmentsContext *_localctx = _tracker.createInstance<List_of_net_decl_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 120, VerilogParser::RuleList_of_net_decl_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1534);
    net_decl_assignment();
    setState(1539);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1535);
      match(VerilogParser::CO);
      setState(1536);
      net_decl_assignment();
      setState(1541);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_net_identifiersContext::List_of_net_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Net_idContext *> VerilogParser::List_of_net_identifiersContext::net_id() {
  return getRuleContexts<VerilogParser::Net_idContext>();
}

VerilogParser::Net_idContext* VerilogParser::List_of_net_identifiersContext::net_id(size_t i) {
  return getRuleContext<VerilogParser::Net_idContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_net_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_net_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_net_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_net_identifiers;
}


std::any VerilogParser::List_of_net_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_net_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_net_identifiersContext* VerilogParser::list_of_net_identifiers() {
  List_of_net_identifiersContext *_localctx = _tracker.createInstance<List_of_net_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 122, VerilogParser::RuleList_of_net_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1542);
    net_id();
    setState(1547);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1543);
      match(VerilogParser::CO);
      setState(1544);
      net_id();
      setState(1549);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_idContext ------------------------------------------------------------------

VerilogParser::Net_idContext::Net_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_identifierContext* VerilogParser::Net_idContext::net_identifier() {
  return getRuleContext<VerilogParser::Net_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Net_idContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Net_idContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Net_idContext::getRuleIndex() const {
  return VerilogParser::RuleNet_id;
}


std::any VerilogParser::Net_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_id(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_idContext* VerilogParser::net_id() {
  Net_idContext *_localctx = _tracker.createInstance<Net_idContext>(_ctx, getState());
  enterRule(_localctx, 124, VerilogParser::RuleNet_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1550);
    net_identifier();
    setState(1554);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(1551);
      dimension();
      setState(1556);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_param_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_param_assignmentsContext::List_of_param_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Param_assignmentContext *> VerilogParser::List_of_param_assignmentsContext::param_assignment() {
  return getRuleContexts<VerilogParser::Param_assignmentContext>();
}

VerilogParser::Param_assignmentContext* VerilogParser::List_of_param_assignmentsContext::param_assignment(size_t i) {
  return getRuleContext<VerilogParser::Param_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_param_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_param_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_param_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_param_assignments;
}


std::any VerilogParser::List_of_param_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_param_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_param_assignmentsContext* VerilogParser::list_of_param_assignments() {
  List_of_param_assignmentsContext *_localctx = _tracker.createInstance<List_of_param_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 126, VerilogParser::RuleList_of_param_assignments);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1557);
    param_assignment();
    setState(1562);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1558);
        match(VerilogParser::CO);
        setState(1559);
        param_assignment(); 
      }
      setState(1564);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_port_identifiersContext::List_of_port_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Port_identifierContext *> VerilogParser::List_of_port_identifiersContext::port_identifier() {
  return getRuleContexts<VerilogParser::Port_identifierContext>();
}

VerilogParser::Port_identifierContext* VerilogParser::List_of_port_identifiersContext::port_identifier(size_t i) {
  return getRuleContext<VerilogParser::Port_identifierContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_port_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_port_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_port_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_port_identifiers;
}


std::any VerilogParser::List_of_port_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_port_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::list_of_port_identifiers() {
  List_of_port_identifiersContext *_localctx = _tracker.createInstance<List_of_port_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 128, VerilogParser::RuleList_of_port_identifiers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1565);
    port_identifier();
    setState(1570);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1566);
        match(VerilogParser::CO);
        setState(1567);
        port_identifier(); 
      }
      setState(1572);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_real_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_real_identifiersContext::List_of_real_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Real_typeContext *> VerilogParser::List_of_real_identifiersContext::real_type() {
  return getRuleContexts<VerilogParser::Real_typeContext>();
}

VerilogParser::Real_typeContext* VerilogParser::List_of_real_identifiersContext::real_type(size_t i) {
  return getRuleContext<VerilogParser::Real_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_real_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_real_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_real_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_real_identifiers;
}


std::any VerilogParser::List_of_real_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_real_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_real_identifiersContext* VerilogParser::list_of_real_identifiers() {
  List_of_real_identifiersContext *_localctx = _tracker.createInstance<List_of_real_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 130, VerilogParser::RuleList_of_real_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1573);
    real_type();
    setState(1578);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1574);
      match(VerilogParser::CO);
      setState(1575);
      real_type();
      setState(1580);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_specparam_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_specparam_assignmentsContext::List_of_specparam_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Specparam_assignmentContext *> VerilogParser::List_of_specparam_assignmentsContext::specparam_assignment() {
  return getRuleContexts<VerilogParser::Specparam_assignmentContext>();
}

VerilogParser::Specparam_assignmentContext* VerilogParser::List_of_specparam_assignmentsContext::specparam_assignment(size_t i) {
  return getRuleContext<VerilogParser::Specparam_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_specparam_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_specparam_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_specparam_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_specparam_assignments;
}


std::any VerilogParser::List_of_specparam_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_specparam_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_specparam_assignmentsContext* VerilogParser::list_of_specparam_assignments() {
  List_of_specparam_assignmentsContext *_localctx = _tracker.createInstance<List_of_specparam_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 132, VerilogParser::RuleList_of_specparam_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1581);
    specparam_assignment();
    setState(1586);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1582);
      match(VerilogParser::CO);
      setState(1583);
      specparam_assignment();
      setState(1588);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_variable_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_variable_identifiersContext::List_of_variable_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Variable_typeContext *> VerilogParser::List_of_variable_identifiersContext::variable_type() {
  return getRuleContexts<VerilogParser::Variable_typeContext>();
}

VerilogParser::Variable_typeContext* VerilogParser::List_of_variable_identifiersContext::variable_type(size_t i) {
  return getRuleContext<VerilogParser::Variable_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_variable_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_variable_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_variable_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_variable_identifiers;
}


std::any VerilogParser::List_of_variable_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_variable_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_variable_identifiersContext* VerilogParser::list_of_variable_identifiers() {
  List_of_variable_identifiersContext *_localctx = _tracker.createInstance<List_of_variable_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 134, VerilogParser::RuleList_of_variable_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1589);
    variable_type();
    setState(1594);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1590);
      match(VerilogParser::CO);
      setState(1591);
      variable_type();
      setState(1596);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_variable_port_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_variable_port_identifiersContext::List_of_variable_port_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Var_port_idContext *> VerilogParser::List_of_variable_port_identifiersContext::var_port_id() {
  return getRuleContexts<VerilogParser::Var_port_idContext>();
}

VerilogParser::Var_port_idContext* VerilogParser::List_of_variable_port_identifiersContext::var_port_id(size_t i) {
  return getRuleContext<VerilogParser::Var_port_idContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_variable_port_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_variable_port_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_variable_port_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_variable_port_identifiers;
}


std::any VerilogParser::List_of_variable_port_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_variable_port_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_variable_port_identifiersContext* VerilogParser::list_of_variable_port_identifiers() {
  List_of_variable_port_identifiersContext *_localctx = _tracker.createInstance<List_of_variable_port_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 136, VerilogParser::RuleList_of_variable_port_identifiers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1597);
    var_port_id();
    setState(1602);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1598);
        match(VerilogParser::CO);
        setState(1599);
        var_port_id(); 
      }
      setState(1604);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_port_idContext ------------------------------------------------------------------

VerilogParser::Var_port_idContext::Var_port_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Var_port_idContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Var_port_idContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Var_port_idContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Var_port_idContext::getRuleIndex() const {
  return VerilogParser::RuleVar_port_id;
}


std::any VerilogParser::Var_port_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVar_port_id(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Var_port_idContext* VerilogParser::var_port_id() {
  Var_port_idContext *_localctx = _tracker.createInstance<Var_port_idContext>(_ctx, getState());
  enterRule(_localctx, 138, VerilogParser::RuleVar_port_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1605);
    port_identifier();
    setState(1608);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::EQ) {
      setState(1606);
      match(VerilogParser::EQ);
      setState(1607);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Defparam_assignmentContext ------------------------------------------------------------------

VerilogParser::Defparam_assignmentContext::Defparam_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Defparam_assignmentContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Defparam_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Defparam_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Defparam_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleDefparam_assignment;
}


std::any VerilogParser::Defparam_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDefparam_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Defparam_assignmentContext* VerilogParser::defparam_assignment() {
  Defparam_assignmentContext *_localctx = _tracker.createInstance<Defparam_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 140, VerilogParser::RuleDefparam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1610);
    hierarchical_identifier();
    setState(1611);
    match(VerilogParser::EQ);
    setState(1612);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_decl_assignmentContext ------------------------------------------------------------------

VerilogParser::Net_decl_assignmentContext::Net_decl_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_identifierContext* VerilogParser::Net_decl_assignmentContext::net_identifier() {
  return getRuleContext<VerilogParser::Net_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Net_decl_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Net_decl_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Net_decl_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNet_decl_assignment;
}


std::any VerilogParser::Net_decl_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_decl_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_decl_assignmentContext* VerilogParser::net_decl_assignment() {
  Net_decl_assignmentContext *_localctx = _tracker.createInstance<Net_decl_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 142, VerilogParser::RuleNet_decl_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1614);
    net_identifier();
    setState(1615);
    match(VerilogParser::EQ);
    setState(1616);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Param_assignmentContext ------------------------------------------------------------------

VerilogParser::Param_assignmentContext::Param_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Parameter_identifierContext* VerilogParser::Param_assignmentContext::parameter_identifier() {
  return getRuleContext<VerilogParser::Parameter_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Param_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Param_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Param_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleParam_assignment;
}


std::any VerilogParser::Param_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParam_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Param_assignmentContext* VerilogParser::param_assignment() {
  Param_assignmentContext *_localctx = _tracker.createInstance<Param_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 144, VerilogParser::RuleParam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1618);
    parameter_identifier();
    setState(1619);
    match(VerilogParser::EQ);
    setState(1620);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_assignmentContext ------------------------------------------------------------------

VerilogParser::Specparam_assignmentContext::Specparam_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specparam_identifierContext* VerilogParser::Specparam_assignmentContext::specparam_identifier() {
  return getRuleContext<VerilogParser::Specparam_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Specparam_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Specparam_assignmentContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

VerilogParser::Pulse_control_specparamContext* VerilogParser::Specparam_assignmentContext::pulse_control_specparam() {
  return getRuleContext<VerilogParser::Pulse_control_specparamContext>(0);
}


size_t VerilogParser::Specparam_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleSpecparam_assignment;
}


std::any VerilogParser::Specparam_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecparam_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specparam_assignmentContext* VerilogParser::specparam_assignment() {
  Specparam_assignmentContext *_localctx = _tracker.createInstance<Specparam_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 146, VerilogParser::RuleSpecparam_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1627);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(1622);
        specparam_identifier();
        setState(1623);
        match(VerilogParser::EQ);
        setState(1624);
        constant_mintypmax_expression();
        break;
      }

      case VerilogParser::PATHPULSEDL: {
        enterOuterAlt(_localctx, 2);
        setState(1626);
        pulse_control_specparam();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulse_control_specparamContext ------------------------------------------------------------------

VerilogParser::Pulse_control_specparamContext::Pulse_control_specparamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::PATHPULSEDL() {
  return getToken(VerilogParser::PATHPULSEDL, 0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reject_limit_valueContext* VerilogParser::Pulse_control_specparamContext::reject_limit_value() {
  return getRuleContext<VerilogParser::Reject_limit_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Error_limit_valueContext* VerilogParser::Pulse_control_specparamContext::error_limit_value() {
  return getRuleContext<VerilogParser::Error_limit_valueContext>(0);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Pulse_control_specparamContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Pulse_control_specparamContext::DL() {
  return getToken(VerilogParser::DL, 0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Pulse_control_specparamContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}


size_t VerilogParser::Pulse_control_specparamContext::getRuleIndex() const {
  return VerilogParser::RulePulse_control_specparam;
}


std::any VerilogParser::Pulse_control_specparamContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPulse_control_specparam(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pulse_control_specparamContext* VerilogParser::pulse_control_specparam() {
  Pulse_control_specparamContext *_localctx = _tracker.createInstance<Pulse_control_specparamContext>(_ctx, getState());
  enterRule(_localctx, 148, VerilogParser::RulePulse_control_specparam);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1652);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1629);
      match(VerilogParser::PATHPULSEDL);
      setState(1630);
      match(VerilogParser::EQ);
      setState(1631);
      match(VerilogParser::LP);
      setState(1632);
      reject_limit_value();
      setState(1635);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1633);
        match(VerilogParser::CO);
        setState(1634);
        error_limit_value();
      }
      setState(1637);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1639);
      match(VerilogParser::PATHPULSEDL);
      setState(1640);
      specify_input_terminal_descriptor();
      setState(1641);
      match(VerilogParser::DL);
      setState(1642);
      specify_output_terminal_descriptor();
      setState(1643);
      match(VerilogParser::EQ);
      setState(1644);
      match(VerilogParser::LP);
      setState(1645);
      reject_limit_value();
      setState(1648);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(1646);
        match(VerilogParser::CO);
        setState(1647);
        error_limit_value();
      }
      setState(1650);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Error_limit_valueContext ------------------------------------------------------------------

VerilogParser::Error_limit_valueContext::Error_limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Limit_valueContext* VerilogParser::Error_limit_valueContext::limit_value() {
  return getRuleContext<VerilogParser::Limit_valueContext>(0);
}


size_t VerilogParser::Error_limit_valueContext::getRuleIndex() const {
  return VerilogParser::RuleError_limit_value;
}


std::any VerilogParser::Error_limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitError_limit_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Error_limit_valueContext* VerilogParser::error_limit_value() {
  Error_limit_valueContext *_localctx = _tracker.createInstance<Error_limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 150, VerilogParser::RuleError_limit_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1654);
    limit_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reject_limit_valueContext ------------------------------------------------------------------

VerilogParser::Reject_limit_valueContext::Reject_limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Limit_valueContext* VerilogParser::Reject_limit_valueContext::limit_value() {
  return getRuleContext<VerilogParser::Limit_valueContext>(0);
}


size_t VerilogParser::Reject_limit_valueContext::getRuleIndex() const {
  return VerilogParser::RuleReject_limit_value;
}


std::any VerilogParser::Reject_limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReject_limit_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Reject_limit_valueContext* VerilogParser::reject_limit_value() {
  Reject_limit_valueContext *_localctx = _tracker.createInstance<Reject_limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 152, VerilogParser::RuleReject_limit_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1656);
    limit_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Limit_valueContext ------------------------------------------------------------------

VerilogParser::Limit_valueContext::Limit_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Limit_valueContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Limit_valueContext::getRuleIndex() const {
  return VerilogParser::RuleLimit_value;
}


std::any VerilogParser::Limit_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLimit_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Limit_valueContext* VerilogParser::limit_value() {
  Limit_valueContext *_localctx = _tracker.createInstance<Limit_valueContext>(_ctx, getState());
  enterRule(_localctx, 154, VerilogParser::RuleLimit_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1658);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DimensionContext ------------------------------------------------------------------

VerilogParser::DimensionContext::DimensionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::DimensionContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

std::vector<VerilogParser::Dimension_constant_expressionContext *> VerilogParser::DimensionContext::dimension_constant_expression() {
  return getRuleContexts<VerilogParser::Dimension_constant_expressionContext>();
}

VerilogParser::Dimension_constant_expressionContext* VerilogParser::DimensionContext::dimension_constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Dimension_constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::DimensionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

tree::TerminalNode* VerilogParser::DimensionContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::DimensionContext::getRuleIndex() const {
  return VerilogParser::RuleDimension;
}


std::any VerilogParser::DimensionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDimension(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::DimensionContext* VerilogParser::dimension() {
  DimensionContext *_localctx = _tracker.createInstance<DimensionContext>(_ctx, getState());
  enterRule(_localctx, 156, VerilogParser::RuleDimension);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1660);
    match(VerilogParser::LB);
    setState(1661);
    dimension_constant_expression();
    setState(1662);
    match(VerilogParser::CL);
    setState(1663);
    dimension_constant_expression();
    setState(1664);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Range_Context ------------------------------------------------------------------

VerilogParser::Range_Context::Range_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Range_Context::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::Range_Context::msb_constant_expression() {
  return getRuleContext<VerilogParser::Msb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_Context::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::Range_Context::lsb_constant_expression() {
  return getRuleContext<VerilogParser::Lsb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_Context::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Range_Context::getRuleIndex() const {
  return VerilogParser::RuleRange_;
}


std::any VerilogParser::Range_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRange_(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Range_Context* VerilogParser::range_() {
  Range_Context *_localctx = _tracker.createInstance<Range_Context>(_ctx, getState());
  enterRule(_localctx, 158, VerilogParser::RuleRange_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1666);
    match(VerilogParser::LB);
    setState(1667);
    msb_constant_expression();
    setState(1668);
    match(VerilogParser::CL);
    setState(1669);
    lsb_constant_expression();
    setState(1670);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_declarationContext ------------------------------------------------------------------

VerilogParser::Function_declarationContext::Function_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Function_declarationContext::FUNCTION() {
  return getToken(VerilogParser::FUNCTION, 0);
}

VerilogParser::Function_identifierContext* VerilogParser::Function_declarationContext::function_identifier() {
  return getRuleContext<VerilogParser::Function_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Function_statementContext* VerilogParser::Function_declarationContext::function_statement() {
  return getRuleContext<VerilogParser::Function_statementContext>(0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::ENDFUNCTION() {
  return getToken(VerilogParser::ENDFUNCTION, 0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::AUTOMATIC() {
  return getToken(VerilogParser::AUTOMATIC, 0);
}

VerilogParser::Function_range_or_typeContext* VerilogParser::Function_declarationContext::function_range_or_type() {
  return getRuleContext<VerilogParser::Function_range_or_typeContext>(0);
}

std::vector<VerilogParser::Function_item_declarationContext *> VerilogParser::Function_declarationContext::function_item_declaration() {
  return getRuleContexts<VerilogParser::Function_item_declarationContext>();
}

VerilogParser::Function_item_declarationContext* VerilogParser::Function_declarationContext::function_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Function_item_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Function_port_listContext* VerilogParser::Function_declarationContext::function_port_list() {
  return getRuleContext<VerilogParser::Function_port_listContext>(0);
}

tree::TerminalNode* VerilogParser::Function_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Function_declarationContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Function_declarationContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Function_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_declaration;
}


std::any VerilogParser::Function_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_declarationContext* VerilogParser::function_declaration() {
  Function_declarationContext *_localctx = _tracker.createInstance<Function_declarationContext>(_ctx, getState());
  enterRule(_localctx, 160, VerilogParser::RuleFunction_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1710);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1672);
      match(VerilogParser::FUNCTION);
      setState(1674);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1673);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1677);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la - 88) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 88)) & 4612530443357519881) != 0 || _la == VerilogParser::TIME) {
        setState(1676);
        function_range_or_type();
      }
      setState(1679);
      function_identifier();
      setState(1680);
      match(VerilogParser::SC);
      setState(1682); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1681);
                function_item_declaration();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1684); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(1686);
      function_statement();
      setState(1687);
      match(VerilogParser::ENDFUNCTION);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1689);
      match(VerilogParser::FUNCTION);
      setState(1691);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1690);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1694);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la - 88) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 88)) & 4612530443357519881) != 0 || _la == VerilogParser::TIME) {
        setState(1693);
        function_range_or_type();
      }
      setState(1696);
      function_identifier();
      setState(1697);
      match(VerilogParser::LP);
      setState(1698);
      function_port_list();
      setState(1699);
      match(VerilogParser::RP);
      setState(1700);
      match(VerilogParser::SC);
      setState(1704);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1701);
          block_item_declaration(); 
        }
        setState(1706);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
      }
      setState(1707);
      function_statement();
      setState(1708);
      match(VerilogParser::ENDFUNCTION);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_item_declarationContext ------------------------------------------------------------------

VerilogParser::Function_item_declarationContext::Function_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Block_item_declarationContext* VerilogParser::Function_item_declarationContext::block_item_declaration() {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(0);
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Function_item_declarationContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Function_item_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Function_item_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Function_item_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Function_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_item_declaration;
}


std::any VerilogParser::Function_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_item_declarationContext* VerilogParser::function_item_declaration() {
  Function_item_declarationContext *_localctx = _tracker.createInstance<Function_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 162, VerilogParser::RuleFunction_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1722);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1712);
      block_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1716);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1713);
        attribute_instance();
        setState(1718);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1719);
      tf_input_declaration();
      setState(1720);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_port_listContext ------------------------------------------------------------------

VerilogParser::Function_port_listContext::Function_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Func_port_itemContext *> VerilogParser::Function_port_listContext::func_port_item() {
  return getRuleContexts<VerilogParser::Func_port_itemContext>();
}

VerilogParser::Func_port_itemContext* VerilogParser::Function_port_listContext::func_port_item(size_t i) {
  return getRuleContext<VerilogParser::Func_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Function_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Function_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Function_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_port_list;
}


std::any VerilogParser::Function_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_port_listContext* VerilogParser::function_port_list() {
  Function_port_listContext *_localctx = _tracker.createInstance<Function_port_listContext>(_ctx, getState());
  enterRule(_localctx, 164, VerilogParser::RuleFunction_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1724);
    func_port_item();
    setState(1729);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1725);
      match(VerilogParser::CO);
      setState(1726);
      func_port_item();
      setState(1731);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Func_port_itemContext ------------------------------------------------------------------

VerilogParser::Func_port_itemContext::Func_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Func_port_itemContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Func_port_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Func_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Func_port_itemContext::getRuleIndex() const {
  return VerilogParser::RuleFunc_port_item;
}


std::any VerilogParser::Func_port_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunc_port_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Func_port_itemContext* VerilogParser::func_port_item() {
  Func_port_itemContext *_localctx = _tracker.createInstance<Func_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 166, VerilogParser::RuleFunc_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1735);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(1732);
      attribute_instance();
      setState(1737);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1738);
    tf_input_declaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_range_or_typeContext ------------------------------------------------------------------

VerilogParser::Function_range_or_typeContext::Function_range_or_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Range_Context* VerilogParser::Function_range_or_typeContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

tree::TerminalNode* VerilogParser::Function_range_or_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Function_range_or_typeContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_range_or_type;
}


std::any VerilogParser::Function_range_or_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_range_or_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_range_or_typeContext* VerilogParser::function_range_or_type() {
  Function_range_or_typeContext *_localctx = _tracker.createInstance<Function_range_or_typeContext>(_ctx, getState());
  enterRule(_localctx, 168, VerilogParser::RuleFunction_range_or_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1749);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LB: {
        enterOuterAlt(_localctx, 1);
        setState(1740);
        range_();
        break;
      }

      case VerilogParser::SIGNED: {
        enterOuterAlt(_localctx, 2);
        setState(1741);
        match(VerilogParser::SIGNED);
        setState(1743);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::LB) {
          setState(1742);
          range_();
        }
        break;
      }

      case VerilogParser::INTEGER: {
        enterOuterAlt(_localctx, 3);
        setState(1745);
        match(VerilogParser::INTEGER);
        break;
      }

      case VerilogParser::REAL: {
        enterOuterAlt(_localctx, 4);
        setState(1746);
        match(VerilogParser::REAL);
        break;
      }

      case VerilogParser::REALTIME: {
        enterOuterAlt(_localctx, 5);
        setState(1747);
        match(VerilogParser::REALTIME);
        break;
      }

      case VerilogParser::TIME: {
        enterOuterAlt(_localctx, 6);
        setState(1748);
        match(VerilogParser::TIME);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_declarationContext ------------------------------------------------------------------

VerilogParser::Task_declarationContext::Task_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Task_declarationContext::TASK() {
  return getToken(VerilogParser::TASK, 0);
}

VerilogParser::Task_identifierContext* VerilogParser::Task_declarationContext::task_identifier() {
  return getRuleContext<VerilogParser::Task_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Task_declarationContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::ENDTASK() {
  return getToken(VerilogParser::ENDTASK, 0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::AUTOMATIC() {
  return getToken(VerilogParser::AUTOMATIC, 0);
}

std::vector<VerilogParser::Task_item_declarationContext *> VerilogParser::Task_declarationContext::task_item_declaration() {
  return getRuleContexts<VerilogParser::Task_item_declarationContext>();
}

VerilogParser::Task_item_declarationContext* VerilogParser::Task_declarationContext::task_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Task_item_declarationContext>(i);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Task_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Task_port_listContext* VerilogParser::Task_declarationContext::task_port_list() {
  return getRuleContext<VerilogParser::Task_port_listContext>(0);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Task_declarationContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Task_declarationContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Task_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTask_declaration;
}


std::any VerilogParser::Task_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_declarationContext* VerilogParser::task_declaration() {
  Task_declarationContext *_localctx = _tracker.createInstance<Task_declarationContext>(_ctx, getState());
  enterRule(_localctx, 170, VerilogParser::RuleTask_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1786);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1751);
      match(VerilogParser::TASK);
      setState(1753);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1752);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1755);
      task_identifier();
      setState(1756);
      match(VerilogParser::SC);
      setState(1760);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1757);
          task_item_declaration(); 
        }
        setState(1762);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx);
      }
      setState(1763);
      statement_or_null();
      setState(1764);
      match(VerilogParser::ENDTASK);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1766);
      match(VerilogParser::TASK);
      setState(1768);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::AUTOMATIC) {
        setState(1767);
        match(VerilogParser::AUTOMATIC);
      }
      setState(1770);
      task_identifier();
      setState(1771);
      match(VerilogParser::LP);
      setState(1773);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la - 85) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 85)) & 8589936643) != 0) {
        setState(1772);
        task_port_list();
      }
      setState(1775);
      match(VerilogParser::RP);
      setState(1776);
      match(VerilogParser::SC);
      setState(1780);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1777);
          block_item_declaration(); 
        }
        setState(1782);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
      }
      setState(1783);
      statement_or_null();
      setState(1784);
      match(VerilogParser::ENDTASK);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_item_declarationContext ------------------------------------------------------------------

VerilogParser::Task_item_declarationContext::Task_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Block_item_declarationContext* VerilogParser::Task_item_declarationContext::block_item_declaration() {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(0);
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Task_item_declarationContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Task_item_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Task_item_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Task_item_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Tf_output_declarationContext* VerilogParser::Task_item_declarationContext::tf_output_declaration() {
  return getRuleContext<VerilogParser::Tf_output_declarationContext>(0);
}

VerilogParser::Tf_inout_declarationContext* VerilogParser::Task_item_declarationContext::tf_inout_declaration() {
  return getRuleContext<VerilogParser::Tf_inout_declarationContext>(0);
}


size_t VerilogParser::Task_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTask_item_declaration;
}


std::any VerilogParser::Task_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_item_declarationContext* VerilogParser::task_item_declaration() {
  Task_item_declarationContext *_localctx = _tracker.createInstance<Task_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 172, VerilogParser::RuleTask_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1816);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1788);
      block_item_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1792);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1789);
        attribute_instance();
        setState(1794);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1795);
      tf_input_declaration();
      setState(1796);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1801);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1798);
        attribute_instance();
        setState(1803);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1804);
      tf_output_declaration();
      setState(1805);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1810);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1807);
        attribute_instance();
        setState(1812);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1813);
      tf_inout_declaration();
      setState(1814);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_port_listContext ------------------------------------------------------------------

VerilogParser::Task_port_listContext::Task_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Task_port_itemContext *> VerilogParser::Task_port_listContext::task_port_item() {
  return getRuleContexts<VerilogParser::Task_port_itemContext>();
}

VerilogParser::Task_port_itemContext* VerilogParser::Task_port_listContext::task_port_item(size_t i) {
  return getRuleContext<VerilogParser::Task_port_itemContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Task_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Task_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Task_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleTask_port_list;
}


std::any VerilogParser::Task_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_port_listContext* VerilogParser::task_port_list() {
  Task_port_listContext *_localctx = _tracker.createInstance<Task_port_listContext>(_ctx, getState());
  enterRule(_localctx, 174, VerilogParser::RuleTask_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1818);
    task_port_item();
    setState(1823);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1819);
      match(VerilogParser::CO);
      setState(1820);
      task_port_item();
      setState(1825);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_port_itemContext ------------------------------------------------------------------

VerilogParser::Task_port_itemContext::Task_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Tf_input_declarationContext* VerilogParser::Task_port_itemContext::tf_input_declaration() {
  return getRuleContext<VerilogParser::Tf_input_declarationContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Task_port_itemContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Task_port_itemContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Tf_output_declarationContext* VerilogParser::Task_port_itemContext::tf_output_declaration() {
  return getRuleContext<VerilogParser::Tf_output_declarationContext>(0);
}

VerilogParser::Tf_inout_declarationContext* VerilogParser::Task_port_itemContext::tf_inout_declaration() {
  return getRuleContext<VerilogParser::Tf_inout_declarationContext>(0);
}


size_t VerilogParser::Task_port_itemContext::getRuleIndex() const {
  return VerilogParser::RuleTask_port_item;
}


std::any VerilogParser::Task_port_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_port_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_port_itemContext* VerilogParser::task_port_item() {
  Task_port_itemContext *_localctx = _tracker.createInstance<Task_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 176, VerilogParser::RuleTask_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1847);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1829);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1826);
        attribute_instance();
        setState(1831);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1832);
      tf_input_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1836);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1833);
        attribute_instance();
        setState(1838);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1839);
      tf_output_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1843);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1840);
        attribute_instance();
        setState(1845);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1846);
      tf_inout_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_input_declarationContext ------------------------------------------------------------------

VerilogParser::Tf_input_declarationContext::Tf_input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Tf_input_declarationContext::INPUT() {
  return getToken(VerilogParser::INPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Tf_input_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Tf_input_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Tf_input_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Tf_input_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Task_port_typeContext* VerilogParser::Tf_input_declarationContext::task_port_type() {
  return getRuleContext<VerilogParser::Task_port_typeContext>(0);
}


size_t VerilogParser::Tf_input_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTf_input_declaration;
}


std::any VerilogParser::Tf_input_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTf_input_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tf_input_declarationContext* VerilogParser::tf_input_declaration() {
  Tf_input_declarationContext *_localctx = _tracker.createInstance<Tf_input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 178, VerilogParser::RuleTf_input_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1864);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1849);
      match(VerilogParser::INPUT);
      setState(1851);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::REG) {
        setState(1850);
        match(VerilogParser::REG);
      }
      setState(1854);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1853);
        match(VerilogParser::SIGNED);
      }
      setState(1857);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1856);
        range_();
      }
      setState(1859);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1860);
      match(VerilogParser::INPUT);
      setState(1861);
      task_port_type();
      setState(1862);
      list_of_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_output_declarationContext ------------------------------------------------------------------

VerilogParser::Tf_output_declarationContext::Tf_output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Tf_output_declarationContext::OUTPUT() {
  return getToken(VerilogParser::OUTPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Tf_output_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Tf_output_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Tf_output_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Tf_output_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Task_port_typeContext* VerilogParser::Tf_output_declarationContext::task_port_type() {
  return getRuleContext<VerilogParser::Task_port_typeContext>(0);
}


size_t VerilogParser::Tf_output_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTf_output_declaration;
}


std::any VerilogParser::Tf_output_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTf_output_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tf_output_declarationContext* VerilogParser::tf_output_declaration() {
  Tf_output_declarationContext *_localctx = _tracker.createInstance<Tf_output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 180, VerilogParser::RuleTf_output_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1881);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1866);
      match(VerilogParser::OUTPUT);
      setState(1868);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::REG) {
        setState(1867);
        match(VerilogParser::REG);
      }
      setState(1871);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1870);
        match(VerilogParser::SIGNED);
      }
      setState(1874);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1873);
        range_();
      }
      setState(1876);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1877);
      match(VerilogParser::OUTPUT);
      setState(1878);
      task_port_type();
      setState(1879);
      list_of_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tf_inout_declarationContext ------------------------------------------------------------------

VerilogParser::Tf_inout_declarationContext::Tf_inout_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Tf_inout_declarationContext::INOUT() {
  return getToken(VerilogParser::INOUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Tf_inout_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Tf_inout_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Tf_inout_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Tf_inout_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

VerilogParser::Task_port_typeContext* VerilogParser::Tf_inout_declarationContext::task_port_type() {
  return getRuleContext<VerilogParser::Task_port_typeContext>(0);
}


size_t VerilogParser::Tf_inout_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleTf_inout_declaration;
}


std::any VerilogParser::Tf_inout_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTf_inout_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tf_inout_declarationContext* VerilogParser::tf_inout_declaration() {
  Tf_inout_declarationContext *_localctx = _tracker.createInstance<Tf_inout_declarationContext>(_ctx, getState());
  enterRule(_localctx, 182, VerilogParser::RuleTf_inout_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1898);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1883);
      match(VerilogParser::INOUT);
      setState(1885);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::REG) {
        setState(1884);
        match(VerilogParser::REG);
      }
      setState(1888);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1887);
        match(VerilogParser::SIGNED);
      }
      setState(1891);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1890);
        range_();
      }
      setState(1893);
      list_of_port_identifiers();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1894);
      match(VerilogParser::INOUT);
      setState(1895);
      task_port_type();
      setState(1896);
      list_of_port_identifiers();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_port_typeContext ------------------------------------------------------------------

VerilogParser::Task_port_typeContext::Task_port_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

tree::TerminalNode* VerilogParser::Task_port_typeContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}


size_t VerilogParser::Task_port_typeContext::getRuleIndex() const {
  return VerilogParser::RuleTask_port_type;
}


std::any VerilogParser::Task_port_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_port_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_port_typeContext* VerilogParser::task_port_type() {
  Task_port_typeContext *_localctx = _tracker.createInstance<Task_port_typeContext>(_ctx, getState());
  enterRule(_localctx, 184, VerilogParser::RuleTask_port_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1900);
    _la = _input->LA(1);
    if (!((((_la - 88) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 88)) & 844424930131969) != 0 || _la == VerilogParser::TIME)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_item_declarationContext ------------------------------------------------------------------

VerilogParser::Block_item_declarationContext::Block_item_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::List_of_block_variable_identifiersContext* VerilogParser::Block_item_declarationContext::list_of_block_variable_identifiers() {
  return getRuleContext<VerilogParser::List_of_block_variable_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Block_item_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Block_item_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::SIGNED() {
  return getToken(VerilogParser::SIGNED, 0);
}

VerilogParser::Range_Context* VerilogParser::Block_item_declarationContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::INTEGER() {
  return getToken(VerilogParser::INTEGER, 0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::TIME() {
  return getToken(VerilogParser::TIME, 0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::REAL() {
  return getToken(VerilogParser::REAL, 0);
}

VerilogParser::List_of_block_real_identifiersContext* VerilogParser::Block_item_declarationContext::list_of_block_real_identifiers() {
  return getRuleContext<VerilogParser::List_of_block_real_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Block_item_declarationContext::REALTIME() {
  return getToken(VerilogParser::REALTIME, 0);
}

VerilogParser::Event_declarationContext* VerilogParser::Block_item_declarationContext::event_declaration() {
  return getRuleContext<VerilogParser::Event_declarationContext>(0);
}

VerilogParser::Local_parameter_declarationContext* VerilogParser::Block_item_declarationContext::local_parameter_declaration() {
  return getRuleContext<VerilogParser::Local_parameter_declarationContext>(0);
}

VerilogParser::Parameter_declarationContext* VerilogParser::Block_item_declarationContext::parameter_declaration() {
  return getRuleContext<VerilogParser::Parameter_declarationContext>(0);
}


size_t VerilogParser::Block_item_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_item_declaration;
}


std::any VerilogParser::Block_item_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_item_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_item_declarationContext* VerilogParser::block_item_declaration() {
  Block_item_declarationContext *_localctx = _tracker.createInstance<Block_item_declarationContext>(_ctx, getState());
  enterRule(_localctx, 186, VerilogParser::RuleBlock_item_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1983);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1905);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1902);
        attribute_instance();
        setState(1907);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1908);
      match(VerilogParser::REG);
      setState(1910);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::SIGNED) {
        setState(1909);
        match(VerilogParser::SIGNED);
      }
      setState(1913);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::LB) {
        setState(1912);
        range_();
      }
      setState(1915);
      list_of_block_variable_identifiers();
      setState(1916);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1921);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1918);
        attribute_instance();
        setState(1923);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1924);
      match(VerilogParser::INTEGER);
      setState(1925);
      list_of_block_variable_identifiers();
      setState(1926);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1931);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1928);
        attribute_instance();
        setState(1933);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1934);
      match(VerilogParser::TIME);
      setState(1935);
      list_of_block_variable_identifiers();
      setState(1936);
      match(VerilogParser::SC);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1941);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1938);
        attribute_instance();
        setState(1943);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1944);
      match(VerilogParser::REAL);
      setState(1945);
      list_of_block_real_identifiers();
      setState(1946);
      match(VerilogParser::SC);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1951);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1948);
        attribute_instance();
        setState(1953);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1954);
      match(VerilogParser::REALTIME);
      setState(1955);
      list_of_block_real_identifiers();
      setState(1956);
      match(VerilogParser::SC);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1961);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1958);
        attribute_instance();
        setState(1963);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1964);
      event_declaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1968);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1965);
        attribute_instance();
        setState(1970);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1971);
      local_parameter_declaration();
      setState(1972);
      match(VerilogParser::SC);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1977);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(1974);
        attribute_instance();
        setState(1979);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1980);
      parameter_declaration();
      setState(1981);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_block_variable_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_block_variable_identifiersContext::List_of_block_variable_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Block_variable_typeContext *> VerilogParser::List_of_block_variable_identifiersContext::block_variable_type() {
  return getRuleContexts<VerilogParser::Block_variable_typeContext>();
}

VerilogParser::Block_variable_typeContext* VerilogParser::List_of_block_variable_identifiersContext::block_variable_type(size_t i) {
  return getRuleContext<VerilogParser::Block_variable_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_block_variable_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_block_variable_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_block_variable_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_block_variable_identifiers;
}


std::any VerilogParser::List_of_block_variable_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_block_variable_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_block_variable_identifiersContext* VerilogParser::list_of_block_variable_identifiers() {
  List_of_block_variable_identifiersContext *_localctx = _tracker.createInstance<List_of_block_variable_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 188, VerilogParser::RuleList_of_block_variable_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1985);
    block_variable_type();
    setState(1990);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1986);
      match(VerilogParser::CO);
      setState(1987);
      block_variable_type();
      setState(1992);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_block_real_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_block_real_identifiersContext::List_of_block_real_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Block_real_typeContext *> VerilogParser::List_of_block_real_identifiersContext::block_real_type() {
  return getRuleContexts<VerilogParser::Block_real_typeContext>();
}

VerilogParser::Block_real_typeContext* VerilogParser::List_of_block_real_identifiersContext::block_real_type(size_t i) {
  return getRuleContext<VerilogParser::Block_real_typeContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_block_real_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_block_real_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_block_real_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_block_real_identifiers;
}


std::any VerilogParser::List_of_block_real_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_block_real_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_block_real_identifiersContext* VerilogParser::list_of_block_real_identifiers() {
  List_of_block_real_identifiersContext *_localctx = _tracker.createInstance<List_of_block_real_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 190, VerilogParser::RuleList_of_block_real_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1993);
    block_real_type();
    setState(1998);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(1994);
      match(VerilogParser::CO);
      setState(1995);
      block_real_type();
      setState(2000);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_variable_typeContext ------------------------------------------------------------------

VerilogParser::Block_variable_typeContext::Block_variable_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_identifierContext* VerilogParser::Block_variable_typeContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Block_variable_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Block_variable_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Block_variable_typeContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_variable_type;
}


std::any VerilogParser::Block_variable_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_variable_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_variable_typeContext* VerilogParser::block_variable_type() {
  Block_variable_typeContext *_localctx = _tracker.createInstance<Block_variable_typeContext>(_ctx, getState());
  enterRule(_localctx, 192, VerilogParser::RuleBlock_variable_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2001);
    variable_identifier();
    setState(2005);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(2002);
      dimension();
      setState(2007);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_real_typeContext ------------------------------------------------------------------

VerilogParser::Block_real_typeContext::Block_real_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Real_identifierContext* VerilogParser::Block_real_typeContext::real_identifier() {
  return getRuleContext<VerilogParser::Real_identifierContext>(0);
}

std::vector<VerilogParser::DimensionContext *> VerilogParser::Block_real_typeContext::dimension() {
  return getRuleContexts<VerilogParser::DimensionContext>();
}

VerilogParser::DimensionContext* VerilogParser::Block_real_typeContext::dimension(size_t i) {
  return getRuleContext<VerilogParser::DimensionContext>(i);
}


size_t VerilogParser::Block_real_typeContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_real_type;
}


std::any VerilogParser::Block_real_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_real_type(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_real_typeContext* VerilogParser::block_real_type() {
  Block_real_typeContext *_localctx = _tracker.createInstance<Block_real_typeContext>(_ctx, getState());
  enterRule(_localctx, 194, VerilogParser::RuleBlock_real_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2008);
    real_identifier();
    setState(2012);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LB) {
      setState(2009);
      dimension();
      setState(2014);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gate_instantiationContext ------------------------------------------------------------------

VerilogParser::Gate_instantiationContext::Gate_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Cmos_switchtypeContext* VerilogParser::Gate_instantiationContext::cmos_switchtype() {
  return getRuleContext<VerilogParser::Cmos_switchtypeContext>(0);
}

std::vector<VerilogParser::Cmos_switch_instanceContext *> VerilogParser::Gate_instantiationContext::cmos_switch_instance() {
  return getRuleContexts<VerilogParser::Cmos_switch_instanceContext>();
}

VerilogParser::Cmos_switch_instanceContext* VerilogParser::Gate_instantiationContext::cmos_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Cmos_switch_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Delay3Context* VerilogParser::Gate_instantiationContext::delay3() {
  return getRuleContext<VerilogParser::Delay3Context>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Gate_instantiationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Enable_gatetypeContext* VerilogParser::Gate_instantiationContext::enable_gatetype() {
  return getRuleContext<VerilogParser::Enable_gatetypeContext>(0);
}

std::vector<VerilogParser::Enable_gate_instanceContext *> VerilogParser::Gate_instantiationContext::enable_gate_instance() {
  return getRuleContexts<VerilogParser::Enable_gate_instanceContext>();
}

VerilogParser::Enable_gate_instanceContext* VerilogParser::Gate_instantiationContext::enable_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::Enable_gate_instanceContext>(i);
}

VerilogParser::Drive_strengthContext* VerilogParser::Gate_instantiationContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Mos_switchtypeContext* VerilogParser::Gate_instantiationContext::mos_switchtype() {
  return getRuleContext<VerilogParser::Mos_switchtypeContext>(0);
}

std::vector<VerilogParser::Mos_switch_instanceContext *> VerilogParser::Gate_instantiationContext::mos_switch_instance() {
  return getRuleContexts<VerilogParser::Mos_switch_instanceContext>();
}

VerilogParser::Mos_switch_instanceContext* VerilogParser::Gate_instantiationContext::mos_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Mos_switch_instanceContext>(i);
}

VerilogParser::N_input_gatetypeContext* VerilogParser::Gate_instantiationContext::n_input_gatetype() {
  return getRuleContext<VerilogParser::N_input_gatetypeContext>(0);
}

std::vector<VerilogParser::N_input_gate_instanceContext *> VerilogParser::Gate_instantiationContext::n_input_gate_instance() {
  return getRuleContexts<VerilogParser::N_input_gate_instanceContext>();
}

VerilogParser::N_input_gate_instanceContext* VerilogParser::Gate_instantiationContext::n_input_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::N_input_gate_instanceContext>(i);
}

VerilogParser::Delay2Context* VerilogParser::Gate_instantiationContext::delay2() {
  return getRuleContext<VerilogParser::Delay2Context>(0);
}

VerilogParser::N_output_gatetypeContext* VerilogParser::Gate_instantiationContext::n_output_gatetype() {
  return getRuleContext<VerilogParser::N_output_gatetypeContext>(0);
}

std::vector<VerilogParser::N_output_gate_instanceContext *> VerilogParser::Gate_instantiationContext::n_output_gate_instance() {
  return getRuleContexts<VerilogParser::N_output_gate_instanceContext>();
}

VerilogParser::N_output_gate_instanceContext* VerilogParser::Gate_instantiationContext::n_output_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::N_output_gate_instanceContext>(i);
}

VerilogParser::Pass_en_switchtypeContext* VerilogParser::Gate_instantiationContext::pass_en_switchtype() {
  return getRuleContext<VerilogParser::Pass_en_switchtypeContext>(0);
}

std::vector<VerilogParser::Pass_enable_switch_instanceContext *> VerilogParser::Gate_instantiationContext::pass_enable_switch_instance() {
  return getRuleContexts<VerilogParser::Pass_enable_switch_instanceContext>();
}

VerilogParser::Pass_enable_switch_instanceContext* VerilogParser::Gate_instantiationContext::pass_enable_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Pass_enable_switch_instanceContext>(i);
}

VerilogParser::Pass_switchtypeContext* VerilogParser::Gate_instantiationContext::pass_switchtype() {
  return getRuleContext<VerilogParser::Pass_switchtypeContext>(0);
}

std::vector<VerilogParser::Pass_switch_instanceContext *> VerilogParser::Gate_instantiationContext::pass_switch_instance() {
  return getRuleContexts<VerilogParser::Pass_switch_instanceContext>();
}

VerilogParser::Pass_switch_instanceContext* VerilogParser::Gate_instantiationContext::pass_switch_instance(size_t i) {
  return getRuleContext<VerilogParser::Pass_switch_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::PULLDOWN() {
  return getToken(VerilogParser::PULLDOWN, 0);
}

std::vector<VerilogParser::Pull_gate_instanceContext *> VerilogParser::Gate_instantiationContext::pull_gate_instance() {
  return getRuleContexts<VerilogParser::Pull_gate_instanceContext>();
}

VerilogParser::Pull_gate_instanceContext* VerilogParser::Gate_instantiationContext::pull_gate_instance(size_t i) {
  return getRuleContext<VerilogParser::Pull_gate_instanceContext>(i);
}

VerilogParser::Pulldown_strengthContext* VerilogParser::Gate_instantiationContext::pulldown_strength() {
  return getRuleContext<VerilogParser::Pulldown_strengthContext>(0);
}

tree::TerminalNode* VerilogParser::Gate_instantiationContext::PULLUP() {
  return getToken(VerilogParser::PULLUP, 0);
}

VerilogParser::Pullup_strengthContext* VerilogParser::Gate_instantiationContext::pullup_strength() {
  return getRuleContext<VerilogParser::Pullup_strengthContext>(0);
}


size_t VerilogParser::Gate_instantiationContext::getRuleIndex() const {
  return VerilogParser::RuleGate_instantiation;
}


std::any VerilogParser::Gate_instantiationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGate_instantiation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Gate_instantiationContext* VerilogParser::gate_instantiation() {
  Gate_instantiationContext *_localctx = _tracker.createInstance<Gate_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 196, VerilogParser::RuleGate_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2147);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CMOS:
      case VerilogParser::RCMOS: {
        enterOuterAlt(_localctx, 1);
        setState(2015);
        cmos_switchtype();
        setState(2017);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2016);
          delay3();
        }
        setState(2019);
        cmos_switch_instance();
        setState(2024);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2020);
          match(VerilogParser::CO);
          setState(2021);
          cmos_switch_instance();
          setState(2026);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2027);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::BUFIFONE:
      case VerilogParser::BUFIFZERO:
      case VerilogParser::NOTIFONE:
      case VerilogParser::NOTIFZERO: {
        enterOuterAlt(_localctx, 2);
        setState(2029);
        enable_gatetype();
        setState(2031);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx)) {
        case 1: {
          setState(2030);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(2034);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2033);
          delay3();
        }
        setState(2036);
        enable_gate_instance();
        setState(2041);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2037);
          match(VerilogParser::CO);
          setState(2038);
          enable_gate_instance();
          setState(2043);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2044);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::NMOS:
      case VerilogParser::PMOS:
      case VerilogParser::RNMOS:
      case VerilogParser::RPMOS: {
        enterOuterAlt(_localctx, 3);
        setState(2046);
        mos_switchtype();
        setState(2048);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2047);
          delay3();
        }
        setState(2050);
        mos_switch_instance();
        setState(2055);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2051);
          match(VerilogParser::CO);
          setState(2052);
          mos_switch_instance();
          setState(2057);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2058);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::AND:
      case VerilogParser::NAND:
      case VerilogParser::NOR:
      case VerilogParser::OR:
      case VerilogParser::XNOR:
      case VerilogParser::XOR: {
        enterOuterAlt(_localctx, 4);
        setState(2060);
        n_input_gatetype();
        setState(2062);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx)) {
        case 1: {
          setState(2061);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(2065);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2064);
          delay2();
        }
        setState(2067);
        n_input_gate_instance();
        setState(2072);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2068);
          match(VerilogParser::CO);
          setState(2069);
          n_input_gate_instance();
          setState(2074);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2075);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::BUF:
      case VerilogParser::NOT: {
        enterOuterAlt(_localctx, 5);
        setState(2077);
        n_output_gatetype();
        setState(2079);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx)) {
        case 1: {
          setState(2078);
          drive_strength();
          break;
        }

        default:
          break;
        }
        setState(2082);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2081);
          delay2();
        }
        setState(2084);
        n_output_gate_instance();
        setState(2089);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2085);
          match(VerilogParser::CO);
          setState(2086);
          n_output_gate_instance();
          setState(2091);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2092);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::RTRANIFONE:
      case VerilogParser::RTRANIFZERO:
      case VerilogParser::TRANIFONE:
      case VerilogParser::TRANIFZERO: {
        enterOuterAlt(_localctx, 6);
        setState(2094);
        pass_en_switchtype();
        setState(2096);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::HA) {
          setState(2095);
          delay2();
        }
        setState(2098);
        pass_enable_switch_instance();
        setState(2103);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2099);
          match(VerilogParser::CO);
          setState(2100);
          pass_enable_switch_instance();
          setState(2105);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2106);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::RTRAN:
      case VerilogParser::TRAN: {
        enterOuterAlt(_localctx, 7);
        setState(2108);
        pass_switchtype();
        setState(2109);
        pass_switch_instance();
        setState(2114);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2110);
          match(VerilogParser::CO);
          setState(2111);
          pass_switch_instance();
          setState(2116);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2117);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::PULLDOWN: {
        enterOuterAlt(_localctx, 8);
        setState(2119);
        match(VerilogParser::PULLDOWN);
        setState(2121);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
        case 1: {
          setState(2120);
          pulldown_strength();
          break;
        }

        default:
          break;
        }
        setState(2123);
        pull_gate_instance();
        setState(2128);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2124);
          match(VerilogParser::CO);
          setState(2125);
          pull_gate_instance();
          setState(2130);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2131);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::PULLUP: {
        enterOuterAlt(_localctx, 9);
        setState(2133);
        match(VerilogParser::PULLUP);
        setState(2135);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
        case 1: {
          setState(2134);
          pullup_strength();
          break;
        }

        default:
          break;
        }
        setState(2137);
        pull_gate_instance();
        setState(2142);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2138);
          match(VerilogParser::CO);
          setState(2139);
          pull_gate_instance();
          setState(2144);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2145);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmos_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Cmos_switch_instanceContext::Cmos_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Cmos_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Cmos_switch_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Cmos_switch_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Cmos_switch_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::Cmos_switch_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

VerilogParser::Ncontrol_terminalContext* VerilogParser::Cmos_switch_instanceContext::ncontrol_terminal() {
  return getRuleContext<VerilogParser::Ncontrol_terminalContext>(0);
}

VerilogParser::Pcontrol_terminalContext* VerilogParser::Cmos_switch_instanceContext::pcontrol_terminal() {
  return getRuleContext<VerilogParser::Pcontrol_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Cmos_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Cmos_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Cmos_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleCmos_switch_instance;
}


std::any VerilogParser::Cmos_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCmos_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cmos_switch_instanceContext* VerilogParser::cmos_switch_instance() {
  Cmos_switch_instanceContext *_localctx = _tracker.createInstance<Cmos_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 198, VerilogParser::RuleCmos_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2150);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2149);
      name_of_gate_instance();
    }
    setState(2152);
    match(VerilogParser::LP);
    setState(2153);
    output_terminal();
    setState(2154);
    match(VerilogParser::CO);
    setState(2155);
    input_terminal();
    setState(2156);
    match(VerilogParser::CO);
    setState(2157);
    ncontrol_terminal();
    setState(2158);
    match(VerilogParser::CO);
    setState(2159);
    pcontrol_terminal();
    setState(2160);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_gate_instanceContext ------------------------------------------------------------------

VerilogParser::Enable_gate_instanceContext::Enable_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Enable_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Enable_gate_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Enable_gate_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Enable_gate_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::Enable_gate_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

VerilogParser::Enable_terminalContext* VerilogParser::Enable_gate_instanceContext::enable_terminal() {
  return getRuleContext<VerilogParser::Enable_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Enable_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Enable_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Enable_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleEnable_gate_instance;
}


std::any VerilogParser::Enable_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnable_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Enable_gate_instanceContext* VerilogParser::enable_gate_instance() {
  Enable_gate_instanceContext *_localctx = _tracker.createInstance<Enable_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 200, VerilogParser::RuleEnable_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2163);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2162);
      name_of_gate_instance();
    }
    setState(2165);
    match(VerilogParser::LP);
    setState(2166);
    output_terminal();
    setState(2167);
    match(VerilogParser::CO);
    setState(2168);
    input_terminal();
    setState(2169);
    match(VerilogParser::CO);
    setState(2170);
    enable_terminal();
    setState(2171);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mos_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Mos_switch_instanceContext::Mos_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Mos_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Mos_switch_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Mos_switch_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Mos_switch_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::Mos_switch_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

VerilogParser::Enable_terminalContext* VerilogParser::Mos_switch_instanceContext::enable_terminal() {
  return getRuleContext<VerilogParser::Enable_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Mos_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Mos_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Mos_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleMos_switch_instance;
}


std::any VerilogParser::Mos_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMos_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Mos_switch_instanceContext* VerilogParser::mos_switch_instance() {
  Mos_switch_instanceContext *_localctx = _tracker.createInstance<Mos_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 202, VerilogParser::RuleMos_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2174);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2173);
      name_of_gate_instance();
    }
    setState(2176);
    match(VerilogParser::LP);
    setState(2177);
    output_terminal();
    setState(2178);
    match(VerilogParser::CO);
    setState(2179);
    input_terminal();
    setState(2180);
    match(VerilogParser::CO);
    setState(2181);
    enable_terminal();
    setState(2182);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_input_gate_instanceContext ------------------------------------------------------------------

VerilogParser::N_input_gate_instanceContext::N_input_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_input_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::N_input_gate_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::N_input_gate_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::N_input_gate_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Input_terminalContext *> VerilogParser::N_input_gate_instanceContext::input_terminal() {
  return getRuleContexts<VerilogParser::Input_terminalContext>();
}

VerilogParser::Input_terminalContext* VerilogParser::N_input_gate_instanceContext::input_terminal(size_t i) {
  return getRuleContext<VerilogParser::Input_terminalContext>(i);
}

tree::TerminalNode* VerilogParser::N_input_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::N_input_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::N_input_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleN_input_gate_instance;
}


std::any VerilogParser::N_input_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_input_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_input_gate_instanceContext* VerilogParser::n_input_gate_instance() {
  N_input_gate_instanceContext *_localctx = _tracker.createInstance<N_input_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 204, VerilogParser::RuleN_input_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2185);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2184);
      name_of_gate_instance();
    }
    setState(2187);
    match(VerilogParser::LP);
    setState(2188);
    output_terminal();
    setState(2189);
    match(VerilogParser::CO);
    setState(2190);
    input_terminal();
    setState(2195);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2191);
      match(VerilogParser::CO);
      setState(2192);
      input_terminal();
      setState(2197);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2198);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_output_gate_instanceContext ------------------------------------------------------------------

VerilogParser::N_output_gate_instanceContext::N_output_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_output_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Output_terminalContext *> VerilogParser::N_output_gate_instanceContext::output_terminal() {
  return getRuleContexts<VerilogParser::Output_terminalContext>();
}

VerilogParser::Output_terminalContext* VerilogParser::N_output_gate_instanceContext::output_terminal(size_t i) {
  return getRuleContext<VerilogParser::Output_terminalContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::N_output_gate_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::N_output_gate_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Input_terminalContext* VerilogParser::N_output_gate_instanceContext::input_terminal() {
  return getRuleContext<VerilogParser::Input_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::N_output_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::N_output_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::N_output_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleN_output_gate_instance;
}


std::any VerilogParser::N_output_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_output_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_output_gate_instanceContext* VerilogParser::n_output_gate_instance() {
  N_output_gate_instanceContext *_localctx = _tracker.createInstance<N_output_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 206, VerilogParser::RuleN_output_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2201);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2200);
      name_of_gate_instance();
    }
    setState(2203);
    match(VerilogParser::LP);
    setState(2204);
    output_terminal();
    setState(2209);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2205);
        match(VerilogParser::CO);
        setState(2206);
        output_terminal(); 
      }
      setState(2211);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx);
    }
    setState(2212);
    match(VerilogParser::CO);
    setState(2213);
    input_terminal();
    setState(2214);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Pass_switch_instanceContext::Pass_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Inout_terminalContext *> VerilogParser::Pass_switch_instanceContext::inout_terminal() {
  return getRuleContexts<VerilogParser::Inout_terminalContext>();
}

VerilogParser::Inout_terminalContext* VerilogParser::Pass_switch_instanceContext::inout_terminal(size_t i) {
  return getRuleContext<VerilogParser::Inout_terminalContext>(i);
}

tree::TerminalNode* VerilogParser::Pass_switch_instanceContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

tree::TerminalNode* VerilogParser::Pass_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Pass_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Pass_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RulePass_switch_instance;
}


std::any VerilogParser::Pass_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_switch_instanceContext* VerilogParser::pass_switch_instance() {
  Pass_switch_instanceContext *_localctx = _tracker.createInstance<Pass_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 208, VerilogParser::RulePass_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2217);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2216);
      name_of_gate_instance();
    }
    setState(2219);
    match(VerilogParser::LP);
    setState(2220);
    inout_terminal();
    setState(2221);
    match(VerilogParser::CO);
    setState(2222);
    inout_terminal();
    setState(2223);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_enable_switch_instanceContext ------------------------------------------------------------------

VerilogParser::Pass_enable_switch_instanceContext::Pass_enable_switch_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_enable_switch_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Inout_terminalContext *> VerilogParser::Pass_enable_switch_instanceContext::inout_terminal() {
  return getRuleContexts<VerilogParser::Inout_terminalContext>();
}

VerilogParser::Inout_terminalContext* VerilogParser::Pass_enable_switch_instanceContext::inout_terminal(size_t i) {
  return getRuleContext<VerilogParser::Inout_terminalContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Pass_enable_switch_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Pass_enable_switch_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Enable_terminalContext* VerilogParser::Pass_enable_switch_instanceContext::enable_terminal() {
  return getRuleContext<VerilogParser::Enable_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Pass_enable_switch_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Pass_enable_switch_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Pass_enable_switch_instanceContext::getRuleIndex() const {
  return VerilogParser::RulePass_enable_switch_instance;
}


std::any VerilogParser::Pass_enable_switch_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_enable_switch_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_enable_switch_instanceContext* VerilogParser::pass_enable_switch_instance() {
  Pass_enable_switch_instanceContext *_localctx = _tracker.createInstance<Pass_enable_switch_instanceContext>(_ctx, getState());
  enterRule(_localctx, 210, VerilogParser::RulePass_enable_switch_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2226);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2225);
      name_of_gate_instance();
    }
    setState(2228);
    match(VerilogParser::LP);
    setState(2229);
    inout_terminal();
    setState(2230);
    match(VerilogParser::CO);
    setState(2231);
    inout_terminal();
    setState(2232);
    match(VerilogParser::CO);
    setState(2233);
    enable_terminal();
    setState(2234);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pull_gate_instanceContext ------------------------------------------------------------------

VerilogParser::Pull_gate_instanceContext::Pull_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pull_gate_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Pull_gate_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

tree::TerminalNode* VerilogParser::Pull_gate_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::Pull_gate_instanceContext::name_of_gate_instance() {
  return getRuleContext<VerilogParser::Name_of_gate_instanceContext>(0);
}


size_t VerilogParser::Pull_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RulePull_gate_instance;
}


std::any VerilogParser::Pull_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPull_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pull_gate_instanceContext* VerilogParser::pull_gate_instance() {
  Pull_gate_instanceContext *_localctx = _tracker.createInstance<Pull_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 212, VerilogParser::RulePull_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2237);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2236);
      name_of_gate_instance();
    }
    setState(2239);
    match(VerilogParser::LP);
    setState(2240);
    output_terminal();
    setState(2241);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_of_gate_instanceContext ------------------------------------------------------------------

VerilogParser::Name_of_gate_instanceContext::Name_of_gate_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Gate_instance_identifierContext* VerilogParser::Name_of_gate_instanceContext::gate_instance_identifier() {
  return getRuleContext<VerilogParser::Gate_instance_identifierContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Name_of_gate_instanceContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Name_of_gate_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleName_of_gate_instance;
}


std::any VerilogParser::Name_of_gate_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitName_of_gate_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Name_of_gate_instanceContext* VerilogParser::name_of_gate_instance() {
  Name_of_gate_instanceContext *_localctx = _tracker.createInstance<Name_of_gate_instanceContext>(_ctx, getState());
  enterRule(_localctx, 214, VerilogParser::RuleName_of_gate_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2243);
    gate_instance_identifier();
    setState(2245);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(2244);
      range_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulldown_strengthContext ------------------------------------------------------------------

VerilogParser::Pulldown_strengthContext::Pulldown_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pulldown_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Strength0Context* VerilogParser::Pulldown_strengthContext::strength0() {
  return getRuleContext<VerilogParser::Strength0Context>(0);
}

tree::TerminalNode* VerilogParser::Pulldown_strengthContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Strength1Context* VerilogParser::Pulldown_strengthContext::strength1() {
  return getRuleContext<VerilogParser::Strength1Context>(0);
}

tree::TerminalNode* VerilogParser::Pulldown_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Pulldown_strengthContext::getRuleIndex() const {
  return VerilogParser::RulePulldown_strength;
}


std::any VerilogParser::Pulldown_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPulldown_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pulldown_strengthContext* VerilogParser::pulldown_strength() {
  Pulldown_strengthContext *_localctx = _tracker.createInstance<Pulldown_strengthContext>(_ctx, getState());
  enterRule(_localctx, 216, VerilogParser::RulePulldown_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2263);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2247);
      match(VerilogParser::LP);
      setState(2248);
      strength0();
      setState(2249);
      match(VerilogParser::CO);
      setState(2250);
      strength1();
      setState(2251);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2253);
      match(VerilogParser::LP);
      setState(2254);
      strength1();
      setState(2255);
      match(VerilogParser::CO);
      setState(2256);
      strength0();
      setState(2257);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2259);
      match(VerilogParser::LP);
      setState(2260);
      strength0();
      setState(2261);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pullup_strengthContext ------------------------------------------------------------------

VerilogParser::Pullup_strengthContext::Pullup_strengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pullup_strengthContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Strength0Context* VerilogParser::Pullup_strengthContext::strength0() {
  return getRuleContext<VerilogParser::Strength0Context>(0);
}

tree::TerminalNode* VerilogParser::Pullup_strengthContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Strength1Context* VerilogParser::Pullup_strengthContext::strength1() {
  return getRuleContext<VerilogParser::Strength1Context>(0);
}

tree::TerminalNode* VerilogParser::Pullup_strengthContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Pullup_strengthContext::getRuleIndex() const {
  return VerilogParser::RulePullup_strength;
}


std::any VerilogParser::Pullup_strengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPullup_strength(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pullup_strengthContext* VerilogParser::pullup_strength() {
  Pullup_strengthContext *_localctx = _tracker.createInstance<Pullup_strengthContext>(_ctx, getState());
  enterRule(_localctx, 218, VerilogParser::RulePullup_strength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2281);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2265);
      match(VerilogParser::LP);
      setState(2266);
      strength0();
      setState(2267);
      match(VerilogParser::CO);
      setState(2268);
      strength1();
      setState(2269);
      match(VerilogParser::RP);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2271);
      match(VerilogParser::LP);
      setState(2272);
      strength1();
      setState(2273);
      match(VerilogParser::CO);
      setState(2274);
      strength0();
      setState(2275);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2277);
      match(VerilogParser::LP);
      setState(2278);
      strength1();
      setState(2279);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_terminalContext ------------------------------------------------------------------

VerilogParser::Enable_terminalContext::Enable_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Enable_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Enable_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleEnable_terminal;
}


std::any VerilogParser::Enable_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnable_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Enable_terminalContext* VerilogParser::enable_terminal() {
  Enable_terminalContext *_localctx = _tracker.createInstance<Enable_terminalContext>(_ctx, getState());
  enterRule(_localctx, 220, VerilogParser::RuleEnable_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2283);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Inout_terminalContext ------------------------------------------------------------------

VerilogParser::Inout_terminalContext::Inout_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_lvalueContext* VerilogParser::Inout_terminalContext::net_lvalue() {
  return getRuleContext<VerilogParser::Net_lvalueContext>(0);
}


size_t VerilogParser::Inout_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleInout_terminal;
}


std::any VerilogParser::Inout_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInout_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Inout_terminalContext* VerilogParser::inout_terminal() {
  Inout_terminalContext *_localctx = _tracker.createInstance<Inout_terminalContext>(_ctx, getState());
  enterRule(_localctx, 222, VerilogParser::RuleInout_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2285);
    net_lvalue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_terminalContext ------------------------------------------------------------------

VerilogParser::Input_terminalContext::Input_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Input_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Input_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleInput_terminal;
}


std::any VerilogParser::Input_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_terminalContext* VerilogParser::input_terminal() {
  Input_terminalContext *_localctx = _tracker.createInstance<Input_terminalContext>(_ctx, getState());
  enterRule(_localctx, 224, VerilogParser::RuleInput_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2287);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ncontrol_terminalContext ------------------------------------------------------------------

VerilogParser::Ncontrol_terminalContext::Ncontrol_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Ncontrol_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Ncontrol_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleNcontrol_terminal;
}


std::any VerilogParser::Ncontrol_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNcontrol_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Ncontrol_terminalContext* VerilogParser::ncontrol_terminal() {
  Ncontrol_terminalContext *_localctx = _tracker.createInstance<Ncontrol_terminalContext>(_ctx, getState());
  enterRule(_localctx, 226, VerilogParser::RuleNcontrol_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2289);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_terminalContext ------------------------------------------------------------------

VerilogParser::Output_terminalContext::Output_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_lvalueContext* VerilogParser::Output_terminalContext::net_lvalue() {
  return getRuleContext<VerilogParser::Net_lvalueContext>(0);
}


size_t VerilogParser::Output_terminalContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_terminal;
}


std::any VerilogParser::Output_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_terminalContext* VerilogParser::output_terminal() {
  Output_terminalContext *_localctx = _tracker.createInstance<Output_terminalContext>(_ctx, getState());
  enterRule(_localctx, 228, VerilogParser::RuleOutput_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2291);
    net_lvalue();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pcontrol_terminalContext ------------------------------------------------------------------

VerilogParser::Pcontrol_terminalContext::Pcontrol_terminalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Pcontrol_terminalContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Pcontrol_terminalContext::getRuleIndex() const {
  return VerilogParser::RulePcontrol_terminal;
}


std::any VerilogParser::Pcontrol_terminalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPcontrol_terminal(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pcontrol_terminalContext* VerilogParser::pcontrol_terminal() {
  Pcontrol_terminalContext *_localctx = _tracker.createInstance<Pcontrol_terminalContext>(_ctx, getState());
  enterRule(_localctx, 230, VerilogParser::RulePcontrol_terminal);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2293);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cmos_switchtypeContext ------------------------------------------------------------------

VerilogParser::Cmos_switchtypeContext::Cmos_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Cmos_switchtypeContext::CMOS() {
  return getToken(VerilogParser::CMOS, 0);
}

tree::TerminalNode* VerilogParser::Cmos_switchtypeContext::RCMOS() {
  return getToken(VerilogParser::RCMOS, 0);
}


size_t VerilogParser::Cmos_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RuleCmos_switchtype;
}


std::any VerilogParser::Cmos_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCmos_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cmos_switchtypeContext* VerilogParser::cmos_switchtype() {
  Cmos_switchtypeContext *_localctx = _tracker.createInstance<Cmos_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 232, VerilogParser::RuleCmos_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2295);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::CMOS || _la == VerilogParser::RCMOS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Enable_gatetypeContext ------------------------------------------------------------------

VerilogParser::Enable_gatetypeContext::Enable_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::BUFIFZERO() {
  return getToken(VerilogParser::BUFIFZERO, 0);
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::BUFIFONE() {
  return getToken(VerilogParser::BUFIFONE, 0);
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::NOTIFZERO() {
  return getToken(VerilogParser::NOTIFZERO, 0);
}

tree::TerminalNode* VerilogParser::Enable_gatetypeContext::NOTIFONE() {
  return getToken(VerilogParser::NOTIFONE, 0);
}


size_t VerilogParser::Enable_gatetypeContext::getRuleIndex() const {
  return VerilogParser::RuleEnable_gatetype;
}


std::any VerilogParser::Enable_gatetypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnable_gatetype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Enable_gatetypeContext* VerilogParser::enable_gatetype() {
  Enable_gatetypeContext *_localctx = _tracker.createInstance<Enable_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 234, VerilogParser::RuleEnable_gatetype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2297);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::BUFIFONE

    || _la == VerilogParser::BUFIFZERO || _la == VerilogParser::NOTIFONE

    || _la == VerilogParser::NOTIFZERO)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mos_switchtypeContext ------------------------------------------------------------------

VerilogParser::Mos_switchtypeContext::Mos_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::NMOS() {
  return getToken(VerilogParser::NMOS, 0);
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::PMOS() {
  return getToken(VerilogParser::PMOS, 0);
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::RNMOS() {
  return getToken(VerilogParser::RNMOS, 0);
}

tree::TerminalNode* VerilogParser::Mos_switchtypeContext::RPMOS() {
  return getToken(VerilogParser::RPMOS, 0);
}


size_t VerilogParser::Mos_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RuleMos_switchtype;
}


std::any VerilogParser::Mos_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMos_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Mos_switchtypeContext* VerilogParser::mos_switchtype() {
  Mos_switchtypeContext *_localctx = _tracker.createInstance<Mos_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 236, VerilogParser::RuleMos_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2299);
    _la = _input->LA(1);
    if (!((((_la - 111) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 111)) & 5368713217) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_input_gatetypeContext ------------------------------------------------------------------

VerilogParser::N_input_gatetypeContext::N_input_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::AND() {
  return getToken(VerilogParser::AND, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::NAND() {
  return getToken(VerilogParser::NAND, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::OR() {
  return getToken(VerilogParser::OR, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::NOR() {
  return getToken(VerilogParser::NOR, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::XOR() {
  return getToken(VerilogParser::XOR, 0);
}

tree::TerminalNode* VerilogParser::N_input_gatetypeContext::XNOR() {
  return getToken(VerilogParser::XNOR, 0);
}


size_t VerilogParser::N_input_gatetypeContext::getRuleIndex() const {
  return VerilogParser::RuleN_input_gatetype;
}


std::any VerilogParser::N_input_gatetypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_input_gatetype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_input_gatetypeContext* VerilogParser::n_input_gatetype() {
  N_input_gatetypeContext *_localctx = _tracker.createInstance<N_input_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 238, VerilogParser::RuleN_input_gatetype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2301);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::AND || (((_la - 109) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 109)) & 265) != 0 || _la == VerilogParser::XNOR

    || _la == VerilogParser::XOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- N_output_gatetypeContext ------------------------------------------------------------------

VerilogParser::N_output_gatetypeContext::N_output_gatetypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::N_output_gatetypeContext::BUF() {
  return getToken(VerilogParser::BUF, 0);
}

tree::TerminalNode* VerilogParser::N_output_gatetypeContext::NOT() {
  return getToken(VerilogParser::NOT, 0);
}


size_t VerilogParser::N_output_gatetypeContext::getRuleIndex() const {
  return VerilogParser::RuleN_output_gatetype;
}


std::any VerilogParser::N_output_gatetypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitN_output_gatetype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::N_output_gatetypeContext* VerilogParser::n_output_gatetype() {
  N_output_gatetypeContext *_localctx = _tracker.createInstance<N_output_gatetypeContext>(_ctx, getState());
  enterRule(_localctx, 240, VerilogParser::RuleN_output_gatetype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2303);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::BUF || _la == VerilogParser::NOT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_en_switchtypeContext ------------------------------------------------------------------

VerilogParser::Pass_en_switchtypeContext::Pass_en_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::TRANIFZERO() {
  return getToken(VerilogParser::TRANIFZERO, 0);
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::TRANIFONE() {
  return getToken(VerilogParser::TRANIFONE, 0);
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::RTRANIFONE() {
  return getToken(VerilogParser::RTRANIFONE, 0);
}

tree::TerminalNode* VerilogParser::Pass_en_switchtypeContext::RTRANIFZERO() {
  return getToken(VerilogParser::RTRANIFZERO, 0);
}


size_t VerilogParser::Pass_en_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RulePass_en_switchtype;
}


std::any VerilogParser::Pass_en_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_en_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_en_switchtypeContext* VerilogParser::pass_en_switchtype() {
  Pass_en_switchtypeContext *_localctx = _tracker.createInstance<Pass_en_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 242, VerilogParser::RulePass_en_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2305);
    _la = _input->LA(1);
    if (!((((_la - 145) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 145)) & 12582915) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pass_switchtypeContext ------------------------------------------------------------------

VerilogParser::Pass_switchtypeContext::Pass_switchtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pass_switchtypeContext::TRAN() {
  return getToken(VerilogParser::TRAN, 0);
}

tree::TerminalNode* VerilogParser::Pass_switchtypeContext::RTRAN() {
  return getToken(VerilogParser::RTRAN, 0);
}


size_t VerilogParser::Pass_switchtypeContext::getRuleIndex() const {
  return VerilogParser::RulePass_switchtype;
}


std::any VerilogParser::Pass_switchtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPass_switchtype(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pass_switchtypeContext* VerilogParser::pass_switchtype() {
  Pass_switchtypeContext *_localctx = _tracker.createInstance<Pass_switchtypeContext>(_ctx, getState());
  enterRule(_localctx, 244, VerilogParser::RulePass_switchtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2307);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::RTRAN

    || _la == VerilogParser::TRAN)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_instantiationContext ------------------------------------------------------------------

VerilogParser::Module_instantiationContext::Module_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_identifierContext* VerilogParser::Module_instantiationContext::module_identifier() {
  return getRuleContext<VerilogParser::Module_identifierContext>(0);
}

std::vector<VerilogParser::Module_instanceContext *> VerilogParser::Module_instantiationContext::module_instance() {
  return getRuleContexts<VerilogParser::Module_instanceContext>();
}

VerilogParser::Module_instanceContext* VerilogParser::Module_instantiationContext::module_instance(size_t i) {
  return getRuleContext<VerilogParser::Module_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Module_instantiationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Parameter_value_assignmentContext* VerilogParser::Module_instantiationContext::parameter_value_assignment() {
  return getRuleContext<VerilogParser::Parameter_value_assignmentContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_instantiationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Module_instantiationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Module_instantiationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_instantiation;
}


std::any VerilogParser::Module_instantiationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_instantiation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_instantiationContext* VerilogParser::module_instantiation() {
  Module_instantiationContext *_localctx = _tracker.createInstance<Module_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 246, VerilogParser::RuleModule_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2309);
    module_identifier();
    setState(2311);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(2310);
      parameter_value_assignment();
    }
    setState(2313);
    module_instance();
    setState(2318);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2314);
      match(VerilogParser::CO);
      setState(2315);
      module_instance();
      setState(2320);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2321);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_value_assignmentContext ------------------------------------------------------------------

VerilogParser::Parameter_value_assignmentContext::Parameter_value_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parameter_value_assignmentContext::HA() {
  return getToken(VerilogParser::HA, 0);
}

tree::TerminalNode* VerilogParser::Parameter_value_assignmentContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::List_of_parameter_assignmentsContext* VerilogParser::Parameter_value_assignmentContext::list_of_parameter_assignments() {
  return getRuleContext<VerilogParser::List_of_parameter_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Parameter_value_assignmentContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Parameter_value_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_value_assignment;
}


std::any VerilogParser::Parameter_value_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_value_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_value_assignmentContext* VerilogParser::parameter_value_assignment() {
  Parameter_value_assignmentContext *_localctx = _tracker.createInstance<Parameter_value_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 248, VerilogParser::RuleParameter_value_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2323);
    match(VerilogParser::HA);
    setState(2324);
    match(VerilogParser::LP);
    setState(2325);
    list_of_parameter_assignments();
    setState(2326);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_parameter_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_parameter_assignmentsContext::List_of_parameter_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Ordered_parameter_assignmentContext *> VerilogParser::List_of_parameter_assignmentsContext::ordered_parameter_assignment() {
  return getRuleContexts<VerilogParser::Ordered_parameter_assignmentContext>();
}

VerilogParser::Ordered_parameter_assignmentContext* VerilogParser::List_of_parameter_assignmentsContext::ordered_parameter_assignment(size_t i) {
  return getRuleContext<VerilogParser::Ordered_parameter_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_parameter_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_parameter_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Named_parameter_assignmentContext *> VerilogParser::List_of_parameter_assignmentsContext::named_parameter_assignment() {
  return getRuleContexts<VerilogParser::Named_parameter_assignmentContext>();
}

VerilogParser::Named_parameter_assignmentContext* VerilogParser::List_of_parameter_assignmentsContext::named_parameter_assignment(size_t i) {
  return getRuleContext<VerilogParser::Named_parameter_assignmentContext>(i);
}


size_t VerilogParser::List_of_parameter_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_parameter_assignments;
}


std::any VerilogParser::List_of_parameter_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_parameter_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_parameter_assignmentsContext* VerilogParser::list_of_parameter_assignments() {
  List_of_parameter_assignmentsContext *_localctx = _tracker.createInstance<List_of_parameter_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 250, VerilogParser::RuleList_of_parameter_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2344);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::CATI:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(2328);
        ordered_parameter_assignment();
        setState(2333);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2329);
          match(VerilogParser::CO);
          setState(2330);
          ordered_parameter_assignment();
          setState(2335);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case VerilogParser::DT: {
        enterOuterAlt(_localctx, 2);
        setState(2336);
        named_parameter_assignment();
        setState(2341);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2337);
          match(VerilogParser::CO);
          setState(2338);
          named_parameter_assignment();
          setState(2343);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordered_parameter_assignmentContext ------------------------------------------------------------------

VerilogParser::Ordered_parameter_assignmentContext::Ordered_parameter_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Ordered_parameter_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Ordered_parameter_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleOrdered_parameter_assignment;
}


std::any VerilogParser::Ordered_parameter_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOrdered_parameter_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Ordered_parameter_assignmentContext* VerilogParser::ordered_parameter_assignment() {
  Ordered_parameter_assignmentContext *_localctx = _tracker.createInstance<Ordered_parameter_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 252, VerilogParser::RuleOrdered_parameter_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2346);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Named_parameter_assignmentContext ------------------------------------------------------------------

VerilogParser::Named_parameter_assignmentContext::Named_parameter_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Named_parameter_assignmentContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Parameter_identifierContext* VerilogParser::Named_parameter_assignmentContext::parameter_identifier() {
  return getRuleContext<VerilogParser::Parameter_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Named_parameter_assignmentContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Named_parameter_assignmentContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Named_parameter_assignmentContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Named_parameter_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNamed_parameter_assignment;
}


std::any VerilogParser::Named_parameter_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNamed_parameter_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Named_parameter_assignmentContext* VerilogParser::named_parameter_assignment() {
  Named_parameter_assignmentContext *_localctx = _tracker.createInstance<Named_parameter_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 254, VerilogParser::RuleNamed_parameter_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2348);
    match(VerilogParser::DT);
    setState(2349);
    parameter_identifier();
    setState(2350);
    match(VerilogParser::LP);
    setState(2352);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281474977824772) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 1098706452503) != 0) {
      setState(2351);
      mintypmax_expression();
    }
    setState(2354);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_instanceContext ------------------------------------------------------------------

VerilogParser::Module_instanceContext::Module_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Name_of_module_instanceContext* VerilogParser::Module_instanceContext::name_of_module_instance() {
  return getRuleContext<VerilogParser::Name_of_module_instanceContext>(0);
}

tree::TerminalNode* VerilogParser::Module_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::List_of_port_connectionsContext* VerilogParser::Module_instanceContext::list_of_port_connections() {
  return getRuleContext<VerilogParser::List_of_port_connectionsContext>(0);
}

tree::TerminalNode* VerilogParser::Module_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Module_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleModule_instance;
}


std::any VerilogParser::Module_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_instanceContext* VerilogParser::module_instance() {
  Module_instanceContext *_localctx = _tracker.createInstance<Module_instanceContext>(_ctx, getState());
  enterRule(_localctx, 256, VerilogParser::RuleModule_instance);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2356);
    name_of_module_instance();
    setState(2357);
    match(VerilogParser::LP);
    setState(2358);
    list_of_port_connections();
    setState(2359);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_of_module_instanceContext ------------------------------------------------------------------

VerilogParser::Name_of_module_instanceContext::Name_of_module_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_instance_identifierContext* VerilogParser::Name_of_module_instanceContext::module_instance_identifier() {
  return getRuleContext<VerilogParser::Module_instance_identifierContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Name_of_module_instanceContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Name_of_module_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleName_of_module_instance;
}


std::any VerilogParser::Name_of_module_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitName_of_module_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Name_of_module_instanceContext* VerilogParser::name_of_module_instance() {
  Name_of_module_instanceContext *_localctx = _tracker.createInstance<Name_of_module_instanceContext>(_ctx, getState());
  enterRule(_localctx, 258, VerilogParser::RuleName_of_module_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2361);
    module_instance_identifier();
    setState(2363);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(2362);
      range_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_port_connectionsContext ------------------------------------------------------------------

VerilogParser::List_of_port_connectionsContext::List_of_port_connectionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Ordered_port_connectionContext *> VerilogParser::List_of_port_connectionsContext::ordered_port_connection() {
  return getRuleContexts<VerilogParser::Ordered_port_connectionContext>();
}

VerilogParser::Ordered_port_connectionContext* VerilogParser::List_of_port_connectionsContext::ordered_port_connection(size_t i) {
  return getRuleContext<VerilogParser::Ordered_port_connectionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_port_connectionsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_port_connectionsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Named_port_connectionContext *> VerilogParser::List_of_port_connectionsContext::named_port_connection() {
  return getRuleContexts<VerilogParser::Named_port_connectionContext>();
}

VerilogParser::Named_port_connectionContext* VerilogParser::List_of_port_connectionsContext::named_port_connection(size_t i) {
  return getRuleContext<VerilogParser::Named_port_connectionContext>(i);
}


size_t VerilogParser::List_of_port_connectionsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_port_connections;
}


std::any VerilogParser::List_of_port_connectionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_port_connections(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_port_connectionsContext* VerilogParser::list_of_port_connections() {
  List_of_port_connectionsContext *_localctx = _tracker.createInstance<List_of_port_connectionsContext>(_ctx, getState());
  enterRule(_localctx, 260, VerilogParser::RuleList_of_port_connections);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2381);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2365);
      ordered_port_connection();
      setState(2370);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::CO) {
        setState(2366);
        match(VerilogParser::CO);
        setState(2367);
        ordered_port_connection();
        setState(2372);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2373);
      named_port_connection();
      setState(2378);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::CO) {
        setState(2374);
        match(VerilogParser::CO);
        setState(2375);
        named_port_connection();
        setState(2380);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordered_port_connectionContext ------------------------------------------------------------------

VerilogParser::Ordered_port_connectionContext::Ordered_port_connectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Ordered_port_connectionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Ordered_port_connectionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::ExpressionContext* VerilogParser::Ordered_port_connectionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Ordered_port_connectionContext::getRuleIndex() const {
  return VerilogParser::RuleOrdered_port_connection;
}


std::any VerilogParser::Ordered_port_connectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOrdered_port_connection(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Ordered_port_connectionContext* VerilogParser::ordered_port_connection() {
  Ordered_port_connectionContext *_localctx = _tracker.createInstance<Ordered_port_connectionContext>(_ctx, getState());
  enterRule(_localctx, 262, VerilogParser::RuleOrdered_port_connection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2386);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2383);
        attribute_instance(); 
      }
      setState(2388);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx);
    }
    setState(2390);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281474977824772) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 1098706452503) != 0) {
      setState(2389);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Named_port_connectionContext ------------------------------------------------------------------

VerilogParser::Named_port_connectionContext::Named_port_connectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Named_port_connectionContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Port_identifierContext* VerilogParser::Named_port_connectionContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Named_port_connectionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Named_port_connectionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Named_port_connectionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Named_port_connectionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::ExpressionContext* VerilogParser::Named_port_connectionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Named_port_connectionContext::getRuleIndex() const {
  return VerilogParser::RuleNamed_port_connection;
}


std::any VerilogParser::Named_port_connectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNamed_port_connection(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Named_port_connectionContext* VerilogParser::named_port_connection() {
  Named_port_connectionContext *_localctx = _tracker.createInstance<Named_port_connectionContext>(_ctx, getState());
  enterRule(_localctx, 264, VerilogParser::RuleNamed_port_connection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2395);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(2392);
      attribute_instance();
      setState(2397);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2398);
    match(VerilogParser::DT);
    setState(2399);
    port_identifier();
    setState(2400);
    match(VerilogParser::LP);
    setState(2402);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281474977824772) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 1098706452503) != 0) {
      setState(2401);
      expression(0);
    }
    setState(2404);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_regionContext ------------------------------------------------------------------

VerilogParser::Generate_regionContext::Generate_regionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Generate_regionContext::GENERATE() {
  return getToken(VerilogParser::GENERATE, 0);
}

tree::TerminalNode* VerilogParser::Generate_regionContext::ENDGENERATE() {
  return getToken(VerilogParser::ENDGENERATE, 0);
}

std::vector<VerilogParser::Module_or_generate_itemContext *> VerilogParser::Generate_regionContext::module_or_generate_item() {
  return getRuleContexts<VerilogParser::Module_or_generate_itemContext>();
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::Generate_regionContext::module_or_generate_item(size_t i) {
  return getRuleContext<VerilogParser::Module_or_generate_itemContext>(i);
}


size_t VerilogParser::Generate_regionContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_region;
}


std::any VerilogParser::Generate_regionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_region(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_regionContext* VerilogParser::generate_region() {
  Generate_regionContext *_localctx = _tracker.createInstance<Generate_regionContext>(_ctx, getState());
  enterRule(_localctx, 266, VerilogParser::RuleGenerate_region);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2406);
    match(VerilogParser::GENERATE);
    setState(2410);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 277013026) != 0 || (((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & -6620625700539268829) != 0 || (((_la - 135) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 135)) & 4772763370820472655) != 0) {
      setState(2407);
      module_or_generate_item();
      setState(2412);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2413);
    match(VerilogParser::ENDGENERATE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_declarationContext ------------------------------------------------------------------

VerilogParser::Genvar_declarationContext::Genvar_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Genvar_declarationContext::GENVAR() {
  return getToken(VerilogParser::GENVAR, 0);
}

VerilogParser::List_of_genvar_identifiersContext* VerilogParser::Genvar_declarationContext::list_of_genvar_identifiers() {
  return getRuleContext<VerilogParser::List_of_genvar_identifiersContext>(0);
}

tree::TerminalNode* VerilogParser::Genvar_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Genvar_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_declaration;
}


std::any VerilogParser::Genvar_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_declarationContext* VerilogParser::genvar_declaration() {
  Genvar_declarationContext *_localctx = _tracker.createInstance<Genvar_declarationContext>(_ctx, getState());
  enterRule(_localctx, 268, VerilogParser::RuleGenvar_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2415);
    match(VerilogParser::GENVAR);
    setState(2416);
    list_of_genvar_identifiers();
    setState(2417);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_genvar_identifiersContext ------------------------------------------------------------------

VerilogParser::List_of_genvar_identifiersContext::List_of_genvar_identifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Genvar_identifierContext *> VerilogParser::List_of_genvar_identifiersContext::genvar_identifier() {
  return getRuleContexts<VerilogParser::Genvar_identifierContext>();
}

VerilogParser::Genvar_identifierContext* VerilogParser::List_of_genvar_identifiersContext::genvar_identifier(size_t i) {
  return getRuleContext<VerilogParser::Genvar_identifierContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_genvar_identifiersContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_genvar_identifiersContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_genvar_identifiersContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_genvar_identifiers;
}


std::any VerilogParser::List_of_genvar_identifiersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_genvar_identifiers(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_genvar_identifiersContext* VerilogParser::list_of_genvar_identifiers() {
  List_of_genvar_identifiersContext *_localctx = _tracker.createInstance<List_of_genvar_identifiersContext>(_ctx, getState());
  enterRule(_localctx, 270, VerilogParser::RuleList_of_genvar_identifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2419);
    genvar_identifier();
    setState(2424);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2420);
      match(VerilogParser::CO);
      setState(2421);
      genvar_identifier();
      setState(2426);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_generate_constructContext ------------------------------------------------------------------

VerilogParser::Loop_generate_constructContext::Loop_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::FOR() {
  return getToken(VerilogParser::FOR, 0);
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Genvar_initializationContext* VerilogParser::Loop_generate_constructContext::genvar_initialization() {
  return getRuleContext<VerilogParser::Genvar_initializationContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Loop_generate_constructContext::SC() {
  return getTokens(VerilogParser::SC);
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::SC(size_t i) {
  return getToken(VerilogParser::SC, i);
}

VerilogParser::Genvar_expressionContext* VerilogParser::Loop_generate_constructContext::genvar_expression() {
  return getRuleContext<VerilogParser::Genvar_expressionContext>(0);
}

VerilogParser::Genvar_iterationContext* VerilogParser::Loop_generate_constructContext::genvar_iteration() {
  return getRuleContext<VerilogParser::Genvar_iterationContext>(0);
}

tree::TerminalNode* VerilogParser::Loop_generate_constructContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Generate_blockContext* VerilogParser::Loop_generate_constructContext::generate_block() {
  return getRuleContext<VerilogParser::Generate_blockContext>(0);
}


size_t VerilogParser::Loop_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleLoop_generate_construct;
}


std::any VerilogParser::Loop_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLoop_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Loop_generate_constructContext* VerilogParser::loop_generate_construct() {
  Loop_generate_constructContext *_localctx = _tracker.createInstance<Loop_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 272, VerilogParser::RuleLoop_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2427);
    match(VerilogParser::FOR);
    setState(2428);
    match(VerilogParser::LP);
    setState(2429);
    genvar_initialization();
    setState(2430);
    match(VerilogParser::SC);
    setState(2431);
    genvar_expression();
    setState(2432);
    match(VerilogParser::SC);
    setState(2433);
    genvar_iteration();
    setState(2434);
    match(VerilogParser::RP);
    setState(2435);
    generate_block();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_initializationContext ------------------------------------------------------------------

VerilogParser::Genvar_initializationContext::Genvar_initializationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Genvar_identifierContext* VerilogParser::Genvar_initializationContext::genvar_identifier() {
  return getRuleContext<VerilogParser::Genvar_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Genvar_initializationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Genvar_initializationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Genvar_initializationContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_initialization;
}


std::any VerilogParser::Genvar_initializationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_initialization(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_initializationContext* VerilogParser::genvar_initialization() {
  Genvar_initializationContext *_localctx = _tracker.createInstance<Genvar_initializationContext>(_ctx, getState());
  enterRule(_localctx, 274, VerilogParser::RuleGenvar_initialization);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2437);
    genvar_identifier();
    setState(2438);
    match(VerilogParser::EQ);
    setState(2439);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_expressionContext ------------------------------------------------------------------

VerilogParser::Genvar_expressionContext::Genvar_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Genvar_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Genvar_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_expression;
}


std::any VerilogParser::Genvar_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_expressionContext* VerilogParser::genvar_expression() {
  Genvar_expressionContext *_localctx = _tracker.createInstance<Genvar_expressionContext>(_ctx, getState());
  enterRule(_localctx, 276, VerilogParser::RuleGenvar_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2441);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_iterationContext ------------------------------------------------------------------

VerilogParser::Genvar_iterationContext::Genvar_iterationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Genvar_identifierContext* VerilogParser::Genvar_iterationContext::genvar_identifier() {
  return getRuleContext<VerilogParser::Genvar_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Genvar_iterationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Genvar_expressionContext* VerilogParser::Genvar_iterationContext::genvar_expression() {
  return getRuleContext<VerilogParser::Genvar_expressionContext>(0);
}


size_t VerilogParser::Genvar_iterationContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_iteration;
}


std::any VerilogParser::Genvar_iterationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_iteration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_iterationContext* VerilogParser::genvar_iteration() {
  Genvar_iterationContext *_localctx = _tracker.createInstance<Genvar_iterationContext>(_ctx, getState());
  enterRule(_localctx, 278, VerilogParser::RuleGenvar_iteration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2443);
    genvar_identifier();
    setState(2444);
    match(VerilogParser::EQ);
    setState(2445);
    genvar_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_generate_constructContext ------------------------------------------------------------------

VerilogParser::Conditional_generate_constructContext::Conditional_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::If_generate_constructContext* VerilogParser::Conditional_generate_constructContext::if_generate_construct() {
  return getRuleContext<VerilogParser::If_generate_constructContext>(0);
}

VerilogParser::Case_generate_constructContext* VerilogParser::Conditional_generate_constructContext::case_generate_construct() {
  return getRuleContext<VerilogParser::Case_generate_constructContext>(0);
}


size_t VerilogParser::Conditional_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleConditional_generate_construct;
}


std::any VerilogParser::Conditional_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConditional_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Conditional_generate_constructContext* VerilogParser::conditional_generate_construct() {
  Conditional_generate_constructContext *_localctx = _tracker.createInstance<Conditional_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 280, VerilogParser::RuleConditional_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2449);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(2447);
        if_generate_construct();
        break;
      }

      case VerilogParser::CASE: {
        enterOuterAlt(_localctx, 2);
        setState(2448);
        case_generate_construct();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- If_generate_constructContext ------------------------------------------------------------------

VerilogParser::If_generate_constructContext::If_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::IF() {
  return getToken(VerilogParser::IF, 0);
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::If_generate_constructContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Generate_block_or_nullContext *> VerilogParser::If_generate_constructContext::generate_block_or_null() {
  return getRuleContexts<VerilogParser::Generate_block_or_nullContext>();
}

VerilogParser::Generate_block_or_nullContext* VerilogParser::If_generate_constructContext::generate_block_or_null(size_t i) {
  return getRuleContext<VerilogParser::Generate_block_or_nullContext>(i);
}

tree::TerminalNode* VerilogParser::If_generate_constructContext::ELSE() {
  return getToken(VerilogParser::ELSE, 0);
}


size_t VerilogParser::If_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleIf_generate_construct;
}


std::any VerilogParser::If_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitIf_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::If_generate_constructContext* VerilogParser::if_generate_construct() {
  If_generate_constructContext *_localctx = _tracker.createInstance<If_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 282, VerilogParser::RuleIf_generate_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2451);
    match(VerilogParser::IF);
    setState(2452);
    match(VerilogParser::LP);
    setState(2453);
    constant_expression(0);
    setState(2454);
    match(VerilogParser::RP);
    setState(2455);
    generate_block_or_null();
    setState(2458);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
    case 1: {
      setState(2456);
      match(VerilogParser::ELSE);
      setState(2457);
      generate_block_or_null();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_generate_constructContext ------------------------------------------------------------------

VerilogParser::Case_generate_constructContext::Case_generate_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::CASE() {
  return getToken(VerilogParser::CASE, 0);
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Case_generate_constructContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Case_generate_constructContext::ENDCASE() {
  return getToken(VerilogParser::ENDCASE, 0);
}

std::vector<VerilogParser::Case_generate_itemContext *> VerilogParser::Case_generate_constructContext::case_generate_item() {
  return getRuleContexts<VerilogParser::Case_generate_itemContext>();
}

VerilogParser::Case_generate_itemContext* VerilogParser::Case_generate_constructContext::case_generate_item(size_t i) {
  return getRuleContext<VerilogParser::Case_generate_itemContext>(i);
}


size_t VerilogParser::Case_generate_constructContext::getRuleIndex() const {
  return VerilogParser::RuleCase_generate_construct;
}


std::any VerilogParser::Case_generate_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_generate_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_generate_constructContext* VerilogParser::case_generate_construct() {
  Case_generate_constructContext *_localctx = _tracker.createInstance<Case_generate_constructContext>(_ctx, getState());
  enterRule(_localctx, 284, VerilogParser::RuleCase_generate_construct);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2460);
    match(VerilogParser::CASE);
    setState(2461);
    match(VerilogParser::LP);
    setState(2462);
    constant_expression(0);
    setState(2463);
    match(VerilogParser::RP);
    setState(2465); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2464);
      case_generate_item();
      setState(2467); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281475112042500) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 1098706452503) != 0);
    setState(2469);
    match(VerilogParser::ENDCASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_generate_itemContext ------------------------------------------------------------------

VerilogParser::Case_generate_itemContext::Case_generate_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Case_generate_itemContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Case_generate_itemContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Case_generate_itemContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Generate_block_or_nullContext* VerilogParser::Case_generate_itemContext::generate_block_or_null() {
  return getRuleContext<VerilogParser::Generate_block_or_nullContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Case_generate_itemContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Case_generate_itemContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

tree::TerminalNode* VerilogParser::Case_generate_itemContext::DEFAULT() {
  return getToken(VerilogParser::DEFAULT, 0);
}


size_t VerilogParser::Case_generate_itemContext::getRuleIndex() const {
  return VerilogParser::RuleCase_generate_item;
}


std::any VerilogParser::Case_generate_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_generate_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_generate_itemContext* VerilogParser::case_generate_item() {
  Case_generate_itemContext *_localctx = _tracker.createInstance<Case_generate_itemContext>(_ctx, getState());
  enterRule(_localctx, 286, VerilogParser::RuleCase_generate_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2487);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::CATI:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(2471);
        constant_expression(0);
        setState(2476);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(2472);
          match(VerilogParser::CO);
          setState(2473);
          constant_expression(0);
          setState(2478);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2479);
        match(VerilogParser::CL);
        setState(2480);
        generate_block_or_null();
        break;
      }

      case VerilogParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(2482);
        match(VerilogParser::DEFAULT);
        setState(2484);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CL) {
          setState(2483);
          match(VerilogParser::CL);
        }
        setState(2486);
        generate_block_or_null();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_blockContext ------------------------------------------------------------------

VerilogParser::Generate_blockContext::Generate_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Module_or_generate_itemContext *> VerilogParser::Generate_blockContext::module_or_generate_item() {
  return getRuleContexts<VerilogParser::Module_or_generate_itemContext>();
}

VerilogParser::Module_or_generate_itemContext* VerilogParser::Generate_blockContext::module_or_generate_item(size_t i) {
  return getRuleContext<VerilogParser::Module_or_generate_itemContext>(i);
}

tree::TerminalNode* VerilogParser::Generate_blockContext::BEGIN() {
  return getToken(VerilogParser::BEGIN, 0);
}

tree::TerminalNode* VerilogParser::Generate_blockContext::END() {
  return getToken(VerilogParser::END, 0);
}

VerilogParser::Generate_block_nameContext* VerilogParser::Generate_blockContext::generate_block_name() {
  return getRuleContext<VerilogParser::Generate_block_nameContext>(0);
}


size_t VerilogParser::Generate_blockContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block;
}


std::any VerilogParser::Generate_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_blockContext* VerilogParser::generate_block() {
  Generate_blockContext *_localctx = _tracker.createInstance<Generate_blockContext>(_ctx, getState());
  enterRule(_localctx, 288, VerilogParser::RuleGenerate_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2501);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ALWAYS:
      case VerilogParser::AND:
      case VerilogParser::ASSIGN:
      case VerilogParser::BUF:
      case VerilogParser::BUFIFONE:
      case VerilogParser::BUFIFZERO:
      case VerilogParser::CASE:
      case VerilogParser::CMOS:
      case VerilogParser::DEFPARAM:
      case VerilogParser::EVENT:
      case VerilogParser::FOR:
      case VerilogParser::FUNCTION:
      case VerilogParser::GENVAR:
      case VerilogParser::IF:
      case VerilogParser::INITIAL:
      case VerilogParser::INTEGER:
      case VerilogParser::LOCALPARAM:
      case VerilogParser::LP:
      case VerilogParser::NAND:
      case VerilogParser::NMOS:
      case VerilogParser::NOR:
      case VerilogParser::NOT:
      case VerilogParser::NOTIFONE:
      case VerilogParser::NOTIFZERO:
      case VerilogParser::OR:
      case VerilogParser::PMOS:
      case VerilogParser::PULLDOWN:
      case VerilogParser::PULLUP:
      case VerilogParser::RCMOS:
      case VerilogParser::REAL:
      case VerilogParser::REALTIME:
      case VerilogParser::REG:
      case VerilogParser::RNMOS:
      case VerilogParser::RPMOS:
      case VerilogParser::RTRAN:
      case VerilogParser::RTRANIFONE:
      case VerilogParser::RTRANIFZERO:
      case VerilogParser::SUPPLYONE:
      case VerilogParser::SUPPLYZERO:
      case VerilogParser::TASK:
      case VerilogParser::TIME:
      case VerilogParser::TRAN:
      case VerilogParser::TRANIFONE:
      case VerilogParser::TRANIFZERO:
      case VerilogParser::TRI:
      case VerilogParser::TRIAND:
      case VerilogParser::TRIONE:
      case VerilogParser::TRIOR:
      case VerilogParser::TRIREG:
      case VerilogParser::TRIZERO:
      case VerilogParser::UWIRE:
      case VerilogParser::WAND:
      case VerilogParser::WIRE:
      case VerilogParser::WOR:
      case VerilogParser::XNOR:
      case VerilogParser::XOR:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2489);
        module_or_generate_item();
        break;
      }

      case VerilogParser::BEGIN: {
        enterOuterAlt(_localctx, 2);
        setState(2490);
        match(VerilogParser::BEGIN);
        setState(2492);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CL) {
          setState(2491);
          generate_block_name();
        }
        setState(2497);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 277013026) != 0 || (((_la - 65) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 65)) & -6620625700539268829) != 0 || (((_la - 135) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 135)) & 4772763370820472655) != 0) {
          setState(2494);
          module_or_generate_item();
          setState(2499);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(2500);
        match(VerilogParser::END);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_block_nameContext ------------------------------------------------------------------

VerilogParser::Generate_block_nameContext::Generate_block_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Generate_block_nameContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Generate_block_identifierContext* VerilogParser::Generate_block_nameContext::generate_block_identifier() {
  return getRuleContext<VerilogParser::Generate_block_identifierContext>(0);
}


size_t VerilogParser::Generate_block_nameContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block_name;
}


std::any VerilogParser::Generate_block_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_block_nameContext* VerilogParser::generate_block_name() {
  Generate_block_nameContext *_localctx = _tracker.createInstance<Generate_block_nameContext>(_ctx, getState());
  enterRule(_localctx, 290, VerilogParser::RuleGenerate_block_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2503);
    match(VerilogParser::CL);
    setState(2504);
    generate_block_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_block_or_nullContext ------------------------------------------------------------------

VerilogParser::Generate_block_or_nullContext::Generate_block_or_nullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Generate_blockContext* VerilogParser::Generate_block_or_nullContext::generate_block() {
  return getRuleContext<VerilogParser::Generate_blockContext>(0);
}

tree::TerminalNode* VerilogParser::Generate_block_or_nullContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Generate_block_or_nullContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block_or_null;
}


std::any VerilogParser::Generate_block_or_nullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block_or_null(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_block_or_nullContext* VerilogParser::generate_block_or_null() {
  Generate_block_or_nullContext *_localctx = _tracker.createInstance<Generate_block_or_nullContext>(_ctx, getState());
  enterRule(_localctx, 292, VerilogParser::RuleGenerate_block_or_null);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2508);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ALWAYS:
      case VerilogParser::AND:
      case VerilogParser::ASSIGN:
      case VerilogParser::BEGIN:
      case VerilogParser::BUF:
      case VerilogParser::BUFIFONE:
      case VerilogParser::BUFIFZERO:
      case VerilogParser::CASE:
      case VerilogParser::CMOS:
      case VerilogParser::DEFPARAM:
      case VerilogParser::EVENT:
      case VerilogParser::FOR:
      case VerilogParser::FUNCTION:
      case VerilogParser::GENVAR:
      case VerilogParser::IF:
      case VerilogParser::INITIAL:
      case VerilogParser::INTEGER:
      case VerilogParser::LOCALPARAM:
      case VerilogParser::LP:
      case VerilogParser::NAND:
      case VerilogParser::NMOS:
      case VerilogParser::NOR:
      case VerilogParser::NOT:
      case VerilogParser::NOTIFONE:
      case VerilogParser::NOTIFZERO:
      case VerilogParser::OR:
      case VerilogParser::PMOS:
      case VerilogParser::PULLDOWN:
      case VerilogParser::PULLUP:
      case VerilogParser::RCMOS:
      case VerilogParser::REAL:
      case VerilogParser::REALTIME:
      case VerilogParser::REG:
      case VerilogParser::RNMOS:
      case VerilogParser::RPMOS:
      case VerilogParser::RTRAN:
      case VerilogParser::RTRANIFONE:
      case VerilogParser::RTRANIFZERO:
      case VerilogParser::SUPPLYONE:
      case VerilogParser::SUPPLYZERO:
      case VerilogParser::TASK:
      case VerilogParser::TIME:
      case VerilogParser::TRAN:
      case VerilogParser::TRANIFONE:
      case VerilogParser::TRANIFZERO:
      case VerilogParser::TRI:
      case VerilogParser::TRIAND:
      case VerilogParser::TRIONE:
      case VerilogParser::TRIOR:
      case VerilogParser::TRIREG:
      case VerilogParser::TRIZERO:
      case VerilogParser::UWIRE:
      case VerilogParser::WAND:
      case VerilogParser::WIRE:
      case VerilogParser::WOR:
      case VerilogParser::XNOR:
      case VerilogParser::XOR:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2506);
        generate_block();
        break;
      }

      case VerilogParser::SC: {
        enterOuterAlt(_localctx, 2);
        setState(2507);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_declarationContext::Udp_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::PRIMITIVE() {
  return getToken(VerilogParser::PRIMITIVE, 0);
}

VerilogParser::Udp_identifierContext* VerilogParser::Udp_declarationContext::udp_identifier() {
  return getRuleContext<VerilogParser::Udp_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Udp_port_listContext* VerilogParser::Udp_declarationContext::udp_port_list() {
  return getRuleContext<VerilogParser::Udp_port_listContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Udp_bodyContext* VerilogParser::Udp_declarationContext::udp_body() {
  return getRuleContext<VerilogParser::Udp_bodyContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_declarationContext::ENDPRIMITIVE() {
  return getToken(VerilogParser::ENDPRIMITIVE, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::Udp_port_declarationContext *> VerilogParser::Udp_declarationContext::udp_port_declaration() {
  return getRuleContexts<VerilogParser::Udp_port_declarationContext>();
}

VerilogParser::Udp_port_declarationContext* VerilogParser::Udp_declarationContext::udp_port_declaration(size_t i) {
  return getRuleContext<VerilogParser::Udp_port_declarationContext>(i);
}

VerilogParser::Udp_declaration_port_listContext* VerilogParser::Udp_declarationContext::udp_declaration_port_list() {
  return getRuleContext<VerilogParser::Udp_declaration_port_listContext>(0);
}


size_t VerilogParser::Udp_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_declaration;
}


std::any VerilogParser::Udp_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_declarationContext* VerilogParser::udp_declaration() {
  Udp_declarationContext *_localctx = _tracker.createInstance<Udp_declarationContext>(_ctx, getState());
  enterRule(_localctx, 294, VerilogParser::RuleUdp_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2545);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2513);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2510);
        attribute_instance();
        setState(2515);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2516);
      match(VerilogParser::PRIMITIVE);
      setState(2517);
      udp_identifier();
      setState(2518);
      match(VerilogParser::LP);
      setState(2519);
      udp_port_list();
      setState(2520);
      match(VerilogParser::RP);
      setState(2521);
      match(VerilogParser::SC);
      setState(2523); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(2522);
        udp_port_declaration();
        setState(2525); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while ((((_la - 86) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 86)) & 4503603922338817) != 0);
      setState(2527);
      udp_body();
      setState(2528);
      match(VerilogParser::ENDPRIMITIVE);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2533);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2530);
        attribute_instance();
        setState(2535);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2536);
      match(VerilogParser::PRIMITIVE);
      setState(2537);
      udp_identifier();
      setState(2538);
      match(VerilogParser::LP);
      setState(2539);
      udp_declaration_port_list();
      setState(2540);
      match(VerilogParser::RP);
      setState(2541);
      match(VerilogParser::SC);
      setState(2542);
      udp_body();
      setState(2543);
      match(VerilogParser::ENDPRIMITIVE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_port_listContext ------------------------------------------------------------------

VerilogParser::Udp_port_listContext::Udp_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Output_port_identifierContext* VerilogParser::Udp_port_listContext::output_port_identifier() {
  return getRuleContext<VerilogParser::Output_port_identifierContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Input_port_identifierContext *> VerilogParser::Udp_port_listContext::input_port_identifier() {
  return getRuleContexts<VerilogParser::Input_port_identifierContext>();
}

VerilogParser::Input_port_identifierContext* VerilogParser::Udp_port_listContext::input_port_identifier(size_t i) {
  return getRuleContext<VerilogParser::Input_port_identifierContext>(i);
}


size_t VerilogParser::Udp_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_port_list;
}


std::any VerilogParser::Udp_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_port_listContext* VerilogParser::udp_port_list() {
  Udp_port_listContext *_localctx = _tracker.createInstance<Udp_port_listContext>(_ctx, getState());
  enterRule(_localctx, 296, VerilogParser::RuleUdp_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2547);
    output_port_identifier();
    setState(2548);
    match(VerilogParser::CO);
    setState(2549);
    input_port_identifier();
    setState(2554);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2550);
      match(VerilogParser::CO);
      setState(2551);
      input_port_identifier();
      setState(2556);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_declaration_port_listContext ------------------------------------------------------------------

VerilogParser::Udp_declaration_port_listContext::Udp_declaration_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_output_declarationContext* VerilogParser::Udp_declaration_port_listContext::udp_output_declaration() {
  return getRuleContext<VerilogParser::Udp_output_declarationContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_declaration_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_declaration_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Udp_input_declarationContext *> VerilogParser::Udp_declaration_port_listContext::udp_input_declaration() {
  return getRuleContexts<VerilogParser::Udp_input_declarationContext>();
}

VerilogParser::Udp_input_declarationContext* VerilogParser::Udp_declaration_port_listContext::udp_input_declaration(size_t i) {
  return getRuleContext<VerilogParser::Udp_input_declarationContext>(i);
}


size_t VerilogParser::Udp_declaration_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_declaration_port_list;
}


std::any VerilogParser::Udp_declaration_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_declaration_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_declaration_port_listContext* VerilogParser::udp_declaration_port_list() {
  Udp_declaration_port_listContext *_localctx = _tracker.createInstance<Udp_declaration_port_listContext>(_ctx, getState());
  enterRule(_localctx, 298, VerilogParser::RuleUdp_declaration_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2557);
    udp_output_declaration();
    setState(2558);
    match(VerilogParser::CO);
    setState(2559);
    udp_input_declaration();
    setState(2564);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2560);
      match(VerilogParser::CO);
      setState(2561);
      udp_input_declaration();
      setState(2566);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_port_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_port_declarationContext::Udp_port_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_output_declarationContext* VerilogParser::Udp_port_declarationContext::udp_output_declaration() {
  return getRuleContext<VerilogParser::Udp_output_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_port_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Udp_input_declarationContext* VerilogParser::Udp_port_declarationContext::udp_input_declaration() {
  return getRuleContext<VerilogParser::Udp_input_declarationContext>(0);
}

VerilogParser::Udp_reg_declarationContext* VerilogParser::Udp_port_declarationContext::udp_reg_declaration() {
  return getRuleContext<VerilogParser::Udp_reg_declarationContext>(0);
}


size_t VerilogParser::Udp_port_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_port_declaration;
}


std::any VerilogParser::Udp_port_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_port_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_port_declarationContext* VerilogParser::udp_port_declaration() {
  Udp_port_declarationContext *_localctx = _tracker.createInstance<Udp_port_declarationContext>(_ctx, getState());
  enterRule(_localctx, 300, VerilogParser::RuleUdp_port_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2576);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2567);
      udp_output_declaration();
      setState(2568);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2570);
      udp_input_declaration();
      setState(2571);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2573);
      udp_reg_declaration();
      setState(2574);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_output_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_output_declarationContext::Udp_output_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_output_declarationContext::OUTPUT() {
  return getToken(VerilogParser::OUTPUT, 0);
}

VerilogParser::Port_identifierContext* VerilogParser::Udp_output_declarationContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_output_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_output_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Udp_output_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

tree::TerminalNode* VerilogParser::Udp_output_declarationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Udp_output_declarationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Udp_output_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_output_declaration;
}


std::any VerilogParser::Udp_output_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_output_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_output_declarationContext* VerilogParser::udp_output_declaration() {
  Udp_output_declarationContext *_localctx = _tracker.createInstance<Udp_output_declarationContext>(_ctx, getState());
  enterRule(_localctx, 302, VerilogParser::RuleUdp_output_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2599);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2581);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2578);
        attribute_instance();
        setState(2583);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2584);
      match(VerilogParser::OUTPUT);
      setState(2585);
      port_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2589);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2586);
        attribute_instance();
        setState(2591);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2592);
      match(VerilogParser::OUTPUT);
      setState(2593);
      match(VerilogParser::REG);
      setState(2594);
      port_identifier();
      setState(2597);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::EQ) {
        setState(2595);
        match(VerilogParser::EQ);
        setState(2596);
        constant_expression(0);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_input_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_input_declarationContext::Udp_input_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_input_declarationContext::INPUT() {
  return getToken(VerilogParser::INPUT, 0);
}

VerilogParser::List_of_port_identifiersContext* VerilogParser::Udp_input_declarationContext::list_of_port_identifiers() {
  return getRuleContext<VerilogParser::List_of_port_identifiersContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_input_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_input_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Udp_input_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_input_declaration;
}


std::any VerilogParser::Udp_input_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_input_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_input_declarationContext* VerilogParser::udp_input_declaration() {
  Udp_input_declarationContext *_localctx = _tracker.createInstance<Udp_input_declarationContext>(_ctx, getState());
  enterRule(_localctx, 304, VerilogParser::RuleUdp_input_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2604);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(2601);
      attribute_instance();
      setState(2606);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2607);
    match(VerilogParser::INPUT);
    setState(2608);
    list_of_port_identifiers();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_reg_declarationContext ------------------------------------------------------------------

VerilogParser::Udp_reg_declarationContext::Udp_reg_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_reg_declarationContext::REG() {
  return getToken(VerilogParser::REG, 0);
}

VerilogParser::Variable_identifierContext* VerilogParser::Udp_reg_declarationContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Udp_reg_declarationContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Udp_reg_declarationContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Udp_reg_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_reg_declaration;
}


std::any VerilogParser::Udp_reg_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_reg_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_reg_declarationContext* VerilogParser::udp_reg_declaration() {
  Udp_reg_declarationContext *_localctx = _tracker.createInstance<Udp_reg_declarationContext>(_ctx, getState());
  enterRule(_localctx, 306, VerilogParser::RuleUdp_reg_declaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2613);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LP) {
      setState(2610);
      attribute_instance();
      setState(2615);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2616);
    match(VerilogParser::REG);
    setState(2617);
    variable_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_bodyContext ------------------------------------------------------------------

VerilogParser::Udp_bodyContext::Udp_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Combinational_bodyContext* VerilogParser::Udp_bodyContext::combinational_body() {
  return getRuleContext<VerilogParser::Combinational_bodyContext>(0);
}

VerilogParser::Sequential_bodyContext* VerilogParser::Udp_bodyContext::sequential_body() {
  return getRuleContext<VerilogParser::Sequential_bodyContext>(0);
}


size_t VerilogParser::Udp_bodyContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_body;
}


std::any VerilogParser::Udp_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_body(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_bodyContext* VerilogParser::udp_body() {
  Udp_bodyContext *_localctx = _tracker.createInstance<Udp_bodyContext>(_ctx, getState());
  enterRule(_localctx, 308, VerilogParser::RuleUdp_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2621);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2619);
      combinational_body();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2620);
      sequential_body();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Combinational_bodyContext ------------------------------------------------------------------

VerilogParser::Combinational_bodyContext::Combinational_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Combinational_bodyContext::TABLE() {
  return getToken(VerilogParser::TABLE, 0);
}

tree::TerminalNode* VerilogParser::Combinational_bodyContext::ENDTABLE() {
  return getToken(VerilogParser::ENDTABLE, 0);
}

std::vector<VerilogParser::Combinational_entryContext *> VerilogParser::Combinational_bodyContext::combinational_entry() {
  return getRuleContexts<VerilogParser::Combinational_entryContext>();
}

VerilogParser::Combinational_entryContext* VerilogParser::Combinational_bodyContext::combinational_entry(size_t i) {
  return getRuleContext<VerilogParser::Combinational_entryContext>(i);
}


size_t VerilogParser::Combinational_bodyContext::getRuleIndex() const {
  return VerilogParser::RuleCombinational_body;
}


std::any VerilogParser::Combinational_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCombinational_body(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Combinational_bodyContext* VerilogParser::combinational_body() {
  Combinational_bodyContext *_localctx = _tracker.createInstance<Combinational_bodyContext>(_ctx, getState());
  enterRule(_localctx, 310, VerilogParser::RuleCombinational_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2623);
    match(VerilogParser::TABLE);
    setState(2625); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2624);
      combinational_entry();
      setState(2627); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL);
    setState(2629);
    match(VerilogParser::ENDTABLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Combinational_entryContext ------------------------------------------------------------------

VerilogParser::Combinational_entryContext::Combinational_entryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Level_input_listContext* VerilogParser::Combinational_entryContext::level_input_list() {
  return getRuleContext<VerilogParser::Level_input_listContext>(0);
}

tree::TerminalNode* VerilogParser::Combinational_entryContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Output_symbolContext* VerilogParser::Combinational_entryContext::output_symbol() {
  return getRuleContext<VerilogParser::Output_symbolContext>(0);
}

tree::TerminalNode* VerilogParser::Combinational_entryContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Combinational_entryContext::getRuleIndex() const {
  return VerilogParser::RuleCombinational_entry;
}


std::any VerilogParser::Combinational_entryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCombinational_entry(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Combinational_entryContext* VerilogParser::combinational_entry() {
  Combinational_entryContext *_localctx = _tracker.createInstance<Combinational_entryContext>(_ctx, getState());
  enterRule(_localctx, 312, VerilogParser::RuleCombinational_entry);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2631);
    level_input_list();
    setState(2632);
    match(VerilogParser::CL);
    setState(2633);
    output_symbol();
    setState(2634);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequential_bodyContext ------------------------------------------------------------------

VerilogParser::Sequential_bodyContext::Sequential_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Sequential_bodyContext::TABLE() {
  return getToken(VerilogParser::TABLE, 0);
}

tree::TerminalNode* VerilogParser::Sequential_bodyContext::ENDTABLE() {
  return getToken(VerilogParser::ENDTABLE, 0);
}

VerilogParser::Udp_initial_statementContext* VerilogParser::Sequential_bodyContext::udp_initial_statement() {
  return getRuleContext<VerilogParser::Udp_initial_statementContext>(0);
}

std::vector<VerilogParser::Sequential_entryContext *> VerilogParser::Sequential_bodyContext::sequential_entry() {
  return getRuleContexts<VerilogParser::Sequential_entryContext>();
}

VerilogParser::Sequential_entryContext* VerilogParser::Sequential_bodyContext::sequential_entry(size_t i) {
  return getRuleContext<VerilogParser::Sequential_entryContext>(i);
}


size_t VerilogParser::Sequential_bodyContext::getRuleIndex() const {
  return VerilogParser::RuleSequential_body;
}


std::any VerilogParser::Sequential_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSequential_body(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sequential_bodyContext* VerilogParser::sequential_body() {
  Sequential_bodyContext *_localctx = _tracker.createInstance<Sequential_bodyContext>(_ctx, getState());
  enterRule(_localctx, 314, VerilogParser::RuleSequential_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2637);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::INITIAL) {
      setState(2636);
      udp_initial_statement();
    }
    setState(2639);
    match(VerilogParser::TABLE);
    setState(2641); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2640);
      sequential_entry();
      setState(2643); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == VerilogParser::LP || (((_la - 208) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 208)) & 7) != 0);
    setState(2645);
    match(VerilogParser::ENDTABLE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_initial_statementContext ------------------------------------------------------------------

VerilogParser::Udp_initial_statementContext::Udp_initial_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_initial_statementContext::INITIAL() {
  return getToken(VerilogParser::INITIAL, 0);
}

VerilogParser::Output_port_identifierContext* VerilogParser::Udp_initial_statementContext::output_port_identifier() {
  return getRuleContext<VerilogParser::Output_port_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_initial_statementContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Init_valContext* VerilogParser::Udp_initial_statementContext::init_val() {
  return getRuleContext<VerilogParser::Init_valContext>(0);
}

tree::TerminalNode* VerilogParser::Udp_initial_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Udp_initial_statementContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_initial_statement;
}


std::any VerilogParser::Udp_initial_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_initial_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_initial_statementContext* VerilogParser::udp_initial_statement() {
  Udp_initial_statementContext *_localctx = _tracker.createInstance<Udp_initial_statementContext>(_ctx, getState());
  enterRule(_localctx, 316, VerilogParser::RuleUdp_initial_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2647);
    match(VerilogParser::INITIAL);
    setState(2648);
    output_port_identifier();
    setState(2649);
    match(VerilogParser::EQ);
    setState(2650);
    init_val();
    setState(2651);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Init_valContext ------------------------------------------------------------------

VerilogParser::Init_valContext::Init_valContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Binary_numberContext* VerilogParser::Init_valContext::binary_number() {
  return getRuleContext<VerilogParser::Binary_numberContext>(0);
}

VerilogParser::Unsigned_numberContext* VerilogParser::Init_valContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}


size_t VerilogParser::Init_valContext::getRuleIndex() const {
  return VerilogParser::RuleInit_val;
}


std::any VerilogParser::Init_valContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInit_val(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Init_valContext* VerilogParser::init_val() {
  Init_valContext *_localctx = _tracker.createInstance<Init_valContext>(_ctx, getState());
  enterRule(_localctx, 318, VerilogParser::RuleInit_val);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2655);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2653);
      binary_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2654);
      unsigned_number();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sequential_entryContext ------------------------------------------------------------------

VerilogParser::Sequential_entryContext::Sequential_entryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Seq_input_listContext* VerilogParser::Sequential_entryContext::seq_input_list() {
  return getRuleContext<VerilogParser::Seq_input_listContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Sequential_entryContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Sequential_entryContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}

VerilogParser::Current_stateContext* VerilogParser::Sequential_entryContext::current_state() {
  return getRuleContext<VerilogParser::Current_stateContext>(0);
}

VerilogParser::Next_stateContext* VerilogParser::Sequential_entryContext::next_state() {
  return getRuleContext<VerilogParser::Next_stateContext>(0);
}

tree::TerminalNode* VerilogParser::Sequential_entryContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Sequential_entryContext::getRuleIndex() const {
  return VerilogParser::RuleSequential_entry;
}


std::any VerilogParser::Sequential_entryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSequential_entry(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sequential_entryContext* VerilogParser::sequential_entry() {
  Sequential_entryContext *_localctx = _tracker.createInstance<Sequential_entryContext>(_ctx, getState());
  enterRule(_localctx, 320, VerilogParser::RuleSequential_entry);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2657);
    seq_input_list();
    setState(2658);
    match(VerilogParser::CL);
    setState(2659);
    current_state();
    setState(2660);
    match(VerilogParser::CL);
    setState(2661);
    next_state();
    setState(2662);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Seq_input_listContext ------------------------------------------------------------------

VerilogParser::Seq_input_listContext::Seq_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Level_input_listContext* VerilogParser::Seq_input_listContext::level_input_list() {
  return getRuleContext<VerilogParser::Level_input_listContext>(0);
}

VerilogParser::Edge_input_listContext* VerilogParser::Seq_input_listContext::edge_input_list() {
  return getRuleContext<VerilogParser::Edge_input_listContext>(0);
}


size_t VerilogParser::Seq_input_listContext::getRuleIndex() const {
  return VerilogParser::RuleSeq_input_list;
}


std::any VerilogParser::Seq_input_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSeq_input_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Seq_input_listContext* VerilogParser::seq_input_list() {
  Seq_input_listContext *_localctx = _tracker.createInstance<Seq_input_listContext>(_ctx, getState());
  enterRule(_localctx, 322, VerilogParser::RuleSeq_input_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2666);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2664);
      level_input_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2665);
      edge_input_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Level_input_listContext ------------------------------------------------------------------

VerilogParser::Level_input_listContext::Level_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Level_symbolContext *> VerilogParser::Level_input_listContext::level_symbol() {
  return getRuleContexts<VerilogParser::Level_symbolContext>();
}

VerilogParser::Level_symbolContext* VerilogParser::Level_input_listContext::level_symbol(size_t i) {
  return getRuleContext<VerilogParser::Level_symbolContext>(i);
}


size_t VerilogParser::Level_input_listContext::getRuleIndex() const {
  return VerilogParser::RuleLevel_input_list;
}


std::any VerilogParser::Level_input_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLevel_input_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Level_input_listContext* VerilogParser::level_input_list() {
  Level_input_listContext *_localctx = _tracker.createInstance<Level_input_listContext>(_ctx, getState());
  enterRule(_localctx, 324, VerilogParser::RuleLevel_input_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2669); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2668);
      level_symbol();
      setState(2671); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_input_listContext ------------------------------------------------------------------

VerilogParser::Edge_input_listContext::Edge_input_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Edge_indicatorContext* VerilogParser::Edge_input_listContext::edge_indicator() {
  return getRuleContext<VerilogParser::Edge_indicatorContext>(0);
}

std::vector<VerilogParser::Level_symbolContext *> VerilogParser::Edge_input_listContext::level_symbol() {
  return getRuleContexts<VerilogParser::Level_symbolContext>();
}

VerilogParser::Level_symbolContext* VerilogParser::Edge_input_listContext::level_symbol(size_t i) {
  return getRuleContext<VerilogParser::Level_symbolContext>(i);
}


size_t VerilogParser::Edge_input_listContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_input_list;
}


std::any VerilogParser::Edge_input_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_input_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_input_listContext* VerilogParser::edge_input_list() {
  Edge_input_listContext *_localctx = _tracker.createInstance<Edge_input_listContext>(_ctx, getState());
  enterRule(_localctx, 326, VerilogParser::RuleEdge_input_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2676);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL) {
      setState(2673);
      level_symbol();
      setState(2678);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2679);
    edge_indicator();
    setState(2683);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL) {
      setState(2680);
      level_symbol();
      setState(2685);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_indicatorContext ------------------------------------------------------------------

VerilogParser::Edge_indicatorContext::Edge_indicatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_indicatorContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Level_symbolContext *> VerilogParser::Edge_indicatorContext::level_symbol() {
  return getRuleContexts<VerilogParser::Level_symbolContext>();
}

VerilogParser::Level_symbolContext* VerilogParser::Edge_indicatorContext::level_symbol(size_t i) {
  return getRuleContext<VerilogParser::Level_symbolContext>(i);
}

tree::TerminalNode* VerilogParser::Edge_indicatorContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Edge_symbolContext* VerilogParser::Edge_indicatorContext::edge_symbol() {
  return getRuleContext<VerilogParser::Edge_symbolContext>(0);
}


size_t VerilogParser::Edge_indicatorContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_indicator;
}


std::any VerilogParser::Edge_indicatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_indicator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_indicatorContext* VerilogParser::edge_indicator() {
  Edge_indicatorContext *_localctx = _tracker.createInstance<Edge_indicatorContext>(_ctx, getState());
  enterRule(_localctx, 328, VerilogParser::RuleEdge_indicator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2692);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LP: {
        enterOuterAlt(_localctx, 1);
        setState(2686);
        match(VerilogParser::LP);
        setState(2687);
        level_symbol();
        setState(2688);
        level_symbol();
        setState(2689);
        match(VerilogParser::RP);
        break;
      }

      case VerilogParser::EDGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2691);
        edge_symbol();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Current_stateContext ------------------------------------------------------------------

VerilogParser::Current_stateContext::Current_stateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Level_symbolContext* VerilogParser::Current_stateContext::level_symbol() {
  return getRuleContext<VerilogParser::Level_symbolContext>(0);
}


size_t VerilogParser::Current_stateContext::getRuleIndex() const {
  return VerilogParser::RuleCurrent_state;
}


std::any VerilogParser::Current_stateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCurrent_state(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Current_stateContext* VerilogParser::current_state() {
  Current_stateContext *_localctx = _tracker.createInstance<Current_stateContext>(_ctx, getState());
  enterRule(_localctx, 330, VerilogParser::RuleCurrent_state);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2694);
    level_symbol();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Next_stateContext ------------------------------------------------------------------

VerilogParser::Next_stateContext::Next_stateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Output_symbolContext* VerilogParser::Next_stateContext::output_symbol() {
  return getRuleContext<VerilogParser::Output_symbolContext>(0);
}

tree::TerminalNode* VerilogParser::Next_stateContext::MI() {
  return getToken(VerilogParser::MI, 0);
}


size_t VerilogParser::Next_stateContext::getRuleIndex() const {
  return VerilogParser::RuleNext_state;
}


std::any VerilogParser::Next_stateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNext_state(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Next_stateContext* VerilogParser::next_state() {
  Next_stateContext *_localctx = _tracker.createInstance<Next_stateContext>(_ctx, getState());
  enterRule(_localctx, 332, VerilogParser::RuleNext_state);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2698);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::OUTPUT_OR_LEVEL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2696);
        output_symbol();
        break;
      }

      case VerilogParser::MI: {
        enterOuterAlt(_localctx, 2);
        setState(2697);
        match(VerilogParser::MI);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_symbolContext ------------------------------------------------------------------

VerilogParser::Output_symbolContext::Output_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Output_symbolContext::OUTPUT_OR_LEVEL_SYMBOL() {
  return getToken(VerilogParser::OUTPUT_OR_LEVEL_SYMBOL, 0);
}


size_t VerilogParser::Output_symbolContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_symbol;
}


std::any VerilogParser::Output_symbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_symbol(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_symbolContext* VerilogParser::output_symbol() {
  Output_symbolContext *_localctx = _tracker.createInstance<Output_symbolContext>(_ctx, getState());
  enterRule(_localctx, 334, VerilogParser::RuleOutput_symbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2700);
    match(VerilogParser::OUTPUT_OR_LEVEL_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Level_symbolContext ------------------------------------------------------------------

VerilogParser::Level_symbolContext::Level_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Level_symbolContext::LEVEL_ONLY_SYMBOL() {
  return getToken(VerilogParser::LEVEL_ONLY_SYMBOL, 0);
}

tree::TerminalNode* VerilogParser::Level_symbolContext::OUTPUT_OR_LEVEL_SYMBOL() {
  return getToken(VerilogParser::OUTPUT_OR_LEVEL_SYMBOL, 0);
}


size_t VerilogParser::Level_symbolContext::getRuleIndex() const {
  return VerilogParser::RuleLevel_symbol;
}


std::any VerilogParser::Level_symbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLevel_symbol(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Level_symbolContext* VerilogParser::level_symbol() {
  Level_symbolContext *_localctx = _tracker.createInstance<Level_symbolContext>(_ctx, getState());
  enterRule(_localctx, 336, VerilogParser::RuleLevel_symbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2702);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::LEVEL_ONLY_SYMBOL

    || _la == VerilogParser::OUTPUT_OR_LEVEL_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_symbolContext ------------------------------------------------------------------

VerilogParser::Edge_symbolContext::Edge_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_symbolContext::EDGE_SYMBOL() {
  return getToken(VerilogParser::EDGE_SYMBOL, 0);
}


size_t VerilogParser::Edge_symbolContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_symbol;
}


std::any VerilogParser::Edge_symbolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_symbol(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_symbolContext* VerilogParser::edge_symbol() {
  Edge_symbolContext *_localctx = _tracker.createInstance<Edge_symbolContext>(_ctx, getState());
  enterRule(_localctx, 338, VerilogParser::RuleEdge_symbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2704);
    match(VerilogParser::EDGE_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instantiationContext ------------------------------------------------------------------

VerilogParser::Udp_instantiationContext::Udp_instantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_identifierContext* VerilogParser::Udp_instantiationContext::udp_identifier() {
  return getRuleContext<VerilogParser::Udp_identifierContext>(0);
}

std::vector<VerilogParser::Udp_instanceContext *> VerilogParser::Udp_instantiationContext::udp_instance() {
  return getRuleContexts<VerilogParser::Udp_instanceContext>();
}

VerilogParser::Udp_instanceContext* VerilogParser::Udp_instantiationContext::udp_instance(size_t i) {
  return getRuleContext<VerilogParser::Udp_instanceContext>(i);
}

tree::TerminalNode* VerilogParser::Udp_instantiationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Drive_strengthContext* VerilogParser::Udp_instantiationContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Delay2Context* VerilogParser::Udp_instantiationContext::delay2() {
  return getRuleContext<VerilogParser::Delay2Context>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_instantiationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_instantiationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Udp_instantiationContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_instantiation;
}


std::any VerilogParser::Udp_instantiationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_instantiation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_instantiationContext* VerilogParser::udp_instantiation() {
  Udp_instantiationContext *_localctx = _tracker.createInstance<Udp_instantiationContext>(_ctx, getState());
  enterRule(_localctx, 340, VerilogParser::RuleUdp_instantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2706);
    udp_identifier();
    setState(2708);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 266, _ctx)) {
    case 1: {
      setState(2707);
      drive_strength();
      break;
    }

    default:
      break;
    }
    setState(2711);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(2710);
      delay2();
    }
    setState(2713);
    udp_instance();
    setState(2718);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2714);
      match(VerilogParser::CO);
      setState(2715);
      udp_instance();
      setState(2720);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2721);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instanceContext ------------------------------------------------------------------

VerilogParser::Udp_instanceContext::Udp_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Udp_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Output_terminalContext* VerilogParser::Udp_instanceContext::output_terminal() {
  return getRuleContext<VerilogParser::Output_terminalContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Udp_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Udp_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

std::vector<VerilogParser::Input_terminalContext *> VerilogParser::Udp_instanceContext::input_terminal() {
  return getRuleContexts<VerilogParser::Input_terminalContext>();
}

VerilogParser::Input_terminalContext* VerilogParser::Udp_instanceContext::input_terminal(size_t i) {
  return getRuleContext<VerilogParser::Input_terminalContext>(i);
}

tree::TerminalNode* VerilogParser::Udp_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Name_of_udp_instanceContext* VerilogParser::Udp_instanceContext::name_of_udp_instance() {
  return getRuleContext<VerilogParser::Name_of_udp_instanceContext>(0);
}


size_t VerilogParser::Udp_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_instance;
}


std::any VerilogParser::Udp_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_instanceContext* VerilogParser::udp_instance() {
  Udp_instanceContext *_localctx = _tracker.createInstance<Udp_instanceContext>(_ctx, getState());
  enterRule(_localctx, 342, VerilogParser::RuleUdp_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2724);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(2723);
      name_of_udp_instance();
    }
    setState(2726);
    match(VerilogParser::LP);
    setState(2727);
    output_terminal();
    setState(2728);
    match(VerilogParser::CO);
    setState(2729);
    input_terminal();
    setState(2734);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2730);
      match(VerilogParser::CO);
      setState(2731);
      input_terminal();
      setState(2736);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2737);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Name_of_udp_instanceContext ------------------------------------------------------------------

VerilogParser::Name_of_udp_instanceContext::Name_of_udp_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Udp_instance_identifierContext* VerilogParser::Name_of_udp_instanceContext::udp_instance_identifier() {
  return getRuleContext<VerilogParser::Udp_instance_identifierContext>(0);
}

VerilogParser::Range_Context* VerilogParser::Name_of_udp_instanceContext::range_() {
  return getRuleContext<VerilogParser::Range_Context>(0);
}


size_t VerilogParser::Name_of_udp_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleName_of_udp_instance;
}


std::any VerilogParser::Name_of_udp_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitName_of_udp_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Name_of_udp_instanceContext* VerilogParser::name_of_udp_instance() {
  Name_of_udp_instanceContext *_localctx = _tracker.createInstance<Name_of_udp_instanceContext>(_ctx, getState());
  enterRule(_localctx, 344, VerilogParser::RuleName_of_udp_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2739);
    udp_instance_identifier();
    setState(2741);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(2740);
      range_();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Continuous_assignContext ------------------------------------------------------------------

VerilogParser::Continuous_assignContext::Continuous_assignContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Continuous_assignContext::ASSIGN() {
  return getToken(VerilogParser::ASSIGN, 0);
}

VerilogParser::List_of_net_assignmentsContext* VerilogParser::Continuous_assignContext::list_of_net_assignments() {
  return getRuleContext<VerilogParser::List_of_net_assignmentsContext>(0);
}

tree::TerminalNode* VerilogParser::Continuous_assignContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Drive_strengthContext* VerilogParser::Continuous_assignContext::drive_strength() {
  return getRuleContext<VerilogParser::Drive_strengthContext>(0);
}

VerilogParser::Delay3Context* VerilogParser::Continuous_assignContext::delay3() {
  return getRuleContext<VerilogParser::Delay3Context>(0);
}


size_t VerilogParser::Continuous_assignContext::getRuleIndex() const {
  return VerilogParser::RuleContinuous_assign;
}


std::any VerilogParser::Continuous_assignContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitContinuous_assign(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Continuous_assignContext* VerilogParser::continuous_assign() {
  Continuous_assignContext *_localctx = _tracker.createInstance<Continuous_assignContext>(_ctx, getState());
  enterRule(_localctx, 346, VerilogParser::RuleContinuous_assign);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2743);
    match(VerilogParser::ASSIGN);
    setState(2745);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(2744);
      drive_strength();
    }
    setState(2748);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::HA) {
      setState(2747);
      delay3();
    }
    setState(2750);
    list_of_net_assignments();
    setState(2751);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_net_assignmentsContext ------------------------------------------------------------------

VerilogParser::List_of_net_assignmentsContext::List_of_net_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Net_assignmentContext *> VerilogParser::List_of_net_assignmentsContext::net_assignment() {
  return getRuleContexts<VerilogParser::Net_assignmentContext>();
}

VerilogParser::Net_assignmentContext* VerilogParser::List_of_net_assignmentsContext::net_assignment(size_t i) {
  return getRuleContext<VerilogParser::Net_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_net_assignmentsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_net_assignmentsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_net_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_net_assignments;
}


std::any VerilogParser::List_of_net_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_net_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_net_assignmentsContext* VerilogParser::list_of_net_assignments() {
  List_of_net_assignmentsContext *_localctx = _tracker.createInstance<List_of_net_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 348, VerilogParser::RuleList_of_net_assignments);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2753);
    net_assignment();
    setState(2758);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(2754);
      match(VerilogParser::CO);
      setState(2755);
      net_assignment();
      setState(2760);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_assignmentContext ------------------------------------------------------------------

VerilogParser::Net_assignmentContext::Net_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Net_lvalueContext* VerilogParser::Net_assignmentContext::net_lvalue() {
  return getRuleContext<VerilogParser::Net_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Net_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Net_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Net_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNet_assignment;
}


std::any VerilogParser::Net_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_assignmentContext* VerilogParser::net_assignment() {
  Net_assignmentContext *_localctx = _tracker.createInstance<Net_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 350, VerilogParser::RuleNet_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2761);
    net_lvalue();
    setState(2762);
    match(VerilogParser::EQ);
    setState(2763);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_constructContext ------------------------------------------------------------------

VerilogParser::Initial_constructContext::Initial_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Initial_constructContext::INITIAL() {
  return getToken(VerilogParser::INITIAL, 0);
}

VerilogParser::StatementContext* VerilogParser::Initial_constructContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Initial_constructContext::getRuleIndex() const {
  return VerilogParser::RuleInitial_construct;
}


std::any VerilogParser::Initial_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInitial_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Initial_constructContext* VerilogParser::initial_construct() {
  Initial_constructContext *_localctx = _tracker.createInstance<Initial_constructContext>(_ctx, getState());
  enterRule(_localctx, 352, VerilogParser::RuleInitial_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2765);
    match(VerilogParser::INITIAL);
    setState(2766);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Always_constructContext ------------------------------------------------------------------

VerilogParser::Always_constructContext::Always_constructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Always_constructContext::ALWAYS() {
  return getToken(VerilogParser::ALWAYS, 0);
}

VerilogParser::StatementContext* VerilogParser::Always_constructContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Always_constructContext::getRuleIndex() const {
  return VerilogParser::RuleAlways_construct;
}


std::any VerilogParser::Always_constructContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAlways_construct(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Always_constructContext* VerilogParser::always_construct() {
  Always_constructContext *_localctx = _tracker.createInstance<Always_constructContext>(_ctx, getState());
  enterRule(_localctx, 354, VerilogParser::RuleAlways_construct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2768);
    match(VerilogParser::ALWAYS);
    setState(2769);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Blocking_assignmentContext ------------------------------------------------------------------

VerilogParser::Blocking_assignmentContext::Blocking_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_lvalueContext* VerilogParser::Blocking_assignmentContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Blocking_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Blocking_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::Blocking_assignmentContext::delay_or_event_control() {
  return getRuleContext<VerilogParser::Delay_or_event_controlContext>(0);
}


size_t VerilogParser::Blocking_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleBlocking_assignment;
}


std::any VerilogParser::Blocking_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlocking_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Blocking_assignmentContext* VerilogParser::blocking_assignment() {
  Blocking_assignmentContext *_localctx = _tracker.createInstance<Blocking_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 356, VerilogParser::RuleBlocking_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2771);
    variable_lvalue();
    setState(2772);
    match(VerilogParser::EQ);
    setState(2774);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::AT || _la == VerilogParser::HA

    || _la == VerilogParser::REPEAT) {
      setState(2773);
      delay_or_event_control();
    }
    setState(2776);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nonblocking_assignmentContext ------------------------------------------------------------------

VerilogParser::Nonblocking_assignmentContext::Nonblocking_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_lvalueContext* VerilogParser::Nonblocking_assignmentContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Nonblocking_assignmentContext::LTEQ() {
  return getToken(VerilogParser::LTEQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Nonblocking_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::Nonblocking_assignmentContext::delay_or_event_control() {
  return getRuleContext<VerilogParser::Delay_or_event_controlContext>(0);
}


size_t VerilogParser::Nonblocking_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleNonblocking_assignment;
}


std::any VerilogParser::Nonblocking_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNonblocking_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Nonblocking_assignmentContext* VerilogParser::nonblocking_assignment() {
  Nonblocking_assignmentContext *_localctx = _tracker.createInstance<Nonblocking_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 358, VerilogParser::RuleNonblocking_assignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2778);
    variable_lvalue();
    setState(2779);
    match(VerilogParser::LTEQ);
    setState(2781);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::AT || _la == VerilogParser::HA

    || _la == VerilogParser::REPEAT) {
      setState(2780);
      delay_or_event_control();
    }
    setState(2783);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_continuous_assignmentsContext ------------------------------------------------------------------

VerilogParser::Procedural_continuous_assignmentsContext::Procedural_continuous_assignmentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::ASSIGN() {
  return getToken(VerilogParser::ASSIGN, 0);
}

VerilogParser::Variable_assignmentContext* VerilogParser::Procedural_continuous_assignmentsContext::variable_assignment() {
  return getRuleContext<VerilogParser::Variable_assignmentContext>(0);
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::DEASSIGN() {
  return getToken(VerilogParser::DEASSIGN, 0);
}

VerilogParser::Variable_lvalueContext* VerilogParser::Procedural_continuous_assignmentsContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::FORCE() {
  return getToken(VerilogParser::FORCE, 0);
}

tree::TerminalNode* VerilogParser::Procedural_continuous_assignmentsContext::RELEASE() {
  return getToken(VerilogParser::RELEASE, 0);
}


size_t VerilogParser::Procedural_continuous_assignmentsContext::getRuleIndex() const {
  return VerilogParser::RuleProcedural_continuous_assignments;
}


std::any VerilogParser::Procedural_continuous_assignmentsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitProcedural_continuous_assignments(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Procedural_continuous_assignmentsContext* VerilogParser::procedural_continuous_assignments() {
  Procedural_continuous_assignmentsContext *_localctx = _tracker.createInstance<Procedural_continuous_assignmentsContext>(_ctx, getState());
  enterRule(_localctx, 360, VerilogParser::RuleProcedural_continuous_assignments);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2793);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ASSIGN: {
        enterOuterAlt(_localctx, 1);
        setState(2785);
        match(VerilogParser::ASSIGN);
        setState(2786);
        variable_assignment();
        break;
      }

      case VerilogParser::DEASSIGN: {
        enterOuterAlt(_localctx, 2);
        setState(2787);
        match(VerilogParser::DEASSIGN);
        setState(2788);
        variable_lvalue();
        break;
      }

      case VerilogParser::FORCE: {
        enterOuterAlt(_localctx, 3);
        setState(2789);
        match(VerilogParser::FORCE);
        setState(2790);
        variable_assignment();
        break;
      }

      case VerilogParser::RELEASE: {
        enterOuterAlt(_localctx, 4);
        setState(2791);
        match(VerilogParser::RELEASE);
        setState(2792);
        variable_lvalue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_assignmentContext ------------------------------------------------------------------

VerilogParser::Variable_assignmentContext::Variable_assignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_lvalueContext* VerilogParser::Variable_assignmentContext::variable_lvalue() {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(0);
}

tree::TerminalNode* VerilogParser::Variable_assignmentContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Variable_assignmentContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Variable_assignmentContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_assignment;
}


std::any VerilogParser::Variable_assignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_assignment(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_assignmentContext* VerilogParser::variable_assignment() {
  Variable_assignmentContext *_localctx = _tracker.createInstance<Variable_assignmentContext>(_ctx, getState());
  enterRule(_localctx, 362, VerilogParser::RuleVariable_assignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2795);
    variable_lvalue();
    setState(2796);
    match(VerilogParser::EQ);
    setState(2797);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Par_blockContext ------------------------------------------------------------------

VerilogParser::Par_blockContext::Par_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Par_blockContext::FORK() {
  return getToken(VerilogParser::FORK, 0);
}

tree::TerminalNode* VerilogParser::Par_blockContext::JOIN() {
  return getToken(VerilogParser::JOIN, 0);
}

VerilogParser::Block_nameContext* VerilogParser::Par_blockContext::block_name() {
  return getRuleContext<VerilogParser::Block_nameContext>(0);
}

std::vector<VerilogParser::StatementContext *> VerilogParser::Par_blockContext::statement() {
  return getRuleContexts<VerilogParser::StatementContext>();
}

VerilogParser::StatementContext* VerilogParser::Par_blockContext::statement(size_t i) {
  return getRuleContext<VerilogParser::StatementContext>(i);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Par_blockContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Par_blockContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Par_blockContext::getRuleIndex() const {
  return VerilogParser::RulePar_block;
}


std::any VerilogParser::Par_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPar_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Par_blockContext* VerilogParser::par_block() {
  Par_blockContext *_localctx = _tracker.createInstance<Par_blockContext>(_ctx, getState());
  enterRule(_localctx, 364, VerilogParser::RulePar_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2799);
    match(VerilogParser::FORK);
    setState(2807);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(2800);
      block_name();
      setState(2804);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2801);
          block_item_declaration(); 
        }
        setState(2806);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx);
      }
    }
    setState(2812);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1141773824) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 550896701455) != 0 || (((_la - 139) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 139)) & 1450196463408644099) != 0) {
      setState(2809);
      statement();
      setState(2814);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2815);
    match(VerilogParser::JOIN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_nameContext ------------------------------------------------------------------

VerilogParser::Block_nameContext::Block_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Block_nameContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Block_identifierContext* VerilogParser::Block_nameContext::block_identifier() {
  return getRuleContext<VerilogParser::Block_identifierContext>(0);
}


size_t VerilogParser::Block_nameContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_name;
}


std::any VerilogParser::Block_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_nameContext* VerilogParser::block_name() {
  Block_nameContext *_localctx = _tracker.createInstance<Block_nameContext>(_ctx, getState());
  enterRule(_localctx, 366, VerilogParser::RuleBlock_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2817);
    match(VerilogParser::CL);
    setState(2818);
    block_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Seq_blockContext ------------------------------------------------------------------

VerilogParser::Seq_blockContext::Seq_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Seq_blockContext::BEGIN() {
  return getToken(VerilogParser::BEGIN, 0);
}

tree::TerminalNode* VerilogParser::Seq_blockContext::END() {
  return getToken(VerilogParser::END, 0);
}

VerilogParser::Block_nameContext* VerilogParser::Seq_blockContext::block_name() {
  return getRuleContext<VerilogParser::Block_nameContext>(0);
}

std::vector<VerilogParser::StatementContext *> VerilogParser::Seq_blockContext::statement() {
  return getRuleContexts<VerilogParser::StatementContext>();
}

VerilogParser::StatementContext* VerilogParser::Seq_blockContext::statement(size_t i) {
  return getRuleContext<VerilogParser::StatementContext>(i);
}

std::vector<VerilogParser::Block_item_declarationContext *> VerilogParser::Seq_blockContext::block_item_declaration() {
  return getRuleContexts<VerilogParser::Block_item_declarationContext>();
}

VerilogParser::Block_item_declarationContext* VerilogParser::Seq_blockContext::block_item_declaration(size_t i) {
  return getRuleContext<VerilogParser::Block_item_declarationContext>(i);
}


size_t VerilogParser::Seq_blockContext::getRuleIndex() const {
  return VerilogParser::RuleSeq_block;
}


std::any VerilogParser::Seq_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSeq_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Seq_blockContext* VerilogParser::seq_block() {
  Seq_blockContext *_localctx = _tracker.createInstance<Seq_blockContext>(_ctx, getState());
  enterRule(_localctx, 368, VerilogParser::RuleSeq_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2820);
    match(VerilogParser::BEGIN);
    setState(2828);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(2821);
      block_name();
      setState(2825);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2822);
          block_item_declaration(); 
        }
        setState(2827);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx);
      }
    }
    setState(2833);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1141773824) != 0 || (((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 550896701455) != 0 || (((_la - 139) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 139)) & 1450196463408644099) != 0) {
      setState(2830);
      statement();
      setState(2835);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2836);
    match(VerilogParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

VerilogParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Blocking_assignmentContext* VerilogParser::StatementContext::blocking_assignment() {
  return getRuleContext<VerilogParser::Blocking_assignmentContext>(0);
}

tree::TerminalNode* VerilogParser::StatementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::StatementContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::StatementContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

VerilogParser::Case_statementContext* VerilogParser::StatementContext::case_statement() {
  return getRuleContext<VerilogParser::Case_statementContext>(0);
}

VerilogParser::Conditional_statementContext* VerilogParser::StatementContext::conditional_statement() {
  return getRuleContext<VerilogParser::Conditional_statementContext>(0);
}

VerilogParser::Disable_statementContext* VerilogParser::StatementContext::disable_statement() {
  return getRuleContext<VerilogParser::Disable_statementContext>(0);
}

VerilogParser::Event_triggerContext* VerilogParser::StatementContext::event_trigger() {
  return getRuleContext<VerilogParser::Event_triggerContext>(0);
}

VerilogParser::Loop_statementContext* VerilogParser::StatementContext::loop_statement() {
  return getRuleContext<VerilogParser::Loop_statementContext>(0);
}

VerilogParser::Nonblocking_assignmentContext* VerilogParser::StatementContext::nonblocking_assignment() {
  return getRuleContext<VerilogParser::Nonblocking_assignmentContext>(0);
}

VerilogParser::Par_blockContext* VerilogParser::StatementContext::par_block() {
  return getRuleContext<VerilogParser::Par_blockContext>(0);
}

VerilogParser::Procedural_continuous_assignmentsContext* VerilogParser::StatementContext::procedural_continuous_assignments() {
  return getRuleContext<VerilogParser::Procedural_continuous_assignmentsContext>(0);
}

VerilogParser::Procedural_timing_control_statementContext* VerilogParser::StatementContext::procedural_timing_control_statement() {
  return getRuleContext<VerilogParser::Procedural_timing_control_statementContext>(0);
}

VerilogParser::Seq_blockContext* VerilogParser::StatementContext::seq_block() {
  return getRuleContext<VerilogParser::Seq_blockContext>(0);
}

VerilogParser::System_task_enableContext* VerilogParser::StatementContext::system_task_enable() {
  return getRuleContext<VerilogParser::System_task_enableContext>(0);
}

VerilogParser::Task_enableContext* VerilogParser::StatementContext::task_enable() {
  return getRuleContext<VerilogParser::Task_enableContext>(0);
}

VerilogParser::Wait_statementContext* VerilogParser::StatementContext::wait_statement() {
  return getRuleContext<VerilogParser::Wait_statementContext>(0);
}


size_t VerilogParser::StatementContext::getRuleIndex() const {
  return VerilogParser::RuleStatement;
}


std::any VerilogParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::StatementContext* VerilogParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 370, VerilogParser::RuleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2942);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2841);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2838);
        attribute_instance();
        setState(2843);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2844);
      blocking_assignment();
      setState(2845);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2850);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2847);
        attribute_instance();
        setState(2852);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2853);
      case_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2857);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2854);
        attribute_instance();
        setState(2859);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2860);
      conditional_statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2864);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2861);
        attribute_instance();
        setState(2866);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2867);
      disable_statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2871);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2868);
        attribute_instance();
        setState(2873);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2874);
      event_trigger();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2878);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2875);
        attribute_instance();
        setState(2880);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2881);
      loop_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2885);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2882);
        attribute_instance();
        setState(2887);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2888);
      nonblocking_assignment();
      setState(2889);
      match(VerilogParser::SC);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2894);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2891);
        attribute_instance();
        setState(2896);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2897);
      par_block();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2901);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2898);
        attribute_instance();
        setState(2903);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2904);
      procedural_continuous_assignments();
      setState(2905);
      match(VerilogParser::SC);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2910);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2907);
        attribute_instance();
        setState(2912);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2913);
      procedural_timing_control_statement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2917);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2914);
        attribute_instance();
        setState(2919);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2920);
      seq_block();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2924);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2921);
        attribute_instance();
        setState(2926);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2927);
      system_task_enable();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2931);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2928);
        attribute_instance();
        setState(2933);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2934);
      task_enable();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(2938);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2935);
        attribute_instance();
        setState(2940);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2941);
      wait_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Statement_or_nullContext ------------------------------------------------------------------

VerilogParser::Statement_or_nullContext::Statement_or_nullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::StatementContext* VerilogParser::Statement_or_nullContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}

tree::TerminalNode* VerilogParser::Statement_or_nullContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Statement_or_nullContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Statement_or_nullContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}


size_t VerilogParser::Statement_or_nullContext::getRuleIndex() const {
  return VerilogParser::RuleStatement_or_null;
}


std::any VerilogParser::Statement_or_nullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStatement_or_null(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Statement_or_nullContext* VerilogParser::statement_or_null() {
  Statement_or_nullContext *_localctx = _tracker.createInstance<Statement_or_nullContext>(_ctx, getState());
  enterRule(_localctx, 372, VerilogParser::RuleStatement_or_null);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2952);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2944);
      statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2948);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == VerilogParser::LP) {
        setState(2945);
        attribute_instance();
        setState(2950);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(2951);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_statementContext ------------------------------------------------------------------

VerilogParser::Function_statementContext::Function_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::StatementContext* VerilogParser::Function_statementContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}


size_t VerilogParser::Function_statementContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_statement;
}


std::any VerilogParser::Function_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_statementContext* VerilogParser::function_statement() {
  Function_statementContext *_localctx = _tracker.createInstance<Function_statementContext>(_ctx, getState());
  enterRule(_localctx, 374, VerilogParser::RuleFunction_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2954);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_controlContext ------------------------------------------------------------------

VerilogParser::Delay_controlContext::Delay_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delay_controlContext::HA() {
  return getToken(VerilogParser::HA, 0);
}

VerilogParser::Delay_valueContext* VerilogParser::Delay_controlContext::delay_value() {
  return getRuleContext<VerilogParser::Delay_valueContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_controlContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Delay_controlContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_controlContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Delay_controlContext::getRuleIndex() const {
  return VerilogParser::RuleDelay_control;
}


std::any VerilogParser::Delay_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay_controlContext* VerilogParser::delay_control() {
  Delay_controlContext *_localctx = _tracker.createInstance<Delay_controlContext>(_ctx, getState());
  enterRule(_localctx, 376, VerilogParser::RuleDelay_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2963);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2956);
      match(VerilogParser::HA);
      setState(2957);
      delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2958);
      match(VerilogParser::HA);
      setState(2959);
      match(VerilogParser::LP);
      setState(2960);
      mintypmax_expression();
      setState(2961);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delay_or_event_controlContext ------------------------------------------------------------------

VerilogParser::Delay_or_event_controlContext::Delay_or_event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Delay_controlContext* VerilogParser::Delay_or_event_controlContext::delay_control() {
  return getRuleContext<VerilogParser::Delay_controlContext>(0);
}

VerilogParser::Event_controlContext* VerilogParser::Delay_or_event_controlContext::event_control() {
  return getRuleContext<VerilogParser::Event_controlContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_or_event_controlContext::REPEAT() {
  return getToken(VerilogParser::REPEAT, 0);
}

tree::TerminalNode* VerilogParser::Delay_or_event_controlContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Delay_or_event_controlContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delay_or_event_controlContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Delay_or_event_controlContext::getRuleIndex() const {
  return VerilogParser::RuleDelay_or_event_control;
}


std::any VerilogParser::Delay_or_event_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelay_or_event_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delay_or_event_controlContext* VerilogParser::delay_or_event_control() {
  Delay_or_event_controlContext *_localctx = _tracker.createInstance<Delay_or_event_controlContext>(_ctx, getState());
  enterRule(_localctx, 378, VerilogParser::RuleDelay_or_event_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2973);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::HA: {
        enterOuterAlt(_localctx, 1);
        setState(2965);
        delay_control();
        break;
      }

      case VerilogParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(2966);
        event_control();
        break;
      }

      case VerilogParser::REPEAT: {
        enterOuterAlt(_localctx, 3);
        setState(2967);
        match(VerilogParser::REPEAT);
        setState(2968);
        match(VerilogParser::LP);
        setState(2969);
        expression(0);
        setState(2970);
        match(VerilogParser::RP);
        setState(2971);
        event_control();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Disable_statementContext ------------------------------------------------------------------

VerilogParser::Disable_statementContext::Disable_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Disable_statementContext::DISABLE() {
  return getToken(VerilogParser::DISABLE, 0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Disable_statementContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Disable_statementContext::SC() {
  return getToken(VerilogParser::SC, 0);
}


size_t VerilogParser::Disable_statementContext::getRuleIndex() const {
  return VerilogParser::RuleDisable_statement;
}


std::any VerilogParser::Disable_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDisable_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Disable_statementContext* VerilogParser::disable_statement() {
  Disable_statementContext *_localctx = _tracker.createInstance<Disable_statementContext>(_ctx, getState());
  enterRule(_localctx, 380, VerilogParser::RuleDisable_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2975);
    match(VerilogParser::DISABLE);
    setState(2976);
    hierarchical_identifier();
    setState(2977);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_controlContext ------------------------------------------------------------------

VerilogParser::Event_controlContext::Event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_controlContext::AT() {
  return getToken(VerilogParser::AT, 0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Event_controlContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Event_controlContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Event_expressionContext* VerilogParser::Event_controlContext::event_expression() {
  return getRuleContext<VerilogParser::Event_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Event_controlContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Event_controlContext::AS() {
  return getToken(VerilogParser::AS, 0);
}


size_t VerilogParser::Event_controlContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_control;
}


std::any VerilogParser::Event_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_controlContext* VerilogParser::event_control() {
  Event_controlContext *_localctx = _tracker.createInstance<Event_controlContext>(_ctx, getState());
  enterRule(_localctx, 382, VerilogParser::RuleEvent_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2992);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2979);
      match(VerilogParser::AT);
      setState(2980);
      hierarchical_identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2981);
      match(VerilogParser::AT);
      setState(2982);
      match(VerilogParser::LP);
      setState(2983);
      event_expression(0);
      setState(2984);
      match(VerilogParser::RP);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2986);
      match(VerilogParser::AT);
      setState(2987);
      match(VerilogParser::AS);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2988);
      match(VerilogParser::AT);
      setState(2989);
      match(VerilogParser::LP);
      setState(2990);
      match(VerilogParser::AS);
      setState(2991);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_triggerContext ------------------------------------------------------------------

VerilogParser::Event_triggerContext::Event_triggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_triggerContext::MIGT() {
  return getToken(VerilogParser::MIGT, 0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Event_triggerContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Event_triggerContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Bit_selectContext* VerilogParser::Event_triggerContext::bit_select() {
  return getRuleContext<VerilogParser::Bit_selectContext>(0);
}


size_t VerilogParser::Event_triggerContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_trigger;
}


std::any VerilogParser::Event_triggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_trigger(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_triggerContext* VerilogParser::event_trigger() {
  Event_triggerContext *_localctx = _tracker.createInstance<Event_triggerContext>(_ctx, getState());
  enterRule(_localctx, 384, VerilogParser::RuleEvent_trigger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2994);
    match(VerilogParser::MIGT);
    setState(2995);
    hierarchical_identifier();
    setState(2997);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(2996);
      bit_select();
    }
    setState(2999);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_expressionContext ------------------------------------------------------------------

VerilogParser::Event_expressionContext::Event_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Event_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::POSEDGE() {
  return getToken(VerilogParser::POSEDGE, 0);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::NEGEDGE() {
  return getToken(VerilogParser::NEGEDGE, 0);
}

std::vector<VerilogParser::Event_expressionContext *> VerilogParser::Event_expressionContext::event_expression() {
  return getRuleContexts<VerilogParser::Event_expressionContext>();
}

VerilogParser::Event_expressionContext* VerilogParser::Event_expressionContext::event_expression(size_t i) {
  return getRuleContext<VerilogParser::Event_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::OR() {
  return getToken(VerilogParser::OR, 0);
}

tree::TerminalNode* VerilogParser::Event_expressionContext::CO() {
  return getToken(VerilogParser::CO, 0);
}


size_t VerilogParser::Event_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_expression;
}


std::any VerilogParser::Event_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_expression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::Event_expressionContext* VerilogParser::event_expression() {
   return event_expression(0);
}

VerilogParser::Event_expressionContext* VerilogParser::event_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::Event_expressionContext *_localctx = _tracker.createInstance<Event_expressionContext>(_ctx, parentState);
  VerilogParser::Event_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 386;
  enterRecursionRule(_localctx, 386, VerilogParser::RuleEvent_expression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3007);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::CATI:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        setState(3002);
        expression(0);
        break;
      }

      case VerilogParser::POSEDGE: {
        setState(3003);
        match(VerilogParser::POSEDGE);
        setState(3004);
        expression(0);
        break;
      }

      case VerilogParser::NEGEDGE: {
        setState(3005);
        match(VerilogParser::NEGEDGE);
        setState(3006);
        expression(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(3017);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(3015);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Event_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleEvent_expression);
          setState(3009);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(3010);
          match(VerilogParser::OR);
          setState(3011);
          event_expression(3);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Event_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleEvent_expression);
          setState(3012);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(3013);
          match(VerilogParser::CO);
          setState(3014);
          event_expression(2);
          break;
        }

        default:
          break;
        } 
      }
      setState(3019);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Procedural_timing_controlContext ------------------------------------------------------------------

VerilogParser::Procedural_timing_controlContext::Procedural_timing_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Delay_controlContext* VerilogParser::Procedural_timing_controlContext::delay_control() {
  return getRuleContext<VerilogParser::Delay_controlContext>(0);
}

VerilogParser::Event_controlContext* VerilogParser::Procedural_timing_controlContext::event_control() {
  return getRuleContext<VerilogParser::Event_controlContext>(0);
}


size_t VerilogParser::Procedural_timing_controlContext::getRuleIndex() const {
  return VerilogParser::RuleProcedural_timing_control;
}


std::any VerilogParser::Procedural_timing_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitProcedural_timing_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Procedural_timing_controlContext* VerilogParser::procedural_timing_control() {
  Procedural_timing_controlContext *_localctx = _tracker.createInstance<Procedural_timing_controlContext>(_ctx, getState());
  enterRule(_localctx, 388, VerilogParser::RuleProcedural_timing_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3022);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::HA: {
        enterOuterAlt(_localctx, 1);
        setState(3020);
        delay_control();
        break;
      }

      case VerilogParser::AT: {
        enterOuterAlt(_localctx, 2);
        setState(3021);
        event_control();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Procedural_timing_control_statementContext ------------------------------------------------------------------

VerilogParser::Procedural_timing_control_statementContext::Procedural_timing_control_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Procedural_timing_controlContext* VerilogParser::Procedural_timing_control_statementContext::procedural_timing_control() {
  return getRuleContext<VerilogParser::Procedural_timing_controlContext>(0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Procedural_timing_control_statementContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}


size_t VerilogParser::Procedural_timing_control_statementContext::getRuleIndex() const {
  return VerilogParser::RuleProcedural_timing_control_statement;
}


std::any VerilogParser::Procedural_timing_control_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitProcedural_timing_control_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Procedural_timing_control_statementContext* VerilogParser::procedural_timing_control_statement() {
  Procedural_timing_control_statementContext *_localctx = _tracker.createInstance<Procedural_timing_control_statementContext>(_ctx, getState());
  enterRule(_localctx, 390, VerilogParser::RuleProcedural_timing_control_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3024);
    procedural_timing_control();
    setState(3025);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Wait_statementContext ------------------------------------------------------------------

VerilogParser::Wait_statementContext::Wait_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Wait_statementContext::WAIT() {
  return getToken(VerilogParser::WAIT, 0);
}

tree::TerminalNode* VerilogParser::Wait_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Wait_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Wait_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Wait_statementContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}


size_t VerilogParser::Wait_statementContext::getRuleIndex() const {
  return VerilogParser::RuleWait_statement;
}


std::any VerilogParser::Wait_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitWait_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Wait_statementContext* VerilogParser::wait_statement() {
  Wait_statementContext *_localctx = _tracker.createInstance<Wait_statementContext>(_ctx, getState());
  enterRule(_localctx, 392, VerilogParser::RuleWait_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3027);
    match(VerilogParser::WAIT);
    setState(3028);
    match(VerilogParser::LP);
    setState(3029);
    expression(0);
    setState(3030);
    match(VerilogParser::RP);
    setState(3031);
    statement_or_null();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conditional_statementContext ------------------------------------------------------------------

VerilogParser::Conditional_statementContext::Conditional_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::IF() {
  return getToken(VerilogParser::IF, 0);
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Conditional_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Statement_or_nullContext *> VerilogParser::Conditional_statementContext::statement_or_null() {
  return getRuleContexts<VerilogParser::Statement_or_nullContext>();
}

VerilogParser::Statement_or_nullContext* VerilogParser::Conditional_statementContext::statement_or_null(size_t i) {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(i);
}

tree::TerminalNode* VerilogParser::Conditional_statementContext::ELSE() {
  return getToken(VerilogParser::ELSE, 0);
}


size_t VerilogParser::Conditional_statementContext::getRuleIndex() const {
  return VerilogParser::RuleConditional_statement;
}


std::any VerilogParser::Conditional_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConditional_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Conditional_statementContext* VerilogParser::conditional_statement() {
  Conditional_statementContext *_localctx = _tracker.createInstance<Conditional_statementContext>(_ctx, getState());
  enterRule(_localctx, 394, VerilogParser::RuleConditional_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3033);
    match(VerilogParser::IF);
    setState(3034);
    match(VerilogParser::LP);
    setState(3035);
    expression(0);
    setState(3036);
    match(VerilogParser::RP);
    setState(3037);
    statement_or_null();
    setState(3040);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
    case 1: {
      setState(3038);
      match(VerilogParser::ELSE);
      setState(3039);
      statement_or_null();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_statementContext ------------------------------------------------------------------

VerilogParser::Case_statementContext::Case_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Case_statementContext::CASE() {
  return getToken(VerilogParser::CASE, 0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Case_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::ENDCASE() {
  return getToken(VerilogParser::ENDCASE, 0);
}

std::vector<VerilogParser::Case_itemContext *> VerilogParser::Case_statementContext::case_item() {
  return getRuleContexts<VerilogParser::Case_itemContext>();
}

VerilogParser::Case_itemContext* VerilogParser::Case_statementContext::case_item(size_t i) {
  return getRuleContext<VerilogParser::Case_itemContext>(i);
}

tree::TerminalNode* VerilogParser::Case_statementContext::CASEZ() {
  return getToken(VerilogParser::CASEZ, 0);
}

tree::TerminalNode* VerilogParser::Case_statementContext::CASEX() {
  return getToken(VerilogParser::CASEX, 0);
}


size_t VerilogParser::Case_statementContext::getRuleIndex() const {
  return VerilogParser::RuleCase_statement;
}


std::any VerilogParser::Case_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_statementContext* VerilogParser::case_statement() {
  Case_statementContext *_localctx = _tracker.createInstance<Case_statementContext>(_ctx, getState());
  enterRule(_localctx, 396, VerilogParser::RuleCase_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3075);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::CASE: {
        enterOuterAlt(_localctx, 1);
        setState(3042);
        match(VerilogParser::CASE);
        setState(3043);
        match(VerilogParser::LP);
        setState(3044);
        expression(0);
        setState(3045);
        match(VerilogParser::RP);
        setState(3047); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(3046);
          case_item();
          setState(3049); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 281475112042500) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 161)) & 1098706452503) != 0);
        setState(3051);
        match(VerilogParser::ENDCASE);
        break;
      }

      case VerilogParser::CASEZ: {
        enterOuterAlt(_localctx, 2);
        setState(3053);
        match(VerilogParser::CASEZ);
        setState(3054);
        match(VerilogParser::LP);
        setState(3055);
        expression(0);
        setState(3056);
        match(VerilogParser::RP);
        setState(3058); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(3057);
          case_item();
          setState(3060); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 281475112042500) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 161)) & 1098706452503) != 0);
        setState(3062);
        match(VerilogParser::ENDCASE);
        break;
      }

      case VerilogParser::CASEX: {
        enterOuterAlt(_localctx, 3);
        setState(3064);
        match(VerilogParser::CASEX);
        setState(3065);
        match(VerilogParser::LP);
        setState(3066);
        expression(0);
        setState(3067);
        match(VerilogParser::RP);
        setState(3069); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(3068);
          case_item();
          setState(3071); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 281475112042500) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 161)) & 1098706452503) != 0);
        setState(3073);
        match(VerilogParser::ENDCASE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_itemContext ------------------------------------------------------------------

VerilogParser::Case_itemContext::Case_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Case_itemContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Case_itemContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Case_itemContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Statement_or_nullContext* VerilogParser::Case_itemContext::statement_or_null() {
  return getRuleContext<VerilogParser::Statement_or_nullContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Case_itemContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Case_itemContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

tree::TerminalNode* VerilogParser::Case_itemContext::DEFAULT() {
  return getToken(VerilogParser::DEFAULT, 0);
}


size_t VerilogParser::Case_itemContext::getRuleIndex() const {
  return VerilogParser::RuleCase_item;
}


std::any VerilogParser::Case_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCase_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Case_itemContext* VerilogParser::case_item() {
  Case_itemContext *_localctx = _tracker.createInstance<Case_itemContext>(_ctx, getState());
  enterRule(_localctx, 398, VerilogParser::RuleCase_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3093);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::CATI:
      case VerilogParser::EM:
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(3077);
        expression(0);
        setState(3082);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(3078);
          match(VerilogParser::CO);
          setState(3079);
          expression(0);
          setState(3084);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3085);
        match(VerilogParser::CL);
        setState(3086);
        statement_or_null();
        break;
      }

      case VerilogParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(3088);
        match(VerilogParser::DEFAULT);
        setState(3090);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::CL) {
          setState(3089);
          match(VerilogParser::CL);
        }
        setState(3092);
        statement_or_null();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_statementContext ------------------------------------------------------------------

VerilogParser::Loop_statementContext::Loop_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Loop_statementContext::FOREVER() {
  return getToken(VerilogParser::FOREVER, 0);
}

VerilogParser::StatementContext* VerilogParser::Loop_statementContext::statement() {
  return getRuleContext<VerilogParser::StatementContext>(0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::REPEAT() {
  return getToken(VerilogParser::REPEAT, 0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::ExpressionContext* VerilogParser::Loop_statementContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::WHILE() {
  return getToken(VerilogParser::WHILE, 0);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::FOR() {
  return getToken(VerilogParser::FOR, 0);
}

std::vector<VerilogParser::Variable_assignmentContext *> VerilogParser::Loop_statementContext::variable_assignment() {
  return getRuleContexts<VerilogParser::Variable_assignmentContext>();
}

VerilogParser::Variable_assignmentContext* VerilogParser::Loop_statementContext::variable_assignment(size_t i) {
  return getRuleContext<VerilogParser::Variable_assignmentContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Loop_statementContext::SC() {
  return getTokens(VerilogParser::SC);
}

tree::TerminalNode* VerilogParser::Loop_statementContext::SC(size_t i) {
  return getToken(VerilogParser::SC, i);
}


size_t VerilogParser::Loop_statementContext::getRuleIndex() const {
  return VerilogParser::RuleLoop_statement;
}


std::any VerilogParser::Loop_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLoop_statement(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Loop_statementContext* VerilogParser::loop_statement() {
  Loop_statementContext *_localctx = _tracker.createInstance<Loop_statementContext>(_ctx, getState());
  enterRule(_localctx, 400, VerilogParser::RuleLoop_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3119);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::FOREVER: {
        enterOuterAlt(_localctx, 1);
        setState(3095);
        match(VerilogParser::FOREVER);
        setState(3096);
        statement();
        break;
      }

      case VerilogParser::REPEAT: {
        enterOuterAlt(_localctx, 2);
        setState(3097);
        match(VerilogParser::REPEAT);
        setState(3098);
        match(VerilogParser::LP);
        setState(3099);
        expression(0);
        setState(3100);
        match(VerilogParser::RP);
        setState(3101);
        statement();
        break;
      }

      case VerilogParser::WHILE: {
        enterOuterAlt(_localctx, 3);
        setState(3103);
        match(VerilogParser::WHILE);
        setState(3104);
        match(VerilogParser::LP);
        setState(3105);
        expression(0);
        setState(3106);
        match(VerilogParser::RP);
        setState(3107);
        statement();
        break;
      }

      case VerilogParser::FOR: {
        enterOuterAlt(_localctx, 4);
        setState(3109);
        match(VerilogParser::FOR);
        setState(3110);
        match(VerilogParser::LP);
        setState(3111);
        variable_assignment();
        setState(3112);
        match(VerilogParser::SC);
        setState(3113);
        expression(0);
        setState(3114);
        match(VerilogParser::SC);
        setState(3115);
        variable_assignment();
        setState(3116);
        match(VerilogParser::RP);
        setState(3117);
        statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_task_enableContext ------------------------------------------------------------------

VerilogParser::System_task_enableContext::System_task_enableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::System_task_identifierContext* VerilogParser::System_task_enableContext::system_task_identifier() {
  return getRuleContext<VerilogParser::System_task_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::System_task_enableContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Sys_task_en_port_listContext* VerilogParser::System_task_enableContext::sys_task_en_port_list() {
  return getRuleContext<VerilogParser::Sys_task_en_port_listContext>(0);
}


size_t VerilogParser::System_task_enableContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_task_enable;
}


std::any VerilogParser::System_task_enableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_task_enable(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_task_enableContext* VerilogParser::system_task_enable() {
  System_task_enableContext *_localctx = _tracker.createInstance<System_task_enableContext>(_ctx, getState());
  enterRule(_localctx, 402, VerilogParser::RuleSystem_task_enable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3121);
    system_task_identifier();
    setState(3123);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(3122);
      sys_task_en_port_list();
    }
    setState(3125);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sys_task_en_port_listContext ------------------------------------------------------------------

VerilogParser::Sys_task_en_port_listContext::Sys_task_en_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Sys_task_en_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Sys_task_en_port_itemContext *> VerilogParser::Sys_task_en_port_listContext::sys_task_en_port_item() {
  return getRuleContexts<VerilogParser::Sys_task_en_port_itemContext>();
}

VerilogParser::Sys_task_en_port_itemContext* VerilogParser::Sys_task_en_port_listContext::sys_task_en_port_item(size_t i) {
  return getRuleContext<VerilogParser::Sys_task_en_port_itemContext>(i);
}

tree::TerminalNode* VerilogParser::Sys_task_en_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Sys_task_en_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Sys_task_en_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Sys_task_en_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleSys_task_en_port_list;
}


std::any VerilogParser::Sys_task_en_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSys_task_en_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sys_task_en_port_listContext* VerilogParser::sys_task_en_port_list() {
  Sys_task_en_port_listContext *_localctx = _tracker.createInstance<Sys_task_en_port_listContext>(_ctx, getState());
  enterRule(_localctx, 404, VerilogParser::RuleSys_task_en_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3127);
    match(VerilogParser::LP);
    setState(3128);
    sys_task_en_port_item();
    setState(3133);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3129);
      match(VerilogParser::CO);
      setState(3130);
      sys_task_en_port_item();
      setState(3135);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3136);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sys_task_en_port_itemContext ------------------------------------------------------------------

VerilogParser::Sys_task_en_port_itemContext::Sys_task_en_port_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Sys_task_en_port_itemContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Sys_task_en_port_itemContext::getRuleIndex() const {
  return VerilogParser::RuleSys_task_en_port_item;
}


std::any VerilogParser::Sys_task_en_port_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSys_task_en_port_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sys_task_en_port_itemContext* VerilogParser::sys_task_en_port_item() {
  Sys_task_en_port_itemContext *_localctx = _tracker.createInstance<Sys_task_en_port_itemContext>(_ctx, getState());
  enterRule(_localctx, 406, VerilogParser::RuleSys_task_en_port_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3139);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281474977824772) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 1098706452503) != 0) {
      setState(3138);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_enableContext ------------------------------------------------------------------

VerilogParser::Task_enableContext::Task_enableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Task_enableContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Task_enableContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Task_en_port_listContext* VerilogParser::Task_enableContext::task_en_port_list() {
  return getRuleContext<VerilogParser::Task_en_port_listContext>(0);
}


size_t VerilogParser::Task_enableContext::getRuleIndex() const {
  return VerilogParser::RuleTask_enable;
}


std::any VerilogParser::Task_enableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_enable(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_enableContext* VerilogParser::task_enable() {
  Task_enableContext *_localctx = _tracker.createInstance<Task_enableContext>(_ctx, getState());
  enterRule(_localctx, 408, VerilogParser::RuleTask_enable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3141);
    hierarchical_identifier();
    setState(3143);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LP) {
      setState(3142);
      task_en_port_list();
    }
    setState(3145);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_en_port_listContext ------------------------------------------------------------------

VerilogParser::Task_en_port_listContext::Task_en_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Task_en_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Task_en_port_listContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Task_en_port_listContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Task_en_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Task_en_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Task_en_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Task_en_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleTask_en_port_list;
}


std::any VerilogParser::Task_en_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_en_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_en_port_listContext* VerilogParser::task_en_port_list() {
  Task_en_port_listContext *_localctx = _tracker.createInstance<Task_en_port_listContext>(_ctx, getState());
  enterRule(_localctx, 410, VerilogParser::RuleTask_en_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3147);
    match(VerilogParser::LP);
    setState(3148);
    expression(0);
    setState(3153);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3149);
      match(VerilogParser::CO);
      setState(3150);
      expression(0);
      setState(3155);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3156);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_blockContext ------------------------------------------------------------------

VerilogParser::Specify_blockContext::Specify_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Specify_blockContext::SPECIFY() {
  return getToken(VerilogParser::SPECIFY, 0);
}

tree::TerminalNode* VerilogParser::Specify_blockContext::ENDSPECIFY() {
  return getToken(VerilogParser::ENDSPECIFY, 0);
}

std::vector<VerilogParser::Specify_itemContext *> VerilogParser::Specify_blockContext::specify_item() {
  return getRuleContexts<VerilogParser::Specify_itemContext>();
}

VerilogParser::Specify_itemContext* VerilogParser::Specify_blockContext::specify_item(size_t i) {
  return getRuleContext<VerilogParser::Specify_itemContext>(i);
}


size_t VerilogParser::Specify_blockContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_block;
}


std::any VerilogParser::Specify_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_block(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_blockContext* VerilogParser::specify_block() {
  Specify_blockContext *_localctx = _tracker.createInstance<Specify_blockContext>(_ctx, getState());
  enterRule(_localctx, 412, VerilogParser::RuleSpecify_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3158);
    match(VerilogParser::SPECIFY);
    setState(3162);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la - 32) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 32)) & 1688849860268031) != 0 || (((_la - 96) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 96)) & 297237626946191361) != 0) {
      setState(3159);
      specify_item();
      setState(3164);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3165);
    match(VerilogParser::ENDSPECIFY);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_itemContext ------------------------------------------------------------------

VerilogParser::Specify_itemContext::Specify_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specparam_declarationContext* VerilogParser::Specify_itemContext::specparam_declaration() {
  return getRuleContext<VerilogParser::Specparam_declarationContext>(0);
}

VerilogParser::Pulsestyle_declarationContext* VerilogParser::Specify_itemContext::pulsestyle_declaration() {
  return getRuleContext<VerilogParser::Pulsestyle_declarationContext>(0);
}

VerilogParser::Showcancelled_declarationContext* VerilogParser::Specify_itemContext::showcancelled_declaration() {
  return getRuleContext<VerilogParser::Showcancelled_declarationContext>(0);
}

VerilogParser::Path_declarationContext* VerilogParser::Specify_itemContext::path_declaration() {
  return getRuleContext<VerilogParser::Path_declarationContext>(0);
}

VerilogParser::System_timing_checkContext* VerilogParser::Specify_itemContext::system_timing_check() {
  return getRuleContext<VerilogParser::System_timing_checkContext>(0);
}


size_t VerilogParser::Specify_itemContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_item;
}


std::any VerilogParser::Specify_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_item(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_itemContext* VerilogParser::specify_item() {
  Specify_itemContext *_localctx = _tracker.createInstance<Specify_itemContext>(_ctx, getState());
  enterRule(_localctx, 414, VerilogParser::RuleSpecify_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3172);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::SPECPARAM: {
        enterOuterAlt(_localctx, 1);
        setState(3167);
        specparam_declaration();
        break;
      }

      case VerilogParser::PULSESTYLE_ONDETECT:
      case VerilogParser::PULSESTYLE_ONEVENT: {
        enterOuterAlt(_localctx, 2);
        setState(3168);
        pulsestyle_declaration();
        break;
      }

      case VerilogParser::NOSHOWCANCELLED:
      case VerilogParser::SHOWCANCELLED: {
        enterOuterAlt(_localctx, 3);
        setState(3169);
        showcancelled_declaration();
        break;
      }

      case VerilogParser::IF:
      case VerilogParser::IFNONE:
      case VerilogParser::LP: {
        enterOuterAlt(_localctx, 4);
        setState(3170);
        path_declaration();
        break;
      }

      case VerilogParser::DLFULLSKEW:
      case VerilogParser::DLHOLD:
      case VerilogParser::DLNOCHANGE:
      case VerilogParser::DLPERIOD:
      case VerilogParser::DLRECOVERY:
      case VerilogParser::DLRECREM:
      case VerilogParser::DLREMOVAL:
      case VerilogParser::DLSETUP:
      case VerilogParser::DLSETUPHOLD:
      case VerilogParser::DLSKEW:
      case VerilogParser::DLTIMESKEW:
      case VerilogParser::DLWIDTH: {
        enterOuterAlt(_localctx, 5);
        setState(3171);
        system_timing_check();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pulsestyle_declarationContext ------------------------------------------------------------------

VerilogParser::Pulsestyle_declarationContext::Pulsestyle_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Pulsestyle_declarationContext::PULSESTYLE_ONEVENT() {
  return getToken(VerilogParser::PULSESTYLE_ONEVENT, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Pulsestyle_declarationContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Pulsestyle_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Pulsestyle_declarationContext::PULSESTYLE_ONDETECT() {
  return getToken(VerilogParser::PULSESTYLE_ONDETECT, 0);
}


size_t VerilogParser::Pulsestyle_declarationContext::getRuleIndex() const {
  return VerilogParser::RulePulsestyle_declaration;
}


std::any VerilogParser::Pulsestyle_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPulsestyle_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Pulsestyle_declarationContext* VerilogParser::pulsestyle_declaration() {
  Pulsestyle_declarationContext *_localctx = _tracker.createInstance<Pulsestyle_declarationContext>(_ctx, getState());
  enterRule(_localctx, 416, VerilogParser::RulePulsestyle_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3182);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::PULSESTYLE_ONEVENT: {
        enterOuterAlt(_localctx, 1);
        setState(3174);
        match(VerilogParser::PULSESTYLE_ONEVENT);
        setState(3175);
        list_of_path_outputs();
        setState(3176);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::PULSESTYLE_ONDETECT: {
        enterOuterAlt(_localctx, 2);
        setState(3178);
        match(VerilogParser::PULSESTYLE_ONDETECT);
        setState(3179);
        list_of_path_outputs();
        setState(3180);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Showcancelled_declarationContext ------------------------------------------------------------------

VerilogParser::Showcancelled_declarationContext::Showcancelled_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Showcancelled_declarationContext::SHOWCANCELLED() {
  return getToken(VerilogParser::SHOWCANCELLED, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Showcancelled_declarationContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Showcancelled_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

tree::TerminalNode* VerilogParser::Showcancelled_declarationContext::NOSHOWCANCELLED() {
  return getToken(VerilogParser::NOSHOWCANCELLED, 0);
}


size_t VerilogParser::Showcancelled_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleShowcancelled_declaration;
}


std::any VerilogParser::Showcancelled_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitShowcancelled_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Showcancelled_declarationContext* VerilogParser::showcancelled_declaration() {
  Showcancelled_declarationContext *_localctx = _tracker.createInstance<Showcancelled_declarationContext>(_ctx, getState());
  enterRule(_localctx, 418, VerilogParser::RuleShowcancelled_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3192);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::SHOWCANCELLED: {
        enterOuterAlt(_localctx, 1);
        setState(3184);
        match(VerilogParser::SHOWCANCELLED);
        setState(3185);
        list_of_path_outputs();
        setState(3186);
        match(VerilogParser::SC);
        break;
      }

      case VerilogParser::NOSHOWCANCELLED: {
        enterOuterAlt(_localctx, 2);
        setState(3188);
        match(VerilogParser::NOSHOWCANCELLED);
        setState(3189);
        list_of_path_outputs();
        setState(3190);
        match(VerilogParser::SC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_declarationContext ------------------------------------------------------------------

VerilogParser::Path_declarationContext::Path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Simple_path_declarationContext* VerilogParser::Path_declarationContext::simple_path_declaration() {
  return getRuleContext<VerilogParser::Simple_path_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::Path_declarationContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Edge_sensitive_path_declarationContext* VerilogParser::Path_declarationContext::edge_sensitive_path_declaration() {
  return getRuleContext<VerilogParser::Edge_sensitive_path_declarationContext>(0);
}

VerilogParser::State_dependent_path_declarationContext* VerilogParser::Path_declarationContext::state_dependent_path_declaration() {
  return getRuleContext<VerilogParser::State_dependent_path_declarationContext>(0);
}


size_t VerilogParser::Path_declarationContext::getRuleIndex() const {
  return VerilogParser::RulePath_declaration;
}


std::any VerilogParser::Path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPath_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Path_declarationContext* VerilogParser::path_declaration() {
  Path_declarationContext *_localctx = _tracker.createInstance<Path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 420, VerilogParser::RulePath_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3203);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3194);
      simple_path_declaration();
      setState(3195);
      match(VerilogParser::SC);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3197);
      edge_sensitive_path_declaration();
      setState(3198);
      match(VerilogParser::SC);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3200);
      state_dependent_path_declaration();
      setState(3201);
      match(VerilogParser::SC);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_path_declarationContext ------------------------------------------------------------------

VerilogParser::Simple_path_declarationContext::Simple_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Parallel_path_descriptionContext* VerilogParser::Simple_path_declarationContext::parallel_path_description() {
  return getRuleContext<VerilogParser::Parallel_path_descriptionContext>(0);
}

tree::TerminalNode* VerilogParser::Simple_path_declarationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Path_delay_valueContext* VerilogParser::Simple_path_declarationContext::path_delay_value() {
  return getRuleContext<VerilogParser::Path_delay_valueContext>(0);
}

VerilogParser::Full_path_descriptionContext* VerilogParser::Simple_path_declarationContext::full_path_description() {
  return getRuleContext<VerilogParser::Full_path_descriptionContext>(0);
}


size_t VerilogParser::Simple_path_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleSimple_path_declaration;
}


std::any VerilogParser::Simple_path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSimple_path_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Simple_path_declarationContext* VerilogParser::simple_path_declaration() {
  Simple_path_declarationContext *_localctx = _tracker.createInstance<Simple_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 422, VerilogParser::RuleSimple_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3213);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3205);
      parallel_path_description();
      setState(3206);
      match(VerilogParser::EQ);
      setState(3207);
      path_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3209);
      full_path_description();
      setState(3210);
      match(VerilogParser::EQ);
      setState(3211);
      path_delay_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parallel_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Parallel_path_descriptionContext::Parallel_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Parallel_path_descriptionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Parallel_path_descriptionContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_path_descriptionContext::EQGT() {
  return getToken(VerilogParser::EQGT, 0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Parallel_path_descriptionContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_path_descriptionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Parallel_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Parallel_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleParallel_path_description;
}


std::any VerilogParser::Parallel_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParallel_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parallel_path_descriptionContext* VerilogParser::parallel_path_description() {
  Parallel_path_descriptionContext *_localctx = _tracker.createInstance<Parallel_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 424, VerilogParser::RuleParallel_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3215);
    match(VerilogParser::LP);
    setState(3216);
    specify_input_terminal_descriptor();
    setState(3218);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3217);
      polarity_operator();
    }
    setState(3220);
    match(VerilogParser::EQGT);
    setState(3221);
    specify_output_terminal_descriptor();
    setState(3222);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Full_path_descriptionContext::Full_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Full_path_descriptionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::List_of_path_inputsContext* VerilogParser::Full_path_descriptionContext::list_of_path_inputs() {
  return getRuleContext<VerilogParser::List_of_path_inputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_path_descriptionContext::ASGT() {
  return getToken(VerilogParser::ASGT, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Full_path_descriptionContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_path_descriptionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Full_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Full_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleFull_path_description;
}


std::any VerilogParser::Full_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFull_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Full_path_descriptionContext* VerilogParser::full_path_description() {
  Full_path_descriptionContext *_localctx = _tracker.createInstance<Full_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 426, VerilogParser::RuleFull_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3224);
    match(VerilogParser::LP);
    setState(3225);
    list_of_path_inputs();
    setState(3227);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3226);
      polarity_operator();
    }
    setState(3229);
    match(VerilogParser::ASGT);
    setState(3230);
    list_of_path_outputs();
    setState(3231);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_inputsContext ------------------------------------------------------------------

VerilogParser::List_of_path_inputsContext::List_of_path_inputsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Specify_input_terminal_descriptorContext *> VerilogParser::List_of_path_inputsContext::specify_input_terminal_descriptor() {
  return getRuleContexts<VerilogParser::Specify_input_terminal_descriptorContext>();
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::List_of_path_inputsContext::specify_input_terminal_descriptor(size_t i) {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_path_inputsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_path_inputsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_path_inputsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_path_inputs;
}


std::any VerilogParser::List_of_path_inputsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_path_inputs(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_path_inputsContext* VerilogParser::list_of_path_inputs() {
  List_of_path_inputsContext *_localctx = _tracker.createInstance<List_of_path_inputsContext>(_ctx, getState());
  enterRule(_localctx, 428, VerilogParser::RuleList_of_path_inputs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3233);
    specify_input_terminal_descriptor();
    setState(3238);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3234);
      match(VerilogParser::CO);
      setState(3235);
      specify_input_terminal_descriptor();
      setState(3240);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_outputsContext ------------------------------------------------------------------

VerilogParser::List_of_path_outputsContext::List_of_path_outputsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Specify_output_terminal_descriptorContext *> VerilogParser::List_of_path_outputsContext::specify_output_terminal_descriptor() {
  return getRuleContexts<VerilogParser::Specify_output_terminal_descriptorContext>();
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::List_of_path_outputsContext::specify_output_terminal_descriptor(size_t i) {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_path_outputsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_path_outputsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::List_of_path_outputsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_path_outputs;
}


std::any VerilogParser::List_of_path_outputsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_path_outputs(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::list_of_path_outputs() {
  List_of_path_outputsContext *_localctx = _tracker.createInstance<List_of_path_outputsContext>(_ctx, getState());
  enterRule(_localctx, 430, VerilogParser::RuleList_of_path_outputs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3241);
    specify_output_terminal_descriptor();
    setState(3246);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3242);
      match(VerilogParser::CO);
      setState(3243);
      specify_output_terminal_descriptor();
      setState(3248);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_input_terminal_descriptorContext ------------------------------------------------------------------

VerilogParser::Specify_input_terminal_descriptorContext::Specify_input_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Input_identifierContext* VerilogParser::Specify_input_terminal_descriptorContext::input_identifier() {
  return getRuleContext<VerilogParser::Input_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_input_terminal_descriptorContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Specify_input_terminal_descriptorContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_input_terminal_descriptorContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Specify_input_terminal_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_input_terminal_descriptor;
}


std::any VerilogParser::Specify_input_terminal_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_input_terminal_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::specify_input_terminal_descriptor() {
  Specify_input_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_input_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 432, VerilogParser::RuleSpecify_input_terminal_descriptor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3249);
    input_identifier();
    setState(3254);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3250);
      match(VerilogParser::LB);
      setState(3251);
      constant_range_expression();
      setState(3252);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_output_terminal_descriptorContext ------------------------------------------------------------------

VerilogParser::Specify_output_terminal_descriptorContext::Specify_output_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Output_identifierContext* VerilogParser::Specify_output_terminal_descriptorContext::output_identifier() {
  return getRuleContext<VerilogParser::Output_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_output_terminal_descriptorContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Specify_output_terminal_descriptorContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Specify_output_terminal_descriptorContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Specify_output_terminal_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_output_terminal_descriptor;
}


std::any VerilogParser::Specify_output_terminal_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_output_terminal_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::specify_output_terminal_descriptor() {
  Specify_output_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_output_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 434, VerilogParser::RuleSpecify_output_terminal_descriptor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3256);
    output_identifier();
    setState(3261);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3257);
      match(VerilogParser::LB);
      setState(3258);
      constant_range_expression();
      setState(3259);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_identifierContext ------------------------------------------------------------------

VerilogParser::Input_identifierContext::Input_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Input_identifierContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}


size_t VerilogParser::Input_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleInput_identifier;
}


std::any VerilogParser::Input_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_identifierContext* VerilogParser::input_identifier() {
  Input_identifierContext *_localctx = _tracker.createInstance<Input_identifierContext>(_ctx, getState());
  enterRule(_localctx, 436, VerilogParser::RuleInput_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3263);
    port_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_identifierContext ------------------------------------------------------------------

VerilogParser::Output_identifierContext::Output_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Port_identifierContext* VerilogParser::Output_identifierContext::port_identifier() {
  return getRuleContext<VerilogParser::Port_identifierContext>(0);
}


size_t VerilogParser::Output_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_identifier;
}


std::any VerilogParser::Output_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_identifierContext* VerilogParser::output_identifier() {
  Output_identifierContext *_localctx = _tracker.createInstance<Output_identifierContext>(_ctx, getState());
  enterRule(_localctx, 438, VerilogParser::RuleOutput_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3265);
    port_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_delay_valueContext ------------------------------------------------------------------

VerilogParser::Path_delay_valueContext::Path_delay_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::List_of_path_delay_expressionsContext* VerilogParser::Path_delay_valueContext::list_of_path_delay_expressions() {
  return getRuleContext<VerilogParser::List_of_path_delay_expressionsContext>(0);
}

tree::TerminalNode* VerilogParser::Path_delay_valueContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Path_delay_valueContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Path_delay_valueContext::getRuleIndex() const {
  return VerilogParser::RulePath_delay_value;
}


std::any VerilogParser::Path_delay_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPath_delay_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Path_delay_valueContext* VerilogParser::path_delay_value() {
  Path_delay_valueContext *_localctx = _tracker.createInstance<Path_delay_valueContext>(_ctx, getState());
  enterRule(_localctx, 440, VerilogParser::RulePath_delay_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3272);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3267);
      list_of_path_delay_expressions();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3268);
      match(VerilogParser::LP);
      setState(3269);
      list_of_path_delay_expressions();
      setState(3270);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_of_path_delay_expressionsContext ------------------------------------------------------------------

VerilogParser::List_of_path_delay_expressionsContext::List_of_path_delay_expressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::T_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t_path_delay_expression() {
  return getRuleContext<VerilogParser::T_path_delay_expressionContext>(0);
}

VerilogParser::Trise_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::trise_path_delay_expression() {
  return getRuleContext<VerilogParser::Trise_path_delay_expressionContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::List_of_path_delay_expressionsContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::List_of_path_delay_expressionsContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Tfall_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tfall_path_delay_expression() {
  return getRuleContext<VerilogParser::Tfall_path_delay_expressionContext>(0);
}

VerilogParser::Tz_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tz_path_delay_expression() {
  return getRuleContext<VerilogParser::Tz_path_delay_expressionContext>(0);
}

VerilogParser::T01_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t01_path_delay_expression() {
  return getRuleContext<VerilogParser::T01_path_delay_expressionContext>(0);
}

VerilogParser::T10_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t10_path_delay_expression() {
  return getRuleContext<VerilogParser::T10_path_delay_expressionContext>(0);
}

VerilogParser::T0z_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t0z_path_delay_expression() {
  return getRuleContext<VerilogParser::T0z_path_delay_expressionContext>(0);
}

VerilogParser::Tz1_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tz1_path_delay_expression() {
  return getRuleContext<VerilogParser::Tz1_path_delay_expressionContext>(0);
}

VerilogParser::T1z_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t1z_path_delay_expression() {
  return getRuleContext<VerilogParser::T1z_path_delay_expressionContext>(0);
}

VerilogParser::Tz0_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tz0_path_delay_expression() {
  return getRuleContext<VerilogParser::Tz0_path_delay_expressionContext>(0);
}

VerilogParser::T0x_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t0x_path_delay_expression() {
  return getRuleContext<VerilogParser::T0x_path_delay_expressionContext>(0);
}

VerilogParser::Tx1_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tx1_path_delay_expression() {
  return getRuleContext<VerilogParser::Tx1_path_delay_expressionContext>(0);
}

VerilogParser::T1x_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::t1x_path_delay_expression() {
  return getRuleContext<VerilogParser::T1x_path_delay_expressionContext>(0);
}

VerilogParser::Tx0_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tx0_path_delay_expression() {
  return getRuleContext<VerilogParser::Tx0_path_delay_expressionContext>(0);
}

VerilogParser::Txz_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::txz_path_delay_expression() {
  return getRuleContext<VerilogParser::Txz_path_delay_expressionContext>(0);
}

VerilogParser::Tzx_path_delay_expressionContext* VerilogParser::List_of_path_delay_expressionsContext::tzx_path_delay_expression() {
  return getRuleContext<VerilogParser::Tzx_path_delay_expressionContext>(0);
}


size_t VerilogParser::List_of_path_delay_expressionsContext::getRuleIndex() const {
  return VerilogParser::RuleList_of_path_delay_expressions;
}


std::any VerilogParser::List_of_path_delay_expressionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitList_of_path_delay_expressions(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::List_of_path_delay_expressionsContext* VerilogParser::list_of_path_delay_expressions() {
  List_of_path_delay_expressionsContext *_localctx = _tracker.createInstance<List_of_path_delay_expressionsContext>(_ctx, getState());
  enterRule(_localctx, 442, VerilogParser::RuleList_of_path_delay_expressions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3308);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3274);
      t_path_delay_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3275);
      trise_path_delay_expression();
      setState(3276);
      match(VerilogParser::CO);
      setState(3277);
      tfall_path_delay_expression();
      setState(3280);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(3278);
        match(VerilogParser::CO);
        setState(3279);
        tz_path_delay_expression();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3282);
      t01_path_delay_expression();
      setState(3283);
      match(VerilogParser::CO);
      setState(3284);
      t10_path_delay_expression();
      setState(3285);
      match(VerilogParser::CO);
      setState(3286);
      t0z_path_delay_expression();
      setState(3287);
      match(VerilogParser::CO);
      setState(3288);
      tz1_path_delay_expression();
      setState(3289);
      match(VerilogParser::CO);
      setState(3290);
      t1z_path_delay_expression();
      setState(3291);
      match(VerilogParser::CO);
      setState(3292);
      tz0_path_delay_expression();
      setState(3306);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::CO) {
        setState(3293);
        match(VerilogParser::CO);
        setState(3294);
        t0x_path_delay_expression();
        setState(3295);
        match(VerilogParser::CO);
        setState(3296);
        tx1_path_delay_expression();
        setState(3297);
        match(VerilogParser::CO);
        setState(3298);
        t1x_path_delay_expression();
        setState(3299);
        match(VerilogParser::CO);
        setState(3300);
        tx0_path_delay_expression();
        setState(3301);
        match(VerilogParser::CO);
        setState(3302);
        txz_path_delay_expression();
        setState(3303);
        match(VerilogParser::CO);
        setState(3304);
        tzx_path_delay_expression();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T_path_delay_expressionContext::T_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT_path_delay_expression;
}


std::any VerilogParser::T_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T_path_delay_expressionContext* VerilogParser::t_path_delay_expression() {
  T_path_delay_expressionContext *_localctx = _tracker.createInstance<T_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 444, VerilogParser::RuleT_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3310);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trise_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Trise_path_delay_expressionContext::Trise_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Trise_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Trise_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTrise_path_delay_expression;
}


std::any VerilogParser::Trise_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTrise_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Trise_path_delay_expressionContext* VerilogParser::trise_path_delay_expression() {
  Trise_path_delay_expressionContext *_localctx = _tracker.createInstance<Trise_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 446, VerilogParser::RuleTrise_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3312);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tfall_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tfall_path_delay_expressionContext::Tfall_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tfall_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tfall_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTfall_path_delay_expression;
}


std::any VerilogParser::Tfall_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTfall_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tfall_path_delay_expressionContext* VerilogParser::tfall_path_delay_expression() {
  Tfall_path_delay_expressionContext *_localctx = _tracker.createInstance<Tfall_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 448, VerilogParser::RuleTfall_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3314);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tz_path_delay_expressionContext::Tz_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tz_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tz_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTz_path_delay_expression;
}


std::any VerilogParser::Tz_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTz_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tz_path_delay_expressionContext* VerilogParser::tz_path_delay_expression() {
  Tz_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 450, VerilogParser::RuleTz_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3316);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T01_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T01_path_delay_expressionContext::T01_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T01_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T01_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT01_path_delay_expression;
}


std::any VerilogParser::T01_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT01_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T01_path_delay_expressionContext* VerilogParser::t01_path_delay_expression() {
  T01_path_delay_expressionContext *_localctx = _tracker.createInstance<T01_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 452, VerilogParser::RuleT01_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3318);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T10_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T10_path_delay_expressionContext::T10_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T10_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T10_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT10_path_delay_expression;
}


std::any VerilogParser::T10_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT10_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T10_path_delay_expressionContext* VerilogParser::t10_path_delay_expression() {
  T10_path_delay_expressionContext *_localctx = _tracker.createInstance<T10_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 454, VerilogParser::RuleT10_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3320);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T0z_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T0z_path_delay_expressionContext::T0z_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T0z_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T0z_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT0z_path_delay_expression;
}


std::any VerilogParser::T0z_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT0z_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T0z_path_delay_expressionContext* VerilogParser::t0z_path_delay_expression() {
  T0z_path_delay_expressionContext *_localctx = _tracker.createInstance<T0z_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 456, VerilogParser::RuleT0z_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3322);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz1_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tz1_path_delay_expressionContext::Tz1_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tz1_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tz1_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTz1_path_delay_expression;
}


std::any VerilogParser::Tz1_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTz1_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tz1_path_delay_expressionContext* VerilogParser::tz1_path_delay_expression() {
  Tz1_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz1_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 458, VerilogParser::RuleTz1_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3324);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T1z_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T1z_path_delay_expressionContext::T1z_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T1z_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T1z_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT1z_path_delay_expression;
}


std::any VerilogParser::T1z_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT1z_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T1z_path_delay_expressionContext* VerilogParser::t1z_path_delay_expression() {
  T1z_path_delay_expressionContext *_localctx = _tracker.createInstance<T1z_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 460, VerilogParser::RuleT1z_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3326);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tz0_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tz0_path_delay_expressionContext::Tz0_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tz0_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tz0_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTz0_path_delay_expression;
}


std::any VerilogParser::Tz0_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTz0_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tz0_path_delay_expressionContext* VerilogParser::tz0_path_delay_expression() {
  Tz0_path_delay_expressionContext *_localctx = _tracker.createInstance<Tz0_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 462, VerilogParser::RuleTz0_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3328);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T0x_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T0x_path_delay_expressionContext::T0x_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T0x_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T0x_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT0x_path_delay_expression;
}


std::any VerilogParser::T0x_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT0x_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T0x_path_delay_expressionContext* VerilogParser::t0x_path_delay_expression() {
  T0x_path_delay_expressionContext *_localctx = _tracker.createInstance<T0x_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 464, VerilogParser::RuleT0x_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3330);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tx1_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tx1_path_delay_expressionContext::Tx1_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tx1_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tx1_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTx1_path_delay_expression;
}


std::any VerilogParser::Tx1_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTx1_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tx1_path_delay_expressionContext* VerilogParser::tx1_path_delay_expression() {
  Tx1_path_delay_expressionContext *_localctx = _tracker.createInstance<Tx1_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 466, VerilogParser::RuleTx1_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3332);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- T1x_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::T1x_path_delay_expressionContext::T1x_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::T1x_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::T1x_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleT1x_path_delay_expression;
}


std::any VerilogParser::T1x_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitT1x_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::T1x_path_delay_expressionContext* VerilogParser::t1x_path_delay_expression() {
  T1x_path_delay_expressionContext *_localctx = _tracker.createInstance<T1x_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 468, VerilogParser::RuleT1x_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3334);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tx0_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tx0_path_delay_expressionContext::Tx0_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tx0_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tx0_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTx0_path_delay_expression;
}


std::any VerilogParser::Tx0_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTx0_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tx0_path_delay_expressionContext* VerilogParser::tx0_path_delay_expression() {
  Tx0_path_delay_expressionContext *_localctx = _tracker.createInstance<Tx0_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 470, VerilogParser::RuleTx0_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3336);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Txz_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Txz_path_delay_expressionContext::Txz_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Txz_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Txz_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTxz_path_delay_expression;
}


std::any VerilogParser::Txz_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTxz_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Txz_path_delay_expressionContext* VerilogParser::txz_path_delay_expression() {
  Txz_path_delay_expressionContext *_localctx = _tracker.createInstance<Txz_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 472, VerilogParser::RuleTxz_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3338);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tzx_path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Tzx_path_delay_expressionContext::Tzx_path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Path_delay_expressionContext* VerilogParser::Tzx_path_delay_expressionContext::path_delay_expression() {
  return getRuleContext<VerilogParser::Path_delay_expressionContext>(0);
}


size_t VerilogParser::Tzx_path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleTzx_path_delay_expression;
}


std::any VerilogParser::Tzx_path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTzx_path_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Tzx_path_delay_expressionContext* VerilogParser::tzx_path_delay_expression() {
  Tzx_path_delay_expressionContext *_localctx = _tracker.createInstance<Tzx_path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 474, VerilogParser::RuleTzx_path_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3340);
    path_delay_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Path_delay_expressionContext ------------------------------------------------------------------

VerilogParser::Path_delay_expressionContext::Path_delay_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Path_delay_expressionContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}


size_t VerilogParser::Path_delay_expressionContext::getRuleIndex() const {
  return VerilogParser::RulePath_delay_expression;
}


std::any VerilogParser::Path_delay_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPath_delay_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Path_delay_expressionContext* VerilogParser::path_delay_expression() {
  Path_delay_expressionContext *_localctx = _tracker.createInstance<Path_delay_expressionContext>(_ctx, getState());
  enterRule(_localctx, 476, VerilogParser::RulePath_delay_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3342);
    constant_mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_sensitive_path_declarationContext ------------------------------------------------------------------

VerilogParser::Edge_sensitive_path_declarationContext::Edge_sensitive_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Parallel_edge_sensitive_path_descriptionContext* VerilogParser::Edge_sensitive_path_declarationContext::parallel_edge_sensitive_path_description() {
  return getRuleContext<VerilogParser::Parallel_edge_sensitive_path_descriptionContext>(0);
}

tree::TerminalNode* VerilogParser::Edge_sensitive_path_declarationContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Path_delay_valueContext* VerilogParser::Edge_sensitive_path_declarationContext::path_delay_value() {
  return getRuleContext<VerilogParser::Path_delay_valueContext>(0);
}

VerilogParser::Full_edge_sensitive_path_descriptionContext* VerilogParser::Edge_sensitive_path_declarationContext::full_edge_sensitive_path_description() {
  return getRuleContext<VerilogParser::Full_edge_sensitive_path_descriptionContext>(0);
}


size_t VerilogParser::Edge_sensitive_path_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_sensitive_path_declaration;
}


std::any VerilogParser::Edge_sensitive_path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_sensitive_path_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_sensitive_path_declarationContext* VerilogParser::edge_sensitive_path_declaration() {
  Edge_sensitive_path_declarationContext *_localctx = _tracker.createInstance<Edge_sensitive_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 478, VerilogParser::RuleEdge_sensitive_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3352);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3344);
      parallel_edge_sensitive_path_description();
      setState(3345);
      match(VerilogParser::EQ);
      setState(3346);
      path_delay_value();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3348);
      full_edge_sensitive_path_description();
      setState(3349);
      match(VerilogParser::EQ);
      setState(3350);
      path_delay_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parallel_edge_sensitive_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Parallel_edge_sensitive_path_descriptionContext::Parallel_edge_sensitive_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Parallel_edge_sensitive_path_descriptionContext::LP() {
  return getTokens(VerilogParser::LP);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::LP(size_t i) {
  return getToken(VerilogParser::LP, i);
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::EQGT() {
  return getToken(VerilogParser::EQGT, 0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Data_source_expressionContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::data_source_expression() {
  return getRuleContext<VerilogParser::Data_source_expressionContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Parallel_edge_sensitive_path_descriptionContext::RP() {
  return getTokens(VerilogParser::RP);
}

tree::TerminalNode* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::RP(size_t i) {
  return getToken(VerilogParser::RP, i);
}

VerilogParser::Edge_identifierContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::edge_identifier() {
  return getRuleContext<VerilogParser::Edge_identifierContext>(0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Parallel_edge_sensitive_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Parallel_edge_sensitive_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleParallel_edge_sensitive_path_description;
}


std::any VerilogParser::Parallel_edge_sensitive_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParallel_edge_sensitive_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parallel_edge_sensitive_path_descriptionContext* VerilogParser::parallel_edge_sensitive_path_description() {
  Parallel_edge_sensitive_path_descriptionContext *_localctx = _tracker.createInstance<Parallel_edge_sensitive_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 480, VerilogParser::RuleParallel_edge_sensitive_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3354);
    match(VerilogParser::LP);
    setState(3356);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::NEGEDGE

    || _la == VerilogParser::POSEDGE) {
      setState(3355);
      edge_identifier();
    }
    setState(3358);
    specify_input_terminal_descriptor();
    setState(3359);
    match(VerilogParser::EQGT);
    setState(3360);
    match(VerilogParser::LP);
    setState(3361);
    specify_output_terminal_descriptor();
    setState(3363);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3362);
      polarity_operator();
    }
    setState(3365);
    match(VerilogParser::CL);
    setState(3366);
    data_source_expression();
    setState(3367);
    match(VerilogParser::RP);
    setState(3368);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Full_edge_sensitive_path_descriptionContext ------------------------------------------------------------------

VerilogParser::Full_edge_sensitive_path_descriptionContext::Full_edge_sensitive_path_descriptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Full_edge_sensitive_path_descriptionContext::LP() {
  return getTokens(VerilogParser::LP);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::LP(size_t i) {
  return getToken(VerilogParser::LP, i);
}

VerilogParser::List_of_path_inputsContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::list_of_path_inputs() {
  return getRuleContext<VerilogParser::List_of_path_inputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::ASGT() {
  return getToken(VerilogParser::ASGT, 0);
}

VerilogParser::List_of_path_outputsContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::list_of_path_outputs() {
  return getRuleContext<VerilogParser::List_of_path_outputsContext>(0);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Data_source_expressionContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::data_source_expression() {
  return getRuleContext<VerilogParser::Data_source_expressionContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Full_edge_sensitive_path_descriptionContext::RP() {
  return getTokens(VerilogParser::RP);
}

tree::TerminalNode* VerilogParser::Full_edge_sensitive_path_descriptionContext::RP(size_t i) {
  return getToken(VerilogParser::RP, i);
}

VerilogParser::Edge_identifierContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::edge_identifier() {
  return getRuleContext<VerilogParser::Edge_identifierContext>(0);
}

VerilogParser::Polarity_operatorContext* VerilogParser::Full_edge_sensitive_path_descriptionContext::polarity_operator() {
  return getRuleContext<VerilogParser::Polarity_operatorContext>(0);
}


size_t VerilogParser::Full_edge_sensitive_path_descriptionContext::getRuleIndex() const {
  return VerilogParser::RuleFull_edge_sensitive_path_description;
}


std::any VerilogParser::Full_edge_sensitive_path_descriptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFull_edge_sensitive_path_description(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Full_edge_sensitive_path_descriptionContext* VerilogParser::full_edge_sensitive_path_description() {
  Full_edge_sensitive_path_descriptionContext *_localctx = _tracker.createInstance<Full_edge_sensitive_path_descriptionContext>(_ctx, getState());
  enterRule(_localctx, 482, VerilogParser::RuleFull_edge_sensitive_path_description);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3370);
    match(VerilogParser::LP);
    setState(3372);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::NEGEDGE

    || _la == VerilogParser::POSEDGE) {
      setState(3371);
      edge_identifier();
    }
    setState(3374);
    list_of_path_inputs();
    setState(3375);
    match(VerilogParser::ASGT);
    setState(3376);
    match(VerilogParser::LP);
    setState(3377);
    list_of_path_outputs();
    setState(3379);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::MI

    || _la == VerilogParser::PL) {
      setState(3378);
      polarity_operator();
    }
    setState(3381);
    match(VerilogParser::CL);
    setState(3382);
    data_source_expression();
    setState(3383);
    match(VerilogParser::RP);
    setState(3384);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_source_expressionContext ------------------------------------------------------------------

VerilogParser::Data_source_expressionContext::Data_source_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Data_source_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Data_source_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleData_source_expression;
}


std::any VerilogParser::Data_source_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitData_source_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Data_source_expressionContext* VerilogParser::data_source_expression() {
  Data_source_expressionContext *_localctx = _tracker.createInstance<Data_source_expressionContext>(_ctx, getState());
  enterRule(_localctx, 484, VerilogParser::RuleData_source_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3386);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_identifierContext ------------------------------------------------------------------

VerilogParser::Edge_identifierContext::Edge_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_identifierContext::POSEDGE() {
  return getToken(VerilogParser::POSEDGE, 0);
}

tree::TerminalNode* VerilogParser::Edge_identifierContext::NEGEDGE() {
  return getToken(VerilogParser::NEGEDGE, 0);
}


size_t VerilogParser::Edge_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_identifier;
}


std::any VerilogParser::Edge_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_identifierContext* VerilogParser::edge_identifier() {
  Edge_identifierContext *_localctx = _tracker.createInstance<Edge_identifierContext>(_ctx, getState());
  enterRule(_localctx, 486, VerilogParser::RuleEdge_identifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3388);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::NEGEDGE

    || _la == VerilogParser::POSEDGE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- State_dependent_path_declarationContext ------------------------------------------------------------------

VerilogParser::State_dependent_path_declarationContext::State_dependent_path_declarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::IF() {
  return getToken(VerilogParser::IF, 0);
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Module_path_expressionContext* VerilogParser::State_dependent_path_declarationContext::module_path_expression() {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::Simple_path_declarationContext* VerilogParser::State_dependent_path_declarationContext::simple_path_declaration() {
  return getRuleContext<VerilogParser::Simple_path_declarationContext>(0);
}

VerilogParser::Edge_sensitive_path_declarationContext* VerilogParser::State_dependent_path_declarationContext::edge_sensitive_path_declaration() {
  return getRuleContext<VerilogParser::Edge_sensitive_path_declarationContext>(0);
}

tree::TerminalNode* VerilogParser::State_dependent_path_declarationContext::IFNONE() {
  return getToken(VerilogParser::IFNONE, 0);
}


size_t VerilogParser::State_dependent_path_declarationContext::getRuleIndex() const {
  return VerilogParser::RuleState_dependent_path_declaration;
}


std::any VerilogParser::State_dependent_path_declarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitState_dependent_path_declaration(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::State_dependent_path_declarationContext* VerilogParser::state_dependent_path_declaration() {
  State_dependent_path_declarationContext *_localctx = _tracker.createInstance<State_dependent_path_declarationContext>(_ctx, getState());
  enterRule(_localctx, 488, VerilogParser::RuleState_dependent_path_declaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3404);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3390);
      match(VerilogParser::IF);
      setState(3391);
      match(VerilogParser::LP);
      setState(3392);
      module_path_expression(0);
      setState(3393);
      match(VerilogParser::RP);
      setState(3394);
      simple_path_declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3396);
      match(VerilogParser::IF);
      setState(3397);
      match(VerilogParser::LP);
      setState(3398);
      module_path_expression(0);
      setState(3399);
      match(VerilogParser::RP);
      setState(3400);
      edge_sensitive_path_declaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3402);
      match(VerilogParser::IFNONE);
      setState(3403);
      simple_path_declaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Polarity_operatorContext ------------------------------------------------------------------

VerilogParser::Polarity_operatorContext::Polarity_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Polarity_operatorContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::Polarity_operatorContext::MI() {
  return getToken(VerilogParser::MI, 0);
}


size_t VerilogParser::Polarity_operatorContext::getRuleIndex() const {
  return VerilogParser::RulePolarity_operator;
}


std::any VerilogParser::Polarity_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPolarity_operator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Polarity_operatorContext* VerilogParser::polarity_operator() {
  Polarity_operatorContext *_localctx = _tracker.createInstance<Polarity_operatorContext>(_ctx, getState());
  enterRule(_localctx, 490, VerilogParser::RulePolarity_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3406);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::MI

    || _la == VerilogParser::PL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_timing_checkContext ------------------------------------------------------------------

VerilogParser::System_timing_checkContext::System_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Setup_timing_checkContext* VerilogParser::System_timing_checkContext::setup_timing_check() {
  return getRuleContext<VerilogParser::Setup_timing_checkContext>(0);
}

VerilogParser::Hold_timing_checkContext* VerilogParser::System_timing_checkContext::hold_timing_check() {
  return getRuleContext<VerilogParser::Hold_timing_checkContext>(0);
}

VerilogParser::Setuphold_timing_checkContext* VerilogParser::System_timing_checkContext::setuphold_timing_check() {
  return getRuleContext<VerilogParser::Setuphold_timing_checkContext>(0);
}

VerilogParser::Recovery_timing_checkContext* VerilogParser::System_timing_checkContext::recovery_timing_check() {
  return getRuleContext<VerilogParser::Recovery_timing_checkContext>(0);
}

VerilogParser::Removal_timing_checkContext* VerilogParser::System_timing_checkContext::removal_timing_check() {
  return getRuleContext<VerilogParser::Removal_timing_checkContext>(0);
}

VerilogParser::Recrem_timing_checkContext* VerilogParser::System_timing_checkContext::recrem_timing_check() {
  return getRuleContext<VerilogParser::Recrem_timing_checkContext>(0);
}

VerilogParser::Skew_timing_checkContext* VerilogParser::System_timing_checkContext::skew_timing_check() {
  return getRuleContext<VerilogParser::Skew_timing_checkContext>(0);
}

VerilogParser::Timeskew_timing_checkContext* VerilogParser::System_timing_checkContext::timeskew_timing_check() {
  return getRuleContext<VerilogParser::Timeskew_timing_checkContext>(0);
}

VerilogParser::Fullskew_timing_checkContext* VerilogParser::System_timing_checkContext::fullskew_timing_check() {
  return getRuleContext<VerilogParser::Fullskew_timing_checkContext>(0);
}

VerilogParser::Period_timing_checkContext* VerilogParser::System_timing_checkContext::period_timing_check() {
  return getRuleContext<VerilogParser::Period_timing_checkContext>(0);
}

VerilogParser::Width_timing_checkContext* VerilogParser::System_timing_checkContext::width_timing_check() {
  return getRuleContext<VerilogParser::Width_timing_checkContext>(0);
}

VerilogParser::Nochange_timing_checkContext* VerilogParser::System_timing_checkContext::nochange_timing_check() {
  return getRuleContext<VerilogParser::Nochange_timing_checkContext>(0);
}


size_t VerilogParser::System_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_timing_check;
}


std::any VerilogParser::System_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_timing_checkContext* VerilogParser::system_timing_check() {
  System_timing_checkContext *_localctx = _tracker.createInstance<System_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 492, VerilogParser::RuleSystem_timing_check);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3420);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::DLSETUP: {
        enterOuterAlt(_localctx, 1);
        setState(3408);
        setup_timing_check();
        break;
      }

      case VerilogParser::DLHOLD: {
        enterOuterAlt(_localctx, 2);
        setState(3409);
        hold_timing_check();
        break;
      }

      case VerilogParser::DLSETUPHOLD: {
        enterOuterAlt(_localctx, 3);
        setState(3410);
        setuphold_timing_check();
        break;
      }

      case VerilogParser::DLRECOVERY: {
        enterOuterAlt(_localctx, 4);
        setState(3411);
        recovery_timing_check();
        break;
      }

      case VerilogParser::DLREMOVAL: {
        enterOuterAlt(_localctx, 5);
        setState(3412);
        removal_timing_check();
        break;
      }

      case VerilogParser::DLRECREM: {
        enterOuterAlt(_localctx, 6);
        setState(3413);
        recrem_timing_check();
        break;
      }

      case VerilogParser::DLSKEW: {
        enterOuterAlt(_localctx, 7);
        setState(3414);
        skew_timing_check();
        break;
      }

      case VerilogParser::DLTIMESKEW: {
        enterOuterAlt(_localctx, 8);
        setState(3415);
        timeskew_timing_check();
        break;
      }

      case VerilogParser::DLFULLSKEW: {
        enterOuterAlt(_localctx, 9);
        setState(3416);
        fullskew_timing_check();
        break;
      }

      case VerilogParser::DLPERIOD: {
        enterOuterAlt(_localctx, 10);
        setState(3417);
        period_timing_check();
        break;
      }

      case VerilogParser::DLWIDTH: {
        enterOuterAlt(_localctx, 11);
        setState(3418);
        width_timing_check();
        break;
      }

      case VerilogParser::DLNOCHANGE: {
        enterOuterAlt(_localctx, 12);
        setState(3419);
        nochange_timing_check();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Setup_timing_checkContext ------------------------------------------------------------------

VerilogParser::Setup_timing_checkContext::Setup_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::DLSETUP() {
  return getToken(VerilogParser::DLSETUP, 0);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Data_eventContext* VerilogParser::Setup_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Setup_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Reference_eventContext* VerilogParser::Setup_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Setup_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Setup_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Setup_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Setup_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSetup_timing_check;
}


std::any VerilogParser::Setup_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSetup_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Setup_timing_checkContext* VerilogParser::setup_timing_check() {
  Setup_timing_checkContext *_localctx = _tracker.createInstance<Setup_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 494, VerilogParser::RuleSetup_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3422);
    match(VerilogParser::DLSETUP);
    setState(3423);
    match(VerilogParser::LP);
    setState(3424);
    data_event();
    setState(3425);
    match(VerilogParser::CO);
    setState(3426);
    reference_event();
    setState(3427);
    match(VerilogParser::CO);
    setState(3428);
    timing_check_limit();
    setState(3430);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3429);
      notifier_opt();
    }
    setState(3432);
    match(VerilogParser::RP);
    setState(3433);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Notifier_optContext ------------------------------------------------------------------

VerilogParser::Notifier_optContext::Notifier_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Notifier_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::NotifierContext* VerilogParser::Notifier_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}


size_t VerilogParser::Notifier_optContext::getRuleIndex() const {
  return VerilogParser::RuleNotifier_opt;
}


std::any VerilogParser::Notifier_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNotifier_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Notifier_optContext* VerilogParser::notifier_opt() {
  Notifier_optContext *_localctx = _tracker.createInstance<Notifier_optContext>(_ctx, getState());
  enterRule(_localctx, 496, VerilogParser::RuleNotifier_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3435);
    match(VerilogParser::CO);
    setState(3437);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(3436);
      notifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hold_timing_checkContext ------------------------------------------------------------------

VerilogParser::Hold_timing_checkContext::Hold_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::DLHOLD() {
  return getToken(VerilogParser::DLHOLD, 0);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Hold_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Hold_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Hold_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Hold_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Hold_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Hold_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Hold_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleHold_timing_check;
}


std::any VerilogParser::Hold_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHold_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hold_timing_checkContext* VerilogParser::hold_timing_check() {
  Hold_timing_checkContext *_localctx = _tracker.createInstance<Hold_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 498, VerilogParser::RuleHold_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3439);
    match(VerilogParser::DLHOLD);
    setState(3440);
    match(VerilogParser::LP);
    setState(3441);
    reference_event();
    setState(3442);
    match(VerilogParser::CO);
    setState(3443);
    data_event();
    setState(3444);
    match(VerilogParser::CO);
    setState(3445);
    timing_check_limit();
    setState(3447);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3446);
      notifier_opt();
    }
    setState(3449);
    match(VerilogParser::RP);
    setState(3450);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Setuphold_timing_checkContext ------------------------------------------------------------------

VerilogParser::Setuphold_timing_checkContext::Setuphold_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::DLSETUPHOLD() {
  return getToken(VerilogParser::DLSETUPHOLD, 0);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Setuphold_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Setuphold_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Setuphold_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<VerilogParser::Timing_check_limitContext *> VerilogParser::Setuphold_timing_checkContext::timing_check_limit() {
  return getRuleContexts<VerilogParser::Timing_check_limitContext>();
}

VerilogParser::Timing_check_limitContext* VerilogParser::Setuphold_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Setuphold_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Timing_check_optContext* VerilogParser::Setuphold_timing_checkContext::timing_check_opt() {
  return getRuleContext<VerilogParser::Timing_check_optContext>(0);
}


size_t VerilogParser::Setuphold_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSetuphold_timing_check;
}


std::any VerilogParser::Setuphold_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSetuphold_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Setuphold_timing_checkContext* VerilogParser::setuphold_timing_check() {
  Setuphold_timing_checkContext *_localctx = _tracker.createInstance<Setuphold_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 500, VerilogParser::RuleSetuphold_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3452);
    match(VerilogParser::DLSETUPHOLD);
    setState(3453);
    match(VerilogParser::LP);
    setState(3454);
    reference_event();
    setState(3455);
    match(VerilogParser::CO);
    setState(3456);
    data_event();
    setState(3457);
    match(VerilogParser::CO);
    setState(3458);
    timing_check_limit();
    setState(3459);
    match(VerilogParser::CO);
    setState(3460);
    timing_check_limit();
    setState(3462);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3461);
      timing_check_opt();
    }
    setState(3464);
    match(VerilogParser::RP);
    setState(3465);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_optContext ------------------------------------------------------------------

VerilogParser::Timing_check_optContext::Timing_check_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Timing_check_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::NotifierContext* VerilogParser::Timing_check_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}

VerilogParser::Stamptime_cond_optContext* VerilogParser::Timing_check_optContext::stamptime_cond_opt() {
  return getRuleContext<VerilogParser::Stamptime_cond_optContext>(0);
}


size_t VerilogParser::Timing_check_optContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_opt;
}


std::any VerilogParser::Timing_check_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_optContext* VerilogParser::timing_check_opt() {
  Timing_check_optContext *_localctx = _tracker.createInstance<Timing_check_optContext>(_ctx, getState());
  enterRule(_localctx, 502, VerilogParser::RuleTiming_check_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3467);
    match(VerilogParser::CO);
    setState(3469);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(3468);
      notifier();
    }
    setState(3472);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3471);
      stamptime_cond_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Stamptime_cond_optContext ------------------------------------------------------------------

VerilogParser::Stamptime_cond_optContext::Stamptime_cond_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Stamptime_cond_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Stamptime_conditionContext* VerilogParser::Stamptime_cond_optContext::stamptime_condition() {
  return getRuleContext<VerilogParser::Stamptime_conditionContext>(0);
}

VerilogParser::Checktime_cond_optContext* VerilogParser::Stamptime_cond_optContext::checktime_cond_opt() {
  return getRuleContext<VerilogParser::Checktime_cond_optContext>(0);
}


size_t VerilogParser::Stamptime_cond_optContext::getRuleIndex() const {
  return VerilogParser::RuleStamptime_cond_opt;
}


std::any VerilogParser::Stamptime_cond_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStamptime_cond_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Stamptime_cond_optContext* VerilogParser::stamptime_cond_opt() {
  Stamptime_cond_optContext *_localctx = _tracker.createInstance<Stamptime_cond_optContext>(_ctx, getState());
  enterRule(_localctx, 504, VerilogParser::RuleStamptime_cond_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3474);
    match(VerilogParser::CO);
    setState(3476);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281474977824772) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 1098706452503) != 0) {
      setState(3475);
      stamptime_condition();
    }
    setState(3479);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3478);
      checktime_cond_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checktime_cond_optContext ------------------------------------------------------------------

VerilogParser::Checktime_cond_optContext::Checktime_cond_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Checktime_cond_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Checktime_conditionContext* VerilogParser::Checktime_cond_optContext::checktime_condition() {
  return getRuleContext<VerilogParser::Checktime_conditionContext>(0);
}

VerilogParser::Delayed_ref_optContext* VerilogParser::Checktime_cond_optContext::delayed_ref_opt() {
  return getRuleContext<VerilogParser::Delayed_ref_optContext>(0);
}


size_t VerilogParser::Checktime_cond_optContext::getRuleIndex() const {
  return VerilogParser::RuleChecktime_cond_opt;
}


std::any VerilogParser::Checktime_cond_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitChecktime_cond_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Checktime_cond_optContext* VerilogParser::checktime_cond_opt() {
  Checktime_cond_optContext *_localctx = _tracker.createInstance<Checktime_cond_optContext>(_ctx, getState());
  enterRule(_localctx, 506, VerilogParser::RuleChecktime_cond_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3481);
    match(VerilogParser::CO);
    setState(3483);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281474977824772) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 1098706452503) != 0) {
      setState(3482);
      checktime_condition();
    }
    setState(3486);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3485);
      delayed_ref_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_ref_optContext ------------------------------------------------------------------

VerilogParser::Delayed_ref_optContext::Delayed_ref_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delayed_ref_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Delayed_referenceContext* VerilogParser::Delayed_ref_optContext::delayed_reference() {
  return getRuleContext<VerilogParser::Delayed_referenceContext>(0);
}

VerilogParser::Delayed_data_optContext* VerilogParser::Delayed_ref_optContext::delayed_data_opt() {
  return getRuleContext<VerilogParser::Delayed_data_optContext>(0);
}


size_t VerilogParser::Delayed_ref_optContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_ref_opt;
}


std::any VerilogParser::Delayed_ref_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_ref_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_ref_optContext* VerilogParser::delayed_ref_opt() {
  Delayed_ref_optContext *_localctx = _tracker.createInstance<Delayed_ref_optContext>(_ctx, getState());
  enterRule(_localctx, 508, VerilogParser::RuleDelayed_ref_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3488);
    match(VerilogParser::CO);
    setState(3490);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(3489);
      delayed_reference();
    }
    setState(3493);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3492);
      delayed_data_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_data_optContext ------------------------------------------------------------------

VerilogParser::Delayed_data_optContext::Delayed_data_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Delayed_data_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Delayed_dataContext* VerilogParser::Delayed_data_optContext::delayed_data() {
  return getRuleContext<VerilogParser::Delayed_dataContext>(0);
}


size_t VerilogParser::Delayed_data_optContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_data_opt;
}


std::any VerilogParser::Delayed_data_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_data_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_data_optContext* VerilogParser::delayed_data_opt() {
  Delayed_data_optContext *_localctx = _tracker.createInstance<Delayed_data_optContext>(_ctx, getState());
  enterRule(_localctx, 510, VerilogParser::RuleDelayed_data_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3495);
    match(VerilogParser::CO);
    setState(3497);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(3496);
      delayed_data();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recovery_timing_checkContext ------------------------------------------------------------------

VerilogParser::Recovery_timing_checkContext::Recovery_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::DLRECOVERY() {
  return getToken(VerilogParser::DLRECOVERY, 0);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Recovery_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Recovery_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Recovery_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Recovery_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Recovery_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Recovery_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Recovery_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleRecovery_timing_check;
}


std::any VerilogParser::Recovery_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRecovery_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Recovery_timing_checkContext* VerilogParser::recovery_timing_check() {
  Recovery_timing_checkContext *_localctx = _tracker.createInstance<Recovery_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 512, VerilogParser::RuleRecovery_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3499);
    match(VerilogParser::DLRECOVERY);
    setState(3500);
    match(VerilogParser::LP);
    setState(3501);
    reference_event();
    setState(3502);
    match(VerilogParser::CO);
    setState(3503);
    data_event();
    setState(3504);
    match(VerilogParser::CO);
    setState(3505);
    timing_check_limit();
    setState(3507);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3506);
      notifier_opt();
    }
    setState(3509);
    match(VerilogParser::RP);
    setState(3510);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Removal_timing_checkContext ------------------------------------------------------------------

VerilogParser::Removal_timing_checkContext::Removal_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::DLREMOVAL() {
  return getToken(VerilogParser::DLREMOVAL, 0);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Removal_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Removal_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Removal_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Removal_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Removal_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Removal_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Removal_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleRemoval_timing_check;
}


std::any VerilogParser::Removal_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRemoval_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Removal_timing_checkContext* VerilogParser::removal_timing_check() {
  Removal_timing_checkContext *_localctx = _tracker.createInstance<Removal_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 514, VerilogParser::RuleRemoval_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3512);
    match(VerilogParser::DLREMOVAL);
    setState(3513);
    match(VerilogParser::LP);
    setState(3514);
    reference_event();
    setState(3515);
    match(VerilogParser::CO);
    setState(3516);
    data_event();
    setState(3517);
    match(VerilogParser::CO);
    setState(3518);
    timing_check_limit();
    setState(3520);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3519);
      notifier_opt();
    }
    setState(3522);
    match(VerilogParser::RP);
    setState(3523);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recrem_timing_checkContext ------------------------------------------------------------------

VerilogParser::Recrem_timing_checkContext::Recrem_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::DLRECREM() {
  return getToken(VerilogParser::DLRECREM, 0);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Recrem_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Recrem_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Recrem_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<VerilogParser::Timing_check_limitContext *> VerilogParser::Recrem_timing_checkContext::timing_check_limit() {
  return getRuleContexts<VerilogParser::Timing_check_limitContext>();
}

VerilogParser::Timing_check_limitContext* VerilogParser::Recrem_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Recrem_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Timing_check_optContext* VerilogParser::Recrem_timing_checkContext::timing_check_opt() {
  return getRuleContext<VerilogParser::Timing_check_optContext>(0);
}


size_t VerilogParser::Recrem_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleRecrem_timing_check;
}


std::any VerilogParser::Recrem_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRecrem_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Recrem_timing_checkContext* VerilogParser::recrem_timing_check() {
  Recrem_timing_checkContext *_localctx = _tracker.createInstance<Recrem_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 516, VerilogParser::RuleRecrem_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3525);
    match(VerilogParser::DLRECREM);
    setState(3526);
    match(VerilogParser::LP);
    setState(3527);
    reference_event();
    setState(3528);
    match(VerilogParser::CO);
    setState(3529);
    data_event();
    setState(3530);
    match(VerilogParser::CO);
    setState(3531);
    timing_check_limit();
    setState(3532);
    match(VerilogParser::CO);
    setState(3533);
    timing_check_limit();
    setState(3535);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3534);
      timing_check_opt();
    }
    setState(3537);
    match(VerilogParser::RP);
    setState(3538);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Skew_timing_checkContext ------------------------------------------------------------------

VerilogParser::Skew_timing_checkContext::Skew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::DLSKEW() {
  return getToken(VerilogParser::DLSKEW, 0);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Skew_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Skew_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Skew_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Skew_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Skew_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Skew_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Skew_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleSkew_timing_check;
}


std::any VerilogParser::Skew_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSkew_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Skew_timing_checkContext* VerilogParser::skew_timing_check() {
  Skew_timing_checkContext *_localctx = _tracker.createInstance<Skew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 518, VerilogParser::RuleSkew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3540);
    match(VerilogParser::DLSKEW);
    setState(3541);
    match(VerilogParser::LP);
    setState(3542);
    reference_event();
    setState(3543);
    match(VerilogParser::CO);
    setState(3544);
    data_event();
    setState(3545);
    match(VerilogParser::CO);
    setState(3546);
    timing_check_limit();
    setState(3548);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3547);
      notifier_opt();
    }
    setState(3550);
    match(VerilogParser::RP);
    setState(3551);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timeskew_timing_checkContext ------------------------------------------------------------------

VerilogParser::Timeskew_timing_checkContext::Timeskew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::DLTIMESKEW() {
  return getToken(VerilogParser::DLTIMESKEW, 0);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Timeskew_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Timeskew_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Timeskew_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Timeskew_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Timeskew_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Skew_timing_check_optContext* VerilogParser::Timeskew_timing_checkContext::skew_timing_check_opt() {
  return getRuleContext<VerilogParser::Skew_timing_check_optContext>(0);
}


size_t VerilogParser::Timeskew_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleTimeskew_timing_check;
}


std::any VerilogParser::Timeskew_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTimeskew_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timeskew_timing_checkContext* VerilogParser::timeskew_timing_check() {
  Timeskew_timing_checkContext *_localctx = _tracker.createInstance<Timeskew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 520, VerilogParser::RuleTimeskew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3553);
    match(VerilogParser::DLTIMESKEW);
    setState(3554);
    match(VerilogParser::LP);
    setState(3555);
    reference_event();
    setState(3556);
    match(VerilogParser::CO);
    setState(3557);
    data_event();
    setState(3558);
    match(VerilogParser::CO);
    setState(3559);
    timing_check_limit();
    setState(3561);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3560);
      skew_timing_check_opt();
    }
    setState(3563);
    match(VerilogParser::RP);
    setState(3564);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Skew_timing_check_optContext ------------------------------------------------------------------

VerilogParser::Skew_timing_check_optContext::Skew_timing_check_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Skew_timing_check_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::NotifierContext* VerilogParser::Skew_timing_check_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}

VerilogParser::Event_based_flag_optContext* VerilogParser::Skew_timing_check_optContext::event_based_flag_opt() {
  return getRuleContext<VerilogParser::Event_based_flag_optContext>(0);
}


size_t VerilogParser::Skew_timing_check_optContext::getRuleIndex() const {
  return VerilogParser::RuleSkew_timing_check_opt;
}


std::any VerilogParser::Skew_timing_check_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSkew_timing_check_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Skew_timing_check_optContext* VerilogParser::skew_timing_check_opt() {
  Skew_timing_check_optContext *_localctx = _tracker.createInstance<Skew_timing_check_optContext>(_ctx, getState());
  enterRule(_localctx, 522, VerilogParser::RuleSkew_timing_check_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3566);
    match(VerilogParser::CO);
    setState(3568);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::ESCAPED_IDENTIFIER

    || _la == VerilogParser::SIMPLE_IDENTIFIER) {
      setState(3567);
      notifier();
    }
    setState(3571);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3570);
      event_based_flag_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_based_flag_optContext ------------------------------------------------------------------

VerilogParser::Event_based_flag_optContext::Event_based_flag_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Event_based_flag_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Event_based_flagContext* VerilogParser::Event_based_flag_optContext::event_based_flag() {
  return getRuleContext<VerilogParser::Event_based_flagContext>(0);
}

VerilogParser::Remain_active_flag_optContext* VerilogParser::Event_based_flag_optContext::remain_active_flag_opt() {
  return getRuleContext<VerilogParser::Remain_active_flag_optContext>(0);
}


size_t VerilogParser::Event_based_flag_optContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_based_flag_opt;
}


std::any VerilogParser::Event_based_flag_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_based_flag_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_based_flag_optContext* VerilogParser::event_based_flag_opt() {
  Event_based_flag_optContext *_localctx = _tracker.createInstance<Event_based_flag_optContext>(_ctx, getState());
  enterRule(_localctx, 524, VerilogParser::RuleEvent_based_flag_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3573);
    match(VerilogParser::CO);
    setState(3575);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281474977824772) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 1098706452503) != 0) {
      setState(3574);
      event_based_flag();
    }
    setState(3578);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3577);
      remain_active_flag_opt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remain_active_flag_optContext ------------------------------------------------------------------

VerilogParser::Remain_active_flag_optContext::Remain_active_flag_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Remain_active_flag_optContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Remain_active_flagContext* VerilogParser::Remain_active_flag_optContext::remain_active_flag() {
  return getRuleContext<VerilogParser::Remain_active_flagContext>(0);
}


size_t VerilogParser::Remain_active_flag_optContext::getRuleIndex() const {
  return VerilogParser::RuleRemain_active_flag_opt;
}


std::any VerilogParser::Remain_active_flag_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRemain_active_flag_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Remain_active_flag_optContext* VerilogParser::remain_active_flag_opt() {
  Remain_active_flag_optContext *_localctx = _tracker.createInstance<Remain_active_flag_optContext>(_ctx, getState());
  enterRule(_localctx, 526, VerilogParser::RuleRemain_active_flag_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3580);
    match(VerilogParser::CO);
    setState(3582);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281474977824772) != 0 || (((_la - 92) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 92)) & 536872977) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 1098706452503) != 0) {
      setState(3581);
      remain_active_flag();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fullskew_timing_checkContext ------------------------------------------------------------------

VerilogParser::Fullskew_timing_checkContext::Fullskew_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::DLFULLSKEW() {
  return getToken(VerilogParser::DLFULLSKEW, 0);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Fullskew_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Fullskew_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Fullskew_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

std::vector<VerilogParser::Timing_check_limitContext *> VerilogParser::Fullskew_timing_checkContext::timing_check_limit() {
  return getRuleContexts<VerilogParser::Timing_check_limitContext>();
}

VerilogParser::Timing_check_limitContext* VerilogParser::Fullskew_timing_checkContext::timing_check_limit(size_t i) {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(i);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Fullskew_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Skew_timing_check_optContext* VerilogParser::Fullskew_timing_checkContext::skew_timing_check_opt() {
  return getRuleContext<VerilogParser::Skew_timing_check_optContext>(0);
}


size_t VerilogParser::Fullskew_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleFullskew_timing_check;
}


std::any VerilogParser::Fullskew_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFullskew_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Fullskew_timing_checkContext* VerilogParser::fullskew_timing_check() {
  Fullskew_timing_checkContext *_localctx = _tracker.createInstance<Fullskew_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 528, VerilogParser::RuleFullskew_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3584);
    match(VerilogParser::DLFULLSKEW);
    setState(3585);
    match(VerilogParser::LP);
    setState(3586);
    reference_event();
    setState(3587);
    match(VerilogParser::CO);
    setState(3588);
    data_event();
    setState(3589);
    match(VerilogParser::CO);
    setState(3590);
    timing_check_limit();
    setState(3591);
    match(VerilogParser::CO);
    setState(3592);
    timing_check_limit();
    setState(3594);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3593);
      skew_timing_check_opt();
    }
    setState(3596);
    match(VerilogParser::RP);
    setState(3597);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Period_timing_checkContext ------------------------------------------------------------------

VerilogParser::Period_timing_checkContext::Period_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::DLPERIOD() {
  return getToken(VerilogParser::DLPERIOD, 0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Controlled_reference_eventContext* VerilogParser::Period_timing_checkContext::controlled_reference_event() {
  return getRuleContext<VerilogParser::Controlled_reference_eventContext>(0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Period_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Period_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Period_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Period_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RulePeriod_timing_check;
}


std::any VerilogParser::Period_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPeriod_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Period_timing_checkContext* VerilogParser::period_timing_check() {
  Period_timing_checkContext *_localctx = _tracker.createInstance<Period_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 530, VerilogParser::RulePeriod_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3599);
    match(VerilogParser::DLPERIOD);
    setState(3600);
    match(VerilogParser::LP);
    setState(3601);
    controlled_reference_event();
    setState(3602);
    match(VerilogParser::CO);
    setState(3603);
    timing_check_limit();
    setState(3605);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3604);
      notifier_opt();
    }
    setState(3607);
    match(VerilogParser::RP);
    setState(3608);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Width_timing_checkContext ------------------------------------------------------------------

VerilogParser::Width_timing_checkContext::Width_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::DLWIDTH() {
  return getToken(VerilogParser::DLWIDTH, 0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Controlled_reference_eventContext* VerilogParser::Width_timing_checkContext::controlled_reference_event() {
  return getRuleContext<VerilogParser::Controlled_reference_eventContext>(0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::CO() {
  return getToken(VerilogParser::CO, 0);
}

VerilogParser::Timing_check_limitContext* VerilogParser::Width_timing_checkContext::timing_check_limit() {
  return getRuleContext<VerilogParser::Timing_check_limitContext>(0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Width_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Threshold_optContext* VerilogParser::Width_timing_checkContext::threshold_opt() {
  return getRuleContext<VerilogParser::Threshold_optContext>(0);
}


size_t VerilogParser::Width_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleWidth_timing_check;
}


std::any VerilogParser::Width_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitWidth_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Width_timing_checkContext* VerilogParser::width_timing_check() {
  Width_timing_checkContext *_localctx = _tracker.createInstance<Width_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 532, VerilogParser::RuleWidth_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3610);
    match(VerilogParser::DLWIDTH);
    setState(3611);
    match(VerilogParser::LP);
    setState(3612);
    controlled_reference_event();
    setState(3613);
    match(VerilogParser::CO);
    setState(3614);
    timing_check_limit();
    setState(3616);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3615);
      threshold_opt();
    }
    setState(3618);
    match(VerilogParser::RP);
    setState(3619);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Threshold_optContext ------------------------------------------------------------------

VerilogParser::Threshold_optContext::Threshold_optContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Threshold_optContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Threshold_optContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::ThresholdContext* VerilogParser::Threshold_optContext::threshold() {
  return getRuleContext<VerilogParser::ThresholdContext>(0);
}

VerilogParser::NotifierContext* VerilogParser::Threshold_optContext::notifier() {
  return getRuleContext<VerilogParser::NotifierContext>(0);
}


size_t VerilogParser::Threshold_optContext::getRuleIndex() const {
  return VerilogParser::RuleThreshold_opt;
}


std::any VerilogParser::Threshold_optContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitThreshold_opt(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Threshold_optContext* VerilogParser::threshold_opt() {
  Threshold_optContext *_localctx = _tracker.createInstance<Threshold_optContext>(_ctx, getState());
  enterRule(_localctx, 534, VerilogParser::RuleThreshold_opt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3621);
    match(VerilogParser::CO);
    setState(3622);
    threshold();
    setState(3625);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3623);
      match(VerilogParser::CO);
      setState(3624);
      notifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Nochange_timing_checkContext ------------------------------------------------------------------

VerilogParser::Nochange_timing_checkContext::Nochange_timing_checkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::DLNOCHANGE() {
  return getToken(VerilogParser::DLNOCHANGE, 0);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Reference_eventContext* VerilogParser::Nochange_timing_checkContext::reference_event() {
  return getRuleContext<VerilogParser::Reference_eventContext>(0);
}

std::vector<tree::TerminalNode *> VerilogParser::Nochange_timing_checkContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}

VerilogParser::Data_eventContext* VerilogParser::Nochange_timing_checkContext::data_event() {
  return getRuleContext<VerilogParser::Data_eventContext>(0);
}

VerilogParser::Start_edge_offsetContext* VerilogParser::Nochange_timing_checkContext::start_edge_offset() {
  return getRuleContext<VerilogParser::Start_edge_offsetContext>(0);
}

VerilogParser::End_edge_offsetContext* VerilogParser::Nochange_timing_checkContext::end_edge_offset() {
  return getRuleContext<VerilogParser::End_edge_offsetContext>(0);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

tree::TerminalNode* VerilogParser::Nochange_timing_checkContext::SC() {
  return getToken(VerilogParser::SC, 0);
}

VerilogParser::Notifier_optContext* VerilogParser::Nochange_timing_checkContext::notifier_opt() {
  return getRuleContext<VerilogParser::Notifier_optContext>(0);
}


size_t VerilogParser::Nochange_timing_checkContext::getRuleIndex() const {
  return VerilogParser::RuleNochange_timing_check;
}


std::any VerilogParser::Nochange_timing_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNochange_timing_check(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Nochange_timing_checkContext* VerilogParser::nochange_timing_check() {
  Nochange_timing_checkContext *_localctx = _tracker.createInstance<Nochange_timing_checkContext>(_ctx, getState());
  enterRule(_localctx, 536, VerilogParser::RuleNochange_timing_check);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3627);
    match(VerilogParser::DLNOCHANGE);
    setState(3628);
    match(VerilogParser::LP);
    setState(3629);
    reference_event();
    setState(3630);
    match(VerilogParser::CO);
    setState(3631);
    data_event();
    setState(3632);
    match(VerilogParser::CO);
    setState(3633);
    start_edge_offset();
    setState(3634);
    match(VerilogParser::CO);
    setState(3635);
    end_edge_offset();
    setState(3637);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CO) {
      setState(3636);
      notifier_opt();
    }
    setState(3639);
    match(VerilogParser::RP);
    setState(3640);
    match(VerilogParser::SC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Checktime_conditionContext ------------------------------------------------------------------

VerilogParser::Checktime_conditionContext::Checktime_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Checktime_conditionContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Checktime_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleChecktime_condition;
}


std::any VerilogParser::Checktime_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitChecktime_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Checktime_conditionContext* VerilogParser::checktime_condition() {
  Checktime_conditionContext *_localctx = _tracker.createInstance<Checktime_conditionContext>(_ctx, getState());
  enterRule(_localctx, 538, VerilogParser::RuleChecktime_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3642);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Controlled_reference_eventContext ------------------------------------------------------------------

VerilogParser::Controlled_reference_eventContext::Controlled_reference_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Controlled_timing_check_eventContext* VerilogParser::Controlled_reference_eventContext::controlled_timing_check_event() {
  return getRuleContext<VerilogParser::Controlled_timing_check_eventContext>(0);
}


size_t VerilogParser::Controlled_reference_eventContext::getRuleIndex() const {
  return VerilogParser::RuleControlled_reference_event;
}


std::any VerilogParser::Controlled_reference_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitControlled_reference_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Controlled_reference_eventContext* VerilogParser::controlled_reference_event() {
  Controlled_reference_eventContext *_localctx = _tracker.createInstance<Controlled_reference_eventContext>(_ctx, getState());
  enterRule(_localctx, 540, VerilogParser::RuleControlled_reference_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3644);
    controlled_timing_check_event();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_eventContext ------------------------------------------------------------------

VerilogParser::Data_eventContext::Data_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Timing_check_eventContext* VerilogParser::Data_eventContext::timing_check_event() {
  return getRuleContext<VerilogParser::Timing_check_eventContext>(0);
}


size_t VerilogParser::Data_eventContext::getRuleIndex() const {
  return VerilogParser::RuleData_event;
}


std::any VerilogParser::Data_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitData_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Data_eventContext* VerilogParser::data_event() {
  Data_eventContext *_localctx = _tracker.createInstance<Data_eventContext>(_ctx, getState());
  enterRule(_localctx, 542, VerilogParser::RuleData_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3646);
    timing_check_event();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_dataContext ------------------------------------------------------------------

VerilogParser::Delayed_dataContext::Delayed_dataContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Terminal_identifierContext* VerilogParser::Delayed_dataContext::terminal_identifier() {
  return getRuleContext<VerilogParser::Terminal_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_dataContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Delayed_dataContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_dataContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Delayed_dataContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_data;
}


std::any VerilogParser::Delayed_dataContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_data(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_dataContext* VerilogParser::delayed_data() {
  Delayed_dataContext *_localctx = _tracker.createInstance<Delayed_dataContext>(_ctx, getState());
  enterRule(_localctx, 544, VerilogParser::RuleDelayed_data);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3648);
    terminal_identifier();
    setState(3653);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3649);
      match(VerilogParser::LB);
      setState(3650);
      constant_mintypmax_expression();
      setState(3651);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delayed_referenceContext ------------------------------------------------------------------

VerilogParser::Delayed_referenceContext::Delayed_referenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Terminal_identifierContext* VerilogParser::Delayed_referenceContext::terminal_identifier() {
  return getRuleContext<VerilogParser::Terminal_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_referenceContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Delayed_referenceContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Delayed_referenceContext::RB() {
  return getToken(VerilogParser::RB, 0);
}


size_t VerilogParser::Delayed_referenceContext::getRuleIndex() const {
  return VerilogParser::RuleDelayed_reference;
}


std::any VerilogParser::Delayed_referenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDelayed_reference(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Delayed_referenceContext* VerilogParser::delayed_reference() {
  Delayed_referenceContext *_localctx = _tracker.createInstance<Delayed_referenceContext>(_ctx, getState());
  enterRule(_localctx, 546, VerilogParser::RuleDelayed_reference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3655);
    terminal_identifier();
    setState(3660);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(3656);
      match(VerilogParser::LB);
      setState(3657);
      constant_mintypmax_expression();
      setState(3658);
      match(VerilogParser::RB);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- End_edge_offsetContext ------------------------------------------------------------------

VerilogParser::End_edge_offsetContext::End_edge_offsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::End_edge_offsetContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::End_edge_offsetContext::getRuleIndex() const {
  return VerilogParser::RuleEnd_edge_offset;
}


std::any VerilogParser::End_edge_offsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEnd_edge_offset(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::End_edge_offsetContext* VerilogParser::end_edge_offset() {
  End_edge_offsetContext *_localctx = _tracker.createInstance<End_edge_offsetContext>(_ctx, getState());
  enterRule(_localctx, 548, VerilogParser::RuleEnd_edge_offset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3662);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_based_flagContext ------------------------------------------------------------------

VerilogParser::Event_based_flagContext::Event_based_flagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Event_based_flagContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Event_based_flagContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_based_flag;
}


std::any VerilogParser::Event_based_flagContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_based_flag(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_based_flagContext* VerilogParser::event_based_flag() {
  Event_based_flagContext *_localctx = _tracker.createInstance<Event_based_flagContext>(_ctx, getState());
  enterRule(_localctx, 550, VerilogParser::RuleEvent_based_flag);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3664);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotifierContext ------------------------------------------------------------------

VerilogParser::NotifierContext::NotifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Variable_identifierContext* VerilogParser::NotifierContext::variable_identifier() {
  return getRuleContext<VerilogParser::Variable_identifierContext>(0);
}


size_t VerilogParser::NotifierContext::getRuleIndex() const {
  return VerilogParser::RuleNotifier;
}


std::any VerilogParser::NotifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNotifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::NotifierContext* VerilogParser::notifier() {
  NotifierContext *_localctx = _tracker.createInstance<NotifierContext>(_ctx, getState());
  enterRule(_localctx, 552, VerilogParser::RuleNotifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3666);
    variable_identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reference_eventContext ------------------------------------------------------------------

VerilogParser::Reference_eventContext::Reference_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Timing_check_eventContext* VerilogParser::Reference_eventContext::timing_check_event() {
  return getRuleContext<VerilogParser::Timing_check_eventContext>(0);
}


size_t VerilogParser::Reference_eventContext::getRuleIndex() const {
  return VerilogParser::RuleReference_event;
}


std::any VerilogParser::Reference_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReference_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Reference_eventContext* VerilogParser::reference_event() {
  Reference_eventContext *_localctx = _tracker.createInstance<Reference_eventContext>(_ctx, getState());
  enterRule(_localctx, 554, VerilogParser::RuleReference_event);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3668);
    timing_check_event();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Remain_active_flagContext ------------------------------------------------------------------

VerilogParser::Remain_active_flagContext::Remain_active_flagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Remain_active_flagContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Remain_active_flagContext::getRuleIndex() const {
  return VerilogParser::RuleRemain_active_flag;
}


std::any VerilogParser::Remain_active_flagContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRemain_active_flag(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Remain_active_flagContext* VerilogParser::remain_active_flag() {
  Remain_active_flagContext *_localctx = _tracker.createInstance<Remain_active_flagContext>(_ctx, getState());
  enterRule(_localctx, 556, VerilogParser::RuleRemain_active_flag);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3670);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Stamptime_conditionContext ------------------------------------------------------------------

VerilogParser::Stamptime_conditionContext::Stamptime_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Stamptime_conditionContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Stamptime_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleStamptime_condition;
}


std::any VerilogParser::Stamptime_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStamptime_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Stamptime_conditionContext* VerilogParser::stamptime_condition() {
  Stamptime_conditionContext *_localctx = _tracker.createInstance<Stamptime_conditionContext>(_ctx, getState());
  enterRule(_localctx, 558, VerilogParser::RuleStamptime_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3672);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Start_edge_offsetContext ------------------------------------------------------------------

VerilogParser::Start_edge_offsetContext::Start_edge_offsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::Start_edge_offsetContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}


size_t VerilogParser::Start_edge_offsetContext::getRuleIndex() const {
  return VerilogParser::RuleStart_edge_offset;
}


std::any VerilogParser::Start_edge_offsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitStart_edge_offset(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Start_edge_offsetContext* VerilogParser::start_edge_offset() {
  Start_edge_offsetContext *_localctx = _tracker.createInstance<Start_edge_offsetContext>(_ctx, getState());
  enterRule(_localctx, 560, VerilogParser::RuleStart_edge_offset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3674);
    mintypmax_expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThresholdContext ------------------------------------------------------------------

VerilogParser::ThresholdContext::ThresholdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::ThresholdContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::ThresholdContext::getRuleIndex() const {
  return VerilogParser::RuleThreshold;
}


std::any VerilogParser::ThresholdContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitThreshold(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::ThresholdContext* VerilogParser::threshold() {
  ThresholdContext *_localctx = _tracker.createInstance<ThresholdContext>(_ctx, getState());
  enterRule(_localctx, 562, VerilogParser::RuleThreshold);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3676);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_limitContext ------------------------------------------------------------------

VerilogParser::Timing_check_limitContext::Timing_check_limitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Timing_check_limitContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Timing_check_limitContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_limit;
}


std::any VerilogParser::Timing_check_limitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_limit(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_limitContext* VerilogParser::timing_check_limit() {
  Timing_check_limitContext *_localctx = _tracker.createInstance<Timing_check_limitContext>(_ctx, getState());
  enterRule(_localctx, 564, VerilogParser::RuleTiming_check_limit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3678);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_eventContext ------------------------------------------------------------------

VerilogParser::Timing_check_eventContext::Timing_check_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specify_terminal_descriptorContext* VerilogParser::Timing_check_eventContext::specify_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_terminal_descriptorContext>(0);
}

VerilogParser::Timing_check_event_controlContext* VerilogParser::Timing_check_eventContext::timing_check_event_control() {
  return getRuleContext<VerilogParser::Timing_check_event_controlContext>(0);
}

tree::TerminalNode* VerilogParser::Timing_check_eventContext::AMAMAM() {
  return getToken(VerilogParser::AMAMAM, 0);
}

VerilogParser::Timing_check_conditionContext* VerilogParser::Timing_check_eventContext::timing_check_condition() {
  return getRuleContext<VerilogParser::Timing_check_conditionContext>(0);
}


size_t VerilogParser::Timing_check_eventContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_event;
}


std::any VerilogParser::Timing_check_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_eventContext* VerilogParser::timing_check_event() {
  Timing_check_eventContext *_localctx = _tracker.createInstance<Timing_check_eventContext>(_ctx, getState());
  enterRule(_localctx, 566, VerilogParser::RuleTiming_check_event);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3681);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::EDGE || _la == VerilogParser::NEGEDGE

    || _la == VerilogParser::POSEDGE) {
      setState(3680);
      timing_check_event_control();
    }
    setState(3683);
    specify_terminal_descriptor();
    setState(3686);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::AMAMAM) {
      setState(3684);
      match(VerilogParser::AMAMAM);
      setState(3685);
      timing_check_condition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Controlled_timing_check_eventContext ------------------------------------------------------------------

VerilogParser::Controlled_timing_check_eventContext::Controlled_timing_check_eventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Timing_check_event_controlContext* VerilogParser::Controlled_timing_check_eventContext::timing_check_event_control() {
  return getRuleContext<VerilogParser::Timing_check_event_controlContext>(0);
}

VerilogParser::Specify_terminal_descriptorContext* VerilogParser::Controlled_timing_check_eventContext::specify_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_terminal_descriptorContext>(0);
}

tree::TerminalNode* VerilogParser::Controlled_timing_check_eventContext::AMAMAM() {
  return getToken(VerilogParser::AMAMAM, 0);
}

VerilogParser::Timing_check_conditionContext* VerilogParser::Controlled_timing_check_eventContext::timing_check_condition() {
  return getRuleContext<VerilogParser::Timing_check_conditionContext>(0);
}


size_t VerilogParser::Controlled_timing_check_eventContext::getRuleIndex() const {
  return VerilogParser::RuleControlled_timing_check_event;
}


std::any VerilogParser::Controlled_timing_check_eventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitControlled_timing_check_event(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Controlled_timing_check_eventContext* VerilogParser::controlled_timing_check_event() {
  Controlled_timing_check_eventContext *_localctx = _tracker.createInstance<Controlled_timing_check_eventContext>(_ctx, getState());
  enterRule(_localctx, 568, VerilogParser::RuleControlled_timing_check_event);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3688);
    timing_check_event_control();
    setState(3689);
    specify_terminal_descriptor();
    setState(3692);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::AMAMAM) {
      setState(3690);
      match(VerilogParser::AMAMAM);
      setState(3691);
      timing_check_condition();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_event_controlContext ------------------------------------------------------------------

VerilogParser::Timing_check_event_controlContext::Timing_check_event_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Timing_check_event_controlContext::POSEDGE() {
  return getToken(VerilogParser::POSEDGE, 0);
}

tree::TerminalNode* VerilogParser::Timing_check_event_controlContext::NEGEDGE() {
  return getToken(VerilogParser::NEGEDGE, 0);
}

VerilogParser::Edge_control_specifierContext* VerilogParser::Timing_check_event_controlContext::edge_control_specifier() {
  return getRuleContext<VerilogParser::Edge_control_specifierContext>(0);
}


size_t VerilogParser::Timing_check_event_controlContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_event_control;
}


std::any VerilogParser::Timing_check_event_controlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_event_control(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_event_controlContext* VerilogParser::timing_check_event_control() {
  Timing_check_event_controlContext *_localctx = _tracker.createInstance<Timing_check_event_controlContext>(_ctx, getState());
  enterRule(_localctx, 570, VerilogParser::RuleTiming_check_event_control);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3697);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::POSEDGE: {
        enterOuterAlt(_localctx, 1);
        setState(3694);
        match(VerilogParser::POSEDGE);
        break;
      }

      case VerilogParser::NEGEDGE: {
        enterOuterAlt(_localctx, 2);
        setState(3695);
        match(VerilogParser::NEGEDGE);
        break;
      }

      case VerilogParser::EDGE: {
        enterOuterAlt(_localctx, 3);
        setState(3696);
        edge_control_specifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specify_terminal_descriptorContext ------------------------------------------------------------------

VerilogParser::Specify_terminal_descriptorContext::Specify_terminal_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Specify_input_terminal_descriptorContext* VerilogParser::Specify_terminal_descriptorContext::specify_input_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_input_terminal_descriptorContext>(0);
}

VerilogParser::Specify_output_terminal_descriptorContext* VerilogParser::Specify_terminal_descriptorContext::specify_output_terminal_descriptor() {
  return getRuleContext<VerilogParser::Specify_output_terminal_descriptorContext>(0);
}


size_t VerilogParser::Specify_terminal_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleSpecify_terminal_descriptor;
}


std::any VerilogParser::Specify_terminal_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecify_terminal_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specify_terminal_descriptorContext* VerilogParser::specify_terminal_descriptor() {
  Specify_terminal_descriptorContext *_localctx = _tracker.createInstance<Specify_terminal_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 572, VerilogParser::RuleSpecify_terminal_descriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3701);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 380, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3699);
      specify_input_terminal_descriptor();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3700);
      specify_output_terminal_descriptor();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_control_specifierContext ------------------------------------------------------------------

VerilogParser::Edge_control_specifierContext::Edge_control_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::EDGE() {
  return getToken(VerilogParser::EDGE, 0);
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

std::vector<VerilogParser::Edge_descriptorContext *> VerilogParser::Edge_control_specifierContext::edge_descriptor() {
  return getRuleContexts<VerilogParser::Edge_descriptorContext>();
}

VerilogParser::Edge_descriptorContext* VerilogParser::Edge_control_specifierContext::edge_descriptor(size_t i) {
  return getRuleContext<VerilogParser::Edge_descriptorContext>(i);
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::RB() {
  return getToken(VerilogParser::RB, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Edge_control_specifierContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Edge_control_specifierContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Edge_control_specifierContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_control_specifier;
}


std::any VerilogParser::Edge_control_specifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_control_specifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_control_specifierContext* VerilogParser::edge_control_specifier() {
  Edge_control_specifierContext *_localctx = _tracker.createInstance<Edge_control_specifierContext>(_ctx, getState());
  enterRule(_localctx, 574, VerilogParser::RuleEdge_control_specifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3703);
    match(VerilogParser::EDGE);
    setState(3704);
    match(VerilogParser::LB);
    setState(3705);
    edge_descriptor();
    setState(3710);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3706);
      match(VerilogParser::CO);
      setState(3707);
      edge_descriptor();
      setState(3712);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3713);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Edge_descriptorContext ------------------------------------------------------------------

VerilogParser::Edge_descriptorContext::Edge_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Edge_descriptorContext::EDGE_DESCRIPTOR() {
  return getToken(VerilogParser::EDGE_DESCRIPTOR, 0);
}


size_t VerilogParser::Edge_descriptorContext::getRuleIndex() const {
  return VerilogParser::RuleEdge_descriptor;
}


std::any VerilogParser::Edge_descriptorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEdge_descriptor(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Edge_descriptorContext* VerilogParser::edge_descriptor() {
  Edge_descriptorContext *_localctx = _tracker.createInstance<Edge_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 576, VerilogParser::RuleEdge_descriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3715);
    match(VerilogParser::EDGE_DESCRIPTOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Timing_check_conditionContext ------------------------------------------------------------------

VerilogParser::Timing_check_conditionContext::Timing_check_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Scalar_timing_check_conditionContext* VerilogParser::Timing_check_conditionContext::scalar_timing_check_condition() {
  return getRuleContext<VerilogParser::Scalar_timing_check_conditionContext>(0);
}

tree::TerminalNode* VerilogParser::Timing_check_conditionContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

tree::TerminalNode* VerilogParser::Timing_check_conditionContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Timing_check_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleTiming_check_condition;
}


std::any VerilogParser::Timing_check_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTiming_check_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Timing_check_conditionContext* VerilogParser::timing_check_condition() {
  Timing_check_conditionContext *_localctx = _tracker.createInstance<Timing_check_conditionContext>(_ctx, getState());
  enterRule(_localctx, 578, VerilogParser::RuleTiming_check_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3722);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 382, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3717);
      scalar_timing_check_condition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3718);
      match(VerilogParser::LP);
      setState(3719);
      scalar_timing_check_condition();
      setState(3720);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_timing_check_conditionContext ------------------------------------------------------------------

VerilogParser::Scalar_timing_check_conditionContext::Scalar_timing_check_conditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Scalar_timing_check_conditionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::TI() {
  return getToken(VerilogParser::TI, 0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

VerilogParser::Scalar_constantContext* VerilogParser::Scalar_timing_check_conditionContext::scalar_constant() {
  return getRuleContext<VerilogParser::Scalar_constantContext>(0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EQEQEQ() {
  return getToken(VerilogParser::EQEQEQ, 0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::Scalar_timing_check_conditionContext::EMEQEQ() {
  return getToken(VerilogParser::EMEQEQ, 0);
}


size_t VerilogParser::Scalar_timing_check_conditionContext::getRuleIndex() const {
  return VerilogParser::RuleScalar_timing_check_condition;
}


std::any VerilogParser::Scalar_timing_check_conditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitScalar_timing_check_condition(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Scalar_timing_check_conditionContext* VerilogParser::scalar_timing_check_condition() {
  Scalar_timing_check_conditionContext *_localctx = _tracker.createInstance<Scalar_timing_check_conditionContext>(_ctx, getState());
  enterRule(_localctx, 580, VerilogParser::RuleScalar_timing_check_condition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3743);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 383, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3724);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3725);
      match(VerilogParser::TI);
      setState(3726);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3727);
      expression(0);
      setState(3728);
      match(VerilogParser::EQEQ);
      setState(3729);
      scalar_constant();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3731);
      expression(0);
      setState(3732);
      match(VerilogParser::EQEQEQ);
      setState(3733);
      scalar_constant();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3735);
      expression(0);
      setState(3736);
      match(VerilogParser::EMEQ);
      setState(3737);
      scalar_constant();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3739);
      expression(0);
      setState(3740);
      match(VerilogParser::EMEQEQ);
      setState(3741);
      scalar_constant();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Scalar_constantContext ------------------------------------------------------------------

VerilogParser::Scalar_constantContext::Scalar_constantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Binary_numberContext* VerilogParser::Scalar_constantContext::binary_number() {
  return getRuleContext<VerilogParser::Binary_numberContext>(0);
}

VerilogParser::Unsigned_numberContext* VerilogParser::Scalar_constantContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}


size_t VerilogParser::Scalar_constantContext::getRuleIndex() const {
  return VerilogParser::RuleScalar_constant;
}


std::any VerilogParser::Scalar_constantContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitScalar_constant(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Scalar_constantContext* VerilogParser::scalar_constant() {
  Scalar_constantContext *_localctx = _tracker.createInstance<Scalar_constantContext>(_ctx, getState());
  enterRule(_localctx, 582, VerilogParser::RuleScalar_constant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3747);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 384, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3745);
      binary_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3746);
      unsigned_number();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConcatenationContext ------------------------------------------------------------------

VerilogParser::ConcatenationContext::ConcatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::ConcatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::ConcatenationContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::ConcatenationContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::ConcatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::ConcatenationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::ConcatenationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::ConcatenationContext::getRuleIndex() const {
  return VerilogParser::RuleConcatenation;
}


std::any VerilogParser::ConcatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConcatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::ConcatenationContext* VerilogParser::concatenation() {
  ConcatenationContext *_localctx = _tracker.createInstance<ConcatenationContext>(_ctx, getState());
  enterRule(_localctx, 584, VerilogParser::RuleConcatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3749);
    match(VerilogParser::LC);
    setState(3750);
    expression(0);
    setState(3755);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3751);
      match(VerilogParser::CO);
      setState(3752);
      expression(0);
      setState(3757);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3758);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_concatenationContext ------------------------------------------------------------------

VerilogParser::Constant_concatenationContext::Constant_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Constant_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_concatenationContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_concatenationContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_concatenationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Constant_concatenationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Constant_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_concatenation;
}


std::any VerilogParser::Constant_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_concatenationContext* VerilogParser::constant_concatenation() {
  Constant_concatenationContext *_localctx = _tracker.createInstance<Constant_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 586, VerilogParser::RuleConstant_concatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3760);
    match(VerilogParser::LC);
    setState(3761);
    constant_expression(0);
    setState(3766);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3762);
      match(VerilogParser::CO);
      setState(3763);
      constant_expression(0);
      setState(3768);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3769);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_multiple_concatenationContext ------------------------------------------------------------------

VerilogParser::Constant_multiple_concatenationContext::Constant_multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Constant_multiple_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_multiple_concatenationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::Constant_concatenationContext* VerilogParser::Constant_multiple_concatenationContext::constant_concatenation() {
  return getRuleContext<VerilogParser::Constant_concatenationContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_multiple_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}


size_t VerilogParser::Constant_multiple_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_multiple_concatenation;
}


std::any VerilogParser::Constant_multiple_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_multiple_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_multiple_concatenationContext* VerilogParser::constant_multiple_concatenation() {
  Constant_multiple_concatenationContext *_localctx = _tracker.createInstance<Constant_multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 588, VerilogParser::RuleConstant_multiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3771);
    match(VerilogParser::LC);
    setState(3772);
    constant_expression(0);
    setState(3773);
    constant_concatenation();
    setState(3774);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_concatenationContext ------------------------------------------------------------------

VerilogParser::Module_path_concatenationContext::Module_path_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_path_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Module_path_expressionContext *> VerilogParser::Module_path_concatenationContext::module_path_expression() {
  return getRuleContexts<VerilogParser::Module_path_expressionContext>();
}

VerilogParser::Module_path_expressionContext* VerilogParser::Module_path_concatenationContext::module_path_expression(size_t i) {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Module_path_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_path_concatenationContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Module_path_concatenationContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Module_path_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_concatenation;
}


std::any VerilogParser::Module_path_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_concatenationContext* VerilogParser::module_path_concatenation() {
  Module_path_concatenationContext *_localctx = _tracker.createInstance<Module_path_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 590, VerilogParser::RuleModule_path_concatenation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3776);
    match(VerilogParser::LC);
    setState(3777);
    module_path_expression(0);
    setState(3782);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3778);
      match(VerilogParser::CO);
      setState(3779);
      module_path_expression(0);
      setState(3784);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3785);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_multiple_concatenationContext ------------------------------------------------------------------

VerilogParser::Module_path_multiple_concatenationContext::Module_path_multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Module_path_multiple_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Module_path_multiple_concatenationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::Module_path_concatenationContext* VerilogParser::Module_path_multiple_concatenationContext::module_path_concatenation() {
  return getRuleContext<VerilogParser::Module_path_concatenationContext>(0);
}

tree::TerminalNode* VerilogParser::Module_path_multiple_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}


size_t VerilogParser::Module_path_multiple_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_multiple_concatenation;
}


std::any VerilogParser::Module_path_multiple_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_multiple_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_multiple_concatenationContext* VerilogParser::module_path_multiple_concatenation() {
  Module_path_multiple_concatenationContext *_localctx = _tracker.createInstance<Module_path_multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 592, VerilogParser::RuleModule_path_multiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3787);
    match(VerilogParser::LC);
    setState(3788);
    constant_expression(0);
    setState(3789);
    module_path_concatenation();
    setState(3790);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Multiple_concatenationContext ------------------------------------------------------------------

VerilogParser::Multiple_concatenationContext::Multiple_concatenationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Multiple_concatenationContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Multiple_concatenationContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::ConcatenationContext* VerilogParser::Multiple_concatenationContext::concatenation() {
  return getRuleContext<VerilogParser::ConcatenationContext>(0);
}

tree::TerminalNode* VerilogParser::Multiple_concatenationContext::RC() {
  return getToken(VerilogParser::RC, 0);
}


size_t VerilogParser::Multiple_concatenationContext::getRuleIndex() const {
  return VerilogParser::RuleMultiple_concatenation;
}


std::any VerilogParser::Multiple_concatenationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMultiple_concatenation(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Multiple_concatenationContext* VerilogParser::multiple_concatenation() {
  Multiple_concatenationContext *_localctx = _tracker.createInstance<Multiple_concatenationContext>(_ctx, getState());
  enterRule(_localctx, 594, VerilogParser::RuleMultiple_concatenation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3792);
    match(VerilogParser::LC);
    setState(3793);
    constant_expression(0);
    setState(3794);
    concatenation();
    setState(3795);
    match(VerilogParser::RC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_function_callContext ------------------------------------------------------------------

VerilogParser::Constant_function_callContext::Constant_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Function_identifierContext* VerilogParser::Constant_function_callContext::function_identifier() {
  return getRuleContext<VerilogParser::Function_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_function_callContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_function_callContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_function_callContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_function_callContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Constant_function_callContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Constant_function_callContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_function_callContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Constant_function_callContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Constant_function_callContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_function_call;
}


std::any VerilogParser::Constant_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_function_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_function_callContext* VerilogParser::constant_function_call() {
  Constant_function_callContext *_localctx = _tracker.createInstance<Constant_function_callContext>(_ctx, getState());
  enterRule(_localctx, 596, VerilogParser::RuleConstant_function_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3797);
    function_identifier();
    setState(3801);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 388, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3798);
        attribute_instance(); 
      }
      setState(3803);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 388, _ctx);
    }
    setState(3804);
    match(VerilogParser::LP);
    setState(3805);
    constant_expression(0);
    setState(3810);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3806);
      match(VerilogParser::CO);
      setState(3807);
      constant_expression(0);
      setState(3812);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3813);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_system_function_callContext ------------------------------------------------------------------

VerilogParser::Constant_system_function_callContext::Constant_system_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::System_function_identifierContext* VerilogParser::Constant_system_function_callContext::system_function_identifier() {
  return getRuleContext<VerilogParser::System_function_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_system_function_callContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_system_function_callContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_system_function_callContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_system_function_callContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_system_function_callContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Constant_system_function_callContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Constant_system_function_callContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_system_function_call;
}


std::any VerilogParser::Constant_system_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_system_function_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_system_function_callContext* VerilogParser::constant_system_function_call() {
  Constant_system_function_callContext *_localctx = _tracker.createInstance<Constant_system_function_callContext>(_ctx, getState());
  enterRule(_localctx, 598, VerilogParser::RuleConstant_system_function_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3815);
    system_function_identifier();
    setState(3816);
    match(VerilogParser::LP);
    setState(3817);
    constant_expression(0);
    setState(3822);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3818);
      match(VerilogParser::CO);
      setState(3819);
      constant_expression(0);
      setState(3824);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3825);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_callContext ------------------------------------------------------------------

VerilogParser::Function_callContext::Function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Function_callContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

tree::TerminalNode* VerilogParser::Function_callContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Function_callContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Function_callContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Function_callContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Function_callContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Function_callContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Function_callContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Function_callContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Function_callContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_call;
}


std::any VerilogParser::Function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_callContext* VerilogParser::function_call() {
  Function_callContext *_localctx = _tracker.createInstance<Function_callContext>(_ctx, getState());
  enterRule(_localctx, 600, VerilogParser::RuleFunction_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3827);
    hierarchical_identifier();
    setState(3831);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 391, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3828);
        attribute_instance(); 
      }
      setState(3833);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 391, _ctx);
    }
    setState(3834);
    match(VerilogParser::LP);
    setState(3835);
    expression(0);
    setState(3840);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3836);
      match(VerilogParser::CO);
      setState(3837);
      expression(0);
      setState(3842);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3843);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_function_callContext ------------------------------------------------------------------

VerilogParser::System_function_callContext::System_function_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::System_function_identifierContext* VerilogParser::System_function_callContext::system_function_identifier() {
  return getRuleContext<VerilogParser::System_function_identifierContext>(0);
}

VerilogParser::Sys_func_call_port_listContext* VerilogParser::System_function_callContext::sys_func_call_port_list() {
  return getRuleContext<VerilogParser::Sys_func_call_port_listContext>(0);
}


size_t VerilogParser::System_function_callContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_function_call;
}


std::any VerilogParser::System_function_callContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_function_call(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_function_callContext* VerilogParser::system_function_call() {
  System_function_callContext *_localctx = _tracker.createInstance<System_function_callContext>(_ctx, getState());
  enterRule(_localctx, 602, VerilogParser::RuleSystem_function_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3845);
    system_function_identifier();
    setState(3847);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 393, _ctx)) {
    case 1: {
      setState(3846);
      sys_func_call_port_list();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sys_func_call_port_listContext ------------------------------------------------------------------

VerilogParser::Sys_func_call_port_listContext::Sys_func_call_port_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Sys_func_call_port_listContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Sys_func_call_port_listContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Sys_func_call_port_listContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::Sys_func_call_port_listContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Sys_func_call_port_listContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Sys_func_call_port_listContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Sys_func_call_port_listContext::getRuleIndex() const {
  return VerilogParser::RuleSys_func_call_port_list;
}


std::any VerilogParser::Sys_func_call_port_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSys_func_call_port_list(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Sys_func_call_port_listContext* VerilogParser::sys_func_call_port_list() {
  Sys_func_call_port_listContext *_localctx = _tracker.createInstance<Sys_func_call_port_listContext>(_ctx, getState());
  enterRule(_localctx, 604, VerilogParser::RuleSys_func_call_port_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3849);
    match(VerilogParser::LP);
    setState(3850);
    expression(0);
    setState(3855);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(3851);
      match(VerilogParser::CO);
      setState(3852);
      expression(0);
      setState(3857);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3858);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Base_expressionContext ------------------------------------------------------------------

VerilogParser::Base_expressionContext::Base_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Base_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}


size_t VerilogParser::Base_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleBase_expression;
}


std::any VerilogParser::Base_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBase_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Base_expressionContext* VerilogParser::base_expression() {
  Base_expressionContext *_localctx = _tracker.createInstance<Base_expressionContext>(_ctx, getState());
  enterRule(_localctx, 606, VerilogParser::RuleBase_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3860);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_base_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_base_expressionContext::Constant_base_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_base_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Constant_base_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_base_expression;
}


std::any VerilogParser::Constant_base_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_base_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_base_expressionContext* VerilogParser::constant_base_expression() {
  Constant_base_expressionContext *_localctx = _tracker.createInstance<Constant_base_expressionContext>(_ctx, getState());
  enterRule(_localctx, 608, VerilogParser::RuleConstant_base_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3862);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_expressionContext::Constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_primaryContext* VerilogParser::Constant_expressionContext::constant_primary() {
  return getRuleContext<VerilogParser::Constant_primaryContext>(0);
}

VerilogParser::Unary_operatorContext* VerilogParser::Constant_expressionContext::unary_operator() {
  return getRuleContext<VerilogParser::Unary_operatorContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Constant_expressionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Constant_expressionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_expressionContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_expressionContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::ASAS() {
  return getToken(VerilogParser::ASAS, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::AS() {
  return getToken(VerilogParser::AS, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::SL() {
  return getToken(VerilogParser::SL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::MO() {
  return getToken(VerilogParser::MO, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::MI() {
  return getToken(VerilogParser::MI, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GTGT() {
  return getToken(VerilogParser::GTGT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LTLT() {
  return getToken(VerilogParser::LTLT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GTGTGT() {
  return getToken(VerilogParser::GTGTGT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LTLTLT() {
  return getToken(VerilogParser::LTLTLT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LT() {
  return getToken(VerilogParser::LT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::LTEQ() {
  return getToken(VerilogParser::LTEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GT() {
  return getToken(VerilogParser::GT, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::GTEQ() {
  return getToken(VerilogParser::GTEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EQEQEQ() {
  return getToken(VerilogParser::EQEQEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::EMEQEQ() {
  return getToken(VerilogParser::EMEQEQ, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::AMAM() {
  return getToken(VerilogParser::AMAM, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::VLVL() {
  return getToken(VerilogParser::VLVL, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::QM() {
  return getToken(VerilogParser::QM, 0);
}

tree::TerminalNode* VerilogParser::Constant_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}


size_t VerilogParser::Constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_expression;
}


std::any VerilogParser::Constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_expression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::Constant_expressionContext* VerilogParser::constant_expression() {
   return constant_expression(0);
}

VerilogParser::Constant_expressionContext* VerilogParser::constant_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::Constant_expressionContext *_localctx = _tracker.createInstance<Constant_expressionContext>(_ctx, parentState);
  VerilogParser::Constant_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 610;
  enterRecursionRule(_localctx, 610, VerilogParser::RuleConstant_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3875);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        setState(3865);
        constant_primary();
        break;
      }

      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::CATI:
      case VerilogParser::EM:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL: {
        setState(3866);
        unary_operator();
        setState(3870);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 395, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(3867);
            attribute_instance(); 
          }
          setState(3872);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 395, _ctx);
        }
        setState(3873);
        constant_primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(3990);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(3988);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3877);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(3878);
          match(VerilogParser::ASAS);
          setState(3882);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 397, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3879);
              attribute_instance(); 
            }
            setState(3884);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 397, _ctx);
          }
          setState(3885);
          constant_expression(13);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3886);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(3887);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::AS || _la == VerilogParser::MO

          || _la == VerilogParser::SL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3891);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3888);
              attribute_instance(); 
            }
            setState(3893);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 398, _ctx);
          }
          setState(3894);
          constant_expression(12);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3895);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(3896);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::MI

          || _la == VerilogParser::PL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3900);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3897);
              attribute_instance(); 
            }
            setState(3902);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx);
          }
          setState(3903);
          constant_expression(11);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3904);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(3905);
          _la = _input->LA(1);
          if (!((((_la - 76) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 76)) & 25165827) != 0)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3909);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 400, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3906);
              attribute_instance(); 
            }
            setState(3911);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 400, _ctx);
          }
          setState(3912);
          constant_expression(10);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3913);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(3914);
          _la = _input->LA(1);
          if (!((((_la - 74) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 74)) & 25165827) != 0)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3918);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3915);
              attribute_instance(); 
            }
            setState(3920);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx);
          }
          setState(3921);
          constant_expression(9);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3922);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(3923);
          _la = _input->LA(1);
          if (!(((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -4609997168567123968) != 0)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3927);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3924);
              attribute_instance(); 
            }
            setState(3929);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx);
          }
          setState(3930);
          constant_expression(8);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3931);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(3932);
          match(VerilogParser::AM);
          setState(3936);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3933);
              attribute_instance(); 
            }
            setState(3938);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx);
          }
          setState(3939);
          constant_expression(7);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3940);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(3941);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::CA

          || _la == VerilogParser::CATI || _la == VerilogParser::TICA)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(3945);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3942);
              attribute_instance(); 
            }
            setState(3947);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx);
          }
          setState(3948);
          constant_expression(6);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3949);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(3950);
          match(VerilogParser::VL);
          setState(3954);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3951);
              attribute_instance(); 
            }
            setState(3956);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx);
          }
          setState(3957);
          constant_expression(5);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3958);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(3959);
          match(VerilogParser::AMAM);
          setState(3963);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3960);
              attribute_instance(); 
            }
            setState(3965);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx);
          }
          setState(3966);
          constant_expression(4);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3967);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(3968);
          match(VerilogParser::VLVL);
          setState(3972);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3969);
              attribute_instance(); 
            }
            setState(3974);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx);
          }
          setState(3975);
          constant_expression(3);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<Constant_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleConstant_expression);
          setState(3976);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(3977);
          match(VerilogParser::QM);
          setState(3981);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(3978);
              attribute_instance(); 
            }
            setState(3983);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx);
          }
          setState(3984);
          constant_expression(0);
          setState(3985);
          match(VerilogParser::CL);
          setState(3986);
          constant_expression(1);
          break;
        }

        default:
          break;
        } 
      }
      setState(3992);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Constant_mintypmax_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_mintypmax_expressionContext::Constant_mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Constant_mintypmax_expressionContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_mintypmax_expressionContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Constant_mintypmax_expressionContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Constant_mintypmax_expressionContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}


size_t VerilogParser::Constant_mintypmax_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_mintypmax_expression;
}


std::any VerilogParser::Constant_mintypmax_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_mintypmax_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::constant_mintypmax_expression() {
  Constant_mintypmax_expressionContext *_localctx = _tracker.createInstance<Constant_mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 612, VerilogParser::RuleConstant_mintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3993);
    constant_expression(0);
    setState(3999);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(3994);
      match(VerilogParser::CL);
      setState(3995);
      constant_expression(0);
      setState(3996);
      match(VerilogParser::CL);
      setState(3997);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_range_expressionContext ------------------------------------------------------------------

VerilogParser::Constant_range_expressionContext::Constant_range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Constant_range_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::Constant_range_expressionContext::msb_constant_expression() {
  return getRuleContext<VerilogParser::Msb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_range_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::Constant_range_expressionContext::lsb_constant_expression() {
  return getRuleContext<VerilogParser::Lsb_constant_expressionContext>(0);
}

VerilogParser::Constant_base_expressionContext* VerilogParser::Constant_range_expressionContext::constant_base_expression() {
  return getRuleContext<VerilogParser::Constant_base_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_range_expressionContext::PLCL() {
  return getToken(VerilogParser::PLCL, 0);
}

VerilogParser::Width_constant_expressionContext* VerilogParser::Constant_range_expressionContext::width_constant_expression() {
  return getRuleContext<VerilogParser::Width_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_range_expressionContext::MICL() {
  return getToken(VerilogParser::MICL, 0);
}


size_t VerilogParser::Constant_range_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_range_expression;
}


std::any VerilogParser::Constant_range_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_range_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::constant_range_expression() {
  Constant_range_expressionContext *_localctx = _tracker.createInstance<Constant_range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 614, VerilogParser::RuleConstant_range_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4014);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 412, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4001);
      constant_expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4002);
      msb_constant_expression();
      setState(4003);
      match(VerilogParser::CL);
      setState(4004);
      lsb_constant_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4006);
      constant_base_expression();
      setState(4007);
      match(VerilogParser::PLCL);
      setState(4008);
      width_constant_expression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4010);
      constant_base_expression();
      setState(4011);
      match(VerilogParser::MICL);
      setState(4012);
      width_constant_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Dimension_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Dimension_constant_expressionContext::Dimension_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Dimension_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Dimension_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleDimension_constant_expression;
}


std::any VerilogParser::Dimension_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDimension_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Dimension_constant_expressionContext* VerilogParser::dimension_constant_expression() {
  Dimension_constant_expressionContext *_localctx = _tracker.createInstance<Dimension_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 616, VerilogParser::RuleDimension_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4016);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

VerilogParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::PrimaryContext* VerilogParser::ExpressionContext::primary() {
  return getRuleContext<VerilogParser::PrimaryContext>(0);
}

VerilogParser::Unary_operatorContext* VerilogParser::ExpressionContext::unary_operator() {
  return getRuleContext<VerilogParser::Unary_operatorContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::ExpressionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::ExpressionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::ExpressionContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

tree::TerminalNode* VerilogParser::ExpressionContext::ASAS() {
  return getToken(VerilogParser::ASAS, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::AS() {
  return getToken(VerilogParser::AS, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::SL() {
  return getToken(VerilogParser::SL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::MO() {
  return getToken(VerilogParser::MO, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::MI() {
  return getToken(VerilogParser::MI, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GTGT() {
  return getToken(VerilogParser::GTGT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LTLT() {
  return getToken(VerilogParser::LTLT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GTGTGT() {
  return getToken(VerilogParser::GTGTGT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LTLTLT() {
  return getToken(VerilogParser::LTLTLT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LT() {
  return getToken(VerilogParser::LT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::LTEQ() {
  return getToken(VerilogParser::LTEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GT() {
  return getToken(VerilogParser::GT, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::GTEQ() {
  return getToken(VerilogParser::GTEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EQEQEQ() {
  return getToken(VerilogParser::EQEQEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::EMEQEQ() {
  return getToken(VerilogParser::EMEQEQ, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::AMAM() {
  return getToken(VerilogParser::AMAM, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::VLVL() {
  return getToken(VerilogParser::VLVL, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::QM() {
  return getToken(VerilogParser::QM, 0);
}

tree::TerminalNode* VerilogParser::ExpressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}


size_t VerilogParser::ExpressionContext::getRuleIndex() const {
  return VerilogParser::RuleExpression;
}


std::any VerilogParser::ExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitExpression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::ExpressionContext* VerilogParser::expression() {
   return expression(0);
}

VerilogParser::ExpressionContext* VerilogParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  VerilogParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 618;
  enterRecursionRule(_localctx, 618, VerilogParser::RuleExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4029);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::STRING:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        setState(4019);
        primary();
        break;
      }

      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::CATI:
      case VerilogParser::EM:
      case VerilogParser::MI:
      case VerilogParser::PL:
      case VerilogParser::TI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL: {
        setState(4020);
        unary_operator();
        setState(4024);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(4021);
            attribute_instance(); 
          }
          setState(4026);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 413, _ctx);
        }
        setState(4027);
        primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(4144);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(4142);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 427, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4031);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(4032);
          match(VerilogParser::ASAS);
          setState(4036);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4033);
              attribute_instance(); 
            }
            setState(4038);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 415, _ctx);
          }
          setState(4039);
          expression(13);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4040);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(4041);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::AS || _la == VerilogParser::MO

          || _la == VerilogParser::SL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4045);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4042);
              attribute_instance(); 
            }
            setState(4047);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx);
          }
          setState(4048);
          expression(12);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4049);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(4050);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::MI

          || _la == VerilogParser::PL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4054);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 417, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4051);
              attribute_instance(); 
            }
            setState(4056);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 417, _ctx);
          }
          setState(4057);
          expression(11);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4058);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(4059);
          _la = _input->LA(1);
          if (!((((_la - 76) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 76)) & 25165827) != 0)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4063);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4060);
              attribute_instance(); 
            }
            setState(4065);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx);
          }
          setState(4066);
          expression(10);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4067);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(4068);
          _la = _input->LA(1);
          if (!((((_la - 74) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 74)) & 25165827) != 0)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4072);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 419, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4069);
              attribute_instance(); 
            }
            setState(4074);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 419, _ctx);
          }
          setState(4075);
          expression(9);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4076);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(4077);
          _la = _input->LA(1);
          if (!(((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & -4609997168567123968) != 0)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4081);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 420, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4078);
              attribute_instance(); 
            }
            setState(4083);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 420, _ctx);
          }
          setState(4084);
          expression(8);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4085);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(4086);
          match(VerilogParser::AM);
          setState(4090);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4087);
              attribute_instance(); 
            }
            setState(4092);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx);
          }
          setState(4093);
          expression(7);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4094);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(4095);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::CA

          || _la == VerilogParser::CATI || _la == VerilogParser::TICA)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4099);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4096);
              attribute_instance(); 
            }
            setState(4101);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx);
          }
          setState(4102);
          expression(6);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4103);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(4104);
          match(VerilogParser::VL);
          setState(4108);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4105);
              attribute_instance(); 
            }
            setState(4110);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 423, _ctx);
          }
          setState(4111);
          expression(5);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4112);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(4113);
          match(VerilogParser::AMAM);
          setState(4117);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4114);
              attribute_instance(); 
            }
            setState(4119);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 424, _ctx);
          }
          setState(4120);
          expression(4);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4121);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(4122);
          match(VerilogParser::VLVL);
          setState(4126);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 425, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4123);
              attribute_instance(); 
            }
            setState(4128);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 425, _ctx);
          }
          setState(4129);
          expression(3);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(4130);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(4131);
          match(VerilogParser::QM);
          setState(4135);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4132);
              attribute_instance(); 
            }
            setState(4137);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 426, _ctx);
          }
          setState(4138);
          expression(0);
          setState(4139);
          match(VerilogParser::CL);
          setState(4140);
          expression(1);
          break;
        }

        default:
          break;
        } 
      }
      setState(4146);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 428, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Lsb_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Lsb_constant_expressionContext::Lsb_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Lsb_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Lsb_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleLsb_constant_expression;
}


std::any VerilogParser::Lsb_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLsb_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::lsb_constant_expression() {
  Lsb_constant_expressionContext *_localctx = _tracker.createInstance<Lsb_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 620, VerilogParser::RuleLsb_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4147);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mintypmax_expressionContext ------------------------------------------------------------------

VerilogParser::Mintypmax_expressionContext::Mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Mintypmax_expressionContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Mintypmax_expressionContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Mintypmax_expressionContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Mintypmax_expressionContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}


size_t VerilogParser::Mintypmax_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleMintypmax_expression;
}


std::any VerilogParser::Mintypmax_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMintypmax_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::mintypmax_expression() {
  Mintypmax_expressionContext *_localctx = _tracker.createInstance<Mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 622, VerilogParser::RuleMintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4149);
    expression(0);
    setState(4155);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(4150);
      match(VerilogParser::CL);
      setState(4151);
      expression(0);
      setState(4152);
      match(VerilogParser::CL);
      setState(4153);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_expressionContext ------------------------------------------------------------------

VerilogParser::Module_path_expressionContext::Module_path_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Module_path_primaryContext* VerilogParser::Module_path_expressionContext::module_path_primary() {
  return getRuleContext<VerilogParser::Module_path_primaryContext>(0);
}

VerilogParser::Unary_module_path_operatorContext* VerilogParser::Module_path_expressionContext::unary_module_path_operator() {
  return getRuleContext<VerilogParser::Unary_module_path_operatorContext>(0);
}

std::vector<VerilogParser::Attribute_instanceContext *> VerilogParser::Module_path_expressionContext::attribute_instance() {
  return getRuleContexts<VerilogParser::Attribute_instanceContext>();
}

VerilogParser::Attribute_instanceContext* VerilogParser::Module_path_expressionContext::attribute_instance(size_t i) {
  return getRuleContext<VerilogParser::Attribute_instanceContext>(i);
}

std::vector<VerilogParser::Module_path_expressionContext *> VerilogParser::Module_path_expressionContext::module_path_expression() {
  return getRuleContexts<VerilogParser::Module_path_expressionContext>();
}

VerilogParser::Module_path_expressionContext* VerilogParser::Module_path_expressionContext::module_path_expression(size_t i) {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(i);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::EQEQ() {
  return getToken(VerilogParser::EQEQ, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::EMEQ() {
  return getToken(VerilogParser::EMEQ, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::AMAM() {
  return getToken(VerilogParser::AMAM, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::VLVL() {
  return getToken(VerilogParser::VLVL, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::QM() {
  return getToken(VerilogParser::QM, 0);
}

tree::TerminalNode* VerilogParser::Module_path_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}


size_t VerilogParser::Module_path_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_expression;
}


std::any VerilogParser::Module_path_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_expression(this);
  else
    return visitor->visitChildren(this);
}


VerilogParser::Module_path_expressionContext* VerilogParser::module_path_expression() {
   return module_path_expression(0);
}

VerilogParser::Module_path_expressionContext* VerilogParser::module_path_expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  VerilogParser::Module_path_expressionContext *_localctx = _tracker.createInstance<Module_path_expressionContext>(_ctx, parentState);
  VerilogParser::Module_path_expressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 624;
  enterRecursionRule(_localctx, 624, VerilogParser::RuleModule_path_expression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4168);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::LC:
      case VerilogParser::LP:
      case VerilogParser::BINARY_BASE:
      case VerilogParser::DECIMAL_BASE:
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::EXPONENTIAL_NUMBER:
      case VerilogParser::FIXED_POINT_NUMBER:
      case VerilogParser::HEX_BASE:
      case VerilogParser::OCTAL_BASE:
      case VerilogParser::SIMPLE_IDENTIFIER:
      case VerilogParser::SYSTEM_TF_IDENTIFIER:
      case VerilogParser::UNSIGNED_NUMBER: {
        setState(4158);
        module_path_primary();
        break;
      }

      case VerilogParser::AM:
      case VerilogParser::CA:
      case VerilogParser::CATI:
      case VerilogParser::EM:
      case VerilogParser::TI:
      case VerilogParser::TIAM:
      case VerilogParser::TICA:
      case VerilogParser::TIVL:
      case VerilogParser::VL: {
        setState(4159);
        unary_module_path_operator();
        setState(4163);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(4160);
            attribute_instance(); 
          }
          setState(4165);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx);
        }
        setState(4166);
        module_path_primary();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(4238);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(4236);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 439, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4170);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(4171);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::EMEQ

          || _la == VerilogParser::EQEQ)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4175);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 432, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4172);
              attribute_instance(); 
            }
            setState(4177);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 432, _ctx);
          }
          setState(4178);
          module_path_expression(8);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4179);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(4180);
          match(VerilogParser::AM);
          setState(4184);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4181);
              attribute_instance(); 
            }
            setState(4186);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 433, _ctx);
          }
          setState(4187);
          module_path_expression(7);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4188);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(4189);
          _la = _input->LA(1);
          if (!(_la == VerilogParser::CA

          || _la == VerilogParser::CATI || _la == VerilogParser::TICA)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(4193);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4190);
              attribute_instance(); 
            }
            setState(4195);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx);
          }
          setState(4196);
          module_path_expression(6);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4197);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(4198);
          match(VerilogParser::VL);
          setState(4202);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4199);
              attribute_instance(); 
            }
            setState(4204);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx);
          }
          setState(4205);
          module_path_expression(5);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4206);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(4207);
          match(VerilogParser::AMAM);
          setState(4211);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4208);
              attribute_instance(); 
            }
            setState(4213);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx);
          }
          setState(4214);
          module_path_expression(4);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4215);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(4216);
          match(VerilogParser::VLVL);
          setState(4220);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4217);
              attribute_instance(); 
            }
            setState(4222);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx);
          }
          setState(4223);
          module_path_expression(3);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<Module_path_expressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleModule_path_expression);
          setState(4224);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(4225);
          match(VerilogParser::QM);
          setState(4229);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx);
          while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(4226);
              attribute_instance(); 
            }
            setState(4231);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx);
          }
          setState(4232);
          module_path_expression(0);
          setState(4233);
          match(VerilogParser::CL);
          setState(4234);
          module_path_expression(1);
          break;
        }

        default:
          break;
        } 
      }
      setState(4240);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Module_path_mintypmax_expressionContext ------------------------------------------------------------------

VerilogParser::Module_path_mintypmax_expressionContext::Module_path_mintypmax_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<VerilogParser::Module_path_expressionContext *> VerilogParser::Module_path_mintypmax_expressionContext::module_path_expression() {
  return getRuleContexts<VerilogParser::Module_path_expressionContext>();
}

VerilogParser::Module_path_expressionContext* VerilogParser::Module_path_mintypmax_expressionContext::module_path_expression(size_t i) {
  return getRuleContext<VerilogParser::Module_path_expressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Module_path_mintypmax_expressionContext::CL() {
  return getTokens(VerilogParser::CL);
}

tree::TerminalNode* VerilogParser::Module_path_mintypmax_expressionContext::CL(size_t i) {
  return getToken(VerilogParser::CL, i);
}


size_t VerilogParser::Module_path_mintypmax_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_mintypmax_expression;
}


std::any VerilogParser::Module_path_mintypmax_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_mintypmax_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_mintypmax_expressionContext* VerilogParser::module_path_mintypmax_expression() {
  Module_path_mintypmax_expressionContext *_localctx = _tracker.createInstance<Module_path_mintypmax_expressionContext>(_ctx, getState());
  enterRule(_localctx, 626, VerilogParser::RuleModule_path_mintypmax_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4241);
    module_path_expression(0);
    setState(4247);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::CL) {
      setState(4242);
      match(VerilogParser::CL);
      setState(4243);
      module_path_expression(0);
      setState(4244);
      match(VerilogParser::CL);
      setState(4245);
      module_path_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Msb_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Msb_constant_expressionContext::Msb_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Msb_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Msb_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleMsb_constant_expression;
}


std::any VerilogParser::Msb_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitMsb_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::msb_constant_expression() {
  Msb_constant_expressionContext *_localctx = _tracker.createInstance<Msb_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 628, VerilogParser::RuleMsb_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4249);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Range_expressionContext ------------------------------------------------------------------

VerilogParser::Range_expressionContext::Range_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::ExpressionContext* VerilogParser::Range_expressionContext::expression() {
  return getRuleContext<VerilogParser::ExpressionContext>(0);
}

VerilogParser::Msb_constant_expressionContext* VerilogParser::Range_expressionContext::msb_constant_expression() {
  return getRuleContext<VerilogParser::Msb_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_expressionContext::CL() {
  return getToken(VerilogParser::CL, 0);
}

VerilogParser::Lsb_constant_expressionContext* VerilogParser::Range_expressionContext::lsb_constant_expression() {
  return getRuleContext<VerilogParser::Lsb_constant_expressionContext>(0);
}

VerilogParser::Base_expressionContext* VerilogParser::Range_expressionContext::base_expression() {
  return getRuleContext<VerilogParser::Base_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_expressionContext::PLCL() {
  return getToken(VerilogParser::PLCL, 0);
}

VerilogParser::Width_constant_expressionContext* VerilogParser::Range_expressionContext::width_constant_expression() {
  return getRuleContext<VerilogParser::Width_constant_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Range_expressionContext::MICL() {
  return getToken(VerilogParser::MICL, 0);
}


size_t VerilogParser::Range_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleRange_expression;
}


std::any VerilogParser::Range_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitRange_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Range_expressionContext* VerilogParser::range_expression() {
  Range_expressionContext *_localctx = _tracker.createInstance<Range_expressionContext>(_ctx, getState());
  enterRule(_localctx, 630, VerilogParser::RuleRange_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4264);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 442, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4251);
      expression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4252);
      msb_constant_expression();
      setState(4253);
      match(VerilogParser::CL);
      setState(4254);
      lsb_constant_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4256);
      base_expression();
      setState(4257);
      match(VerilogParser::PLCL);
      setState(4258);
      width_constant_expression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4260);
      base_expression();
      setState(4261);
      match(VerilogParser::MICL);
      setState(4262);
      width_constant_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Width_constant_expressionContext ------------------------------------------------------------------

VerilogParser::Width_constant_expressionContext::Width_constant_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Constant_expressionContext* VerilogParser::Width_constant_expressionContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Width_constant_expressionContext::getRuleIndex() const {
  return VerilogParser::RuleWidth_constant_expression;
}


std::any VerilogParser::Width_constant_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitWidth_constant_expression(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Width_constant_expressionContext* VerilogParser::width_constant_expression() {
  Width_constant_expressionContext *_localctx = _tracker.createInstance<Width_constant_expressionContext>(_ctx, getState());
  enterRule(_localctx, 632, VerilogParser::RuleWidth_constant_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4266);
    constant_expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Constant_primaryContext ------------------------------------------------------------------

VerilogParser::Constant_primaryContext::Constant_primaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::NumberContext* VerilogParser::Constant_primaryContext::number() {
  return getRuleContext<VerilogParser::NumberContext>(0);
}

VerilogParser::IdentifierContext* VerilogParser::Constant_primaryContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Constant_primaryContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::RB() {
  return getToken(VerilogParser::RB, 0);
}

VerilogParser::Constant_concatenationContext* VerilogParser::Constant_primaryContext::constant_concatenation() {
  return getRuleContext<VerilogParser::Constant_concatenationContext>(0);
}

VerilogParser::Constant_multiple_concatenationContext* VerilogParser::Constant_primaryContext::constant_multiple_concatenation() {
  return getRuleContext<VerilogParser::Constant_multiple_concatenationContext>(0);
}

VerilogParser::Constant_function_callContext* VerilogParser::Constant_primaryContext::constant_function_call() {
  return getRuleContext<VerilogParser::Constant_function_callContext>(0);
}

VerilogParser::Constant_system_function_callContext* VerilogParser::Constant_primaryContext::constant_system_function_call() {
  return getRuleContext<VerilogParser::Constant_system_function_callContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Constant_mintypmax_expressionContext* VerilogParser::Constant_primaryContext::constant_mintypmax_expression() {
  return getRuleContext<VerilogParser::Constant_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Constant_primaryContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::String_Context* VerilogParser::Constant_primaryContext::string_() {
  return getRuleContext<VerilogParser::String_Context>(0);
}


size_t VerilogParser::Constant_primaryContext::getRuleIndex() const {
  return VerilogParser::RuleConstant_primary;
}


std::any VerilogParser::Constant_primaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConstant_primary(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Constant_primaryContext* VerilogParser::constant_primary() {
  Constant_primaryContext *_localctx = _tracker.createInstance<Constant_primaryContext>(_ctx, getState());
  enterRule(_localctx, 634, VerilogParser::RuleConstant_primary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4285);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 444, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4268);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4269);
      identifier();
      setState(4274);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 443, _ctx)) {
      case 1: {
        setState(4270);
        match(VerilogParser::LB);
        setState(4271);
        constant_range_expression();
        setState(4272);
        match(VerilogParser::RB);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4276);
      constant_concatenation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4277);
      constant_multiple_concatenation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4278);
      constant_function_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4279);
      constant_system_function_call();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4280);
      match(VerilogParser::LP);
      setState(4281);
      constant_mintypmax_expression();
      setState(4282);
      match(VerilogParser::RP);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4284);
      string_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_path_primaryContext ------------------------------------------------------------------

VerilogParser::Module_path_primaryContext::Module_path_primaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::NumberContext* VerilogParser::Module_path_primaryContext::number() {
  return getRuleContext<VerilogParser::NumberContext>(0);
}

VerilogParser::IdentifierContext* VerilogParser::Module_path_primaryContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

VerilogParser::Module_path_concatenationContext* VerilogParser::Module_path_primaryContext::module_path_concatenation() {
  return getRuleContext<VerilogParser::Module_path_concatenationContext>(0);
}

VerilogParser::Module_path_multiple_concatenationContext* VerilogParser::Module_path_primaryContext::module_path_multiple_concatenation() {
  return getRuleContext<VerilogParser::Module_path_multiple_concatenationContext>(0);
}

VerilogParser::Function_callContext* VerilogParser::Module_path_primaryContext::function_call() {
  return getRuleContext<VerilogParser::Function_callContext>(0);
}

VerilogParser::System_function_callContext* VerilogParser::Module_path_primaryContext::system_function_call() {
  return getRuleContext<VerilogParser::System_function_callContext>(0);
}

tree::TerminalNode* VerilogParser::Module_path_primaryContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Module_path_mintypmax_expressionContext* VerilogParser::Module_path_primaryContext::module_path_mintypmax_expression() {
  return getRuleContext<VerilogParser::Module_path_mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Module_path_primaryContext::RP() {
  return getToken(VerilogParser::RP, 0);
}


size_t VerilogParser::Module_path_primaryContext::getRuleIndex() const {
  return VerilogParser::RuleModule_path_primary;
}


std::any VerilogParser::Module_path_primaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_path_primary(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_path_primaryContext* VerilogParser::module_path_primary() {
  Module_path_primaryContext *_localctx = _tracker.createInstance<Module_path_primaryContext>(_ctx, getState());
  enterRule(_localctx, 636, VerilogParser::RuleModule_path_primary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4297);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 445, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4287);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4288);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4289);
      module_path_concatenation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4290);
      module_path_multiple_concatenation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4291);
      function_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4292);
      system_function_call();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4293);
      match(VerilogParser::LP);
      setState(4294);
      module_path_mintypmax_expression();
      setState(4295);
      match(VerilogParser::RP);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryContext ------------------------------------------------------------------

VerilogParser::PrimaryContext::PrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::NumberContext* VerilogParser::PrimaryContext::number() {
  return getRuleContext<VerilogParser::NumberContext>(0);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::PrimaryContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

VerilogParser::Select_Context* VerilogParser::PrimaryContext::select_() {
  return getRuleContext<VerilogParser::Select_Context>(0);
}

VerilogParser::ConcatenationContext* VerilogParser::PrimaryContext::concatenation() {
  return getRuleContext<VerilogParser::ConcatenationContext>(0);
}

VerilogParser::Multiple_concatenationContext* VerilogParser::PrimaryContext::multiple_concatenation() {
  return getRuleContext<VerilogParser::Multiple_concatenationContext>(0);
}

VerilogParser::Function_callContext* VerilogParser::PrimaryContext::function_call() {
  return getRuleContext<VerilogParser::Function_callContext>(0);
}

VerilogParser::System_function_callContext* VerilogParser::PrimaryContext::system_function_call() {
  return getRuleContext<VerilogParser::System_function_callContext>(0);
}

tree::TerminalNode* VerilogParser::PrimaryContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

VerilogParser::Mintypmax_expressionContext* VerilogParser::PrimaryContext::mintypmax_expression() {
  return getRuleContext<VerilogParser::Mintypmax_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::PrimaryContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

VerilogParser::String_Context* VerilogParser::PrimaryContext::string_() {
  return getRuleContext<VerilogParser::String_Context>(0);
}


size_t VerilogParser::PrimaryContext::getRuleIndex() const {
  return VerilogParser::RulePrimary;
}


std::any VerilogParser::PrimaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPrimary(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::PrimaryContext* VerilogParser::primary() {
  PrimaryContext *_localctx = _tracker.createInstance<PrimaryContext>(_ctx, getState());
  enterRule(_localctx, 638, VerilogParser::RulePrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4313);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4299);
      number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4300);
      hierarchical_identifier();
      setState(4302);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx)) {
      case 1: {
        setState(4301);
        select_();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4304);
      concatenation();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4305);
      multiple_concatenation();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4306);
      function_call();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4307);
      system_function_call();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4308);
      match(VerilogParser::LP);
      setState(4309);
      mintypmax_expression();
      setState(4310);
      match(VerilogParser::RP);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4312);
      string_();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_Context ------------------------------------------------------------------

VerilogParser::Select_Context::Select_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Select_Context::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Range_expressionContext* VerilogParser::Select_Context::range_expression() {
  return getRuleContext<VerilogParser::Range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Select_Context::RB() {
  return getToken(VerilogParser::RB, 0);
}

VerilogParser::Bit_selectContext* VerilogParser::Select_Context::bit_select() {
  return getRuleContext<VerilogParser::Bit_selectContext>(0);
}


size_t VerilogParser::Select_Context::getRuleIndex() const {
  return VerilogParser::RuleSelect_;
}


std::any VerilogParser::Select_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSelect_(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Select_Context* VerilogParser::select_() {
  Select_Context *_localctx = _tracker.createInstance<Select_Context>(_ctx, getState());
  enterRule(_localctx, 640, VerilogParser::RuleSelect_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4316);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx)) {
    case 1: {
      setState(4315);
      bit_select();
      break;
    }

    default:
      break;
    }
    setState(4318);
    match(VerilogParser::LB);
    setState(4319);
    range_expression();
    setState(4320);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bit_selectContext ------------------------------------------------------------------

VerilogParser::Bit_selectContext::Bit_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Bit_selectContext::LB() {
  return getTokens(VerilogParser::LB);
}

tree::TerminalNode* VerilogParser::Bit_selectContext::LB(size_t i) {
  return getToken(VerilogParser::LB, i);
}

std::vector<VerilogParser::ExpressionContext *> VerilogParser::Bit_selectContext::expression() {
  return getRuleContexts<VerilogParser::ExpressionContext>();
}

VerilogParser::ExpressionContext* VerilogParser::Bit_selectContext::expression(size_t i) {
  return getRuleContext<VerilogParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Bit_selectContext::RB() {
  return getTokens(VerilogParser::RB);
}

tree::TerminalNode* VerilogParser::Bit_selectContext::RB(size_t i) {
  return getToken(VerilogParser::RB, i);
}


size_t VerilogParser::Bit_selectContext::getRuleIndex() const {
  return VerilogParser::RuleBit_select;
}


std::any VerilogParser::Bit_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBit_select(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Bit_selectContext* VerilogParser::bit_select() {
  Bit_selectContext *_localctx = _tracker.createInstance<Bit_selectContext>(_ctx, getState());
  enterRule(_localctx, 642, VerilogParser::RuleBit_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4326); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4322);
              match(VerilogParser::LB);
              setState(4323);
              expression(0);
              setState(4324);
              match(VerilogParser::RB);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4328); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 449, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_lvalueContext ------------------------------------------------------------------

VerilogParser::Net_lvalueContext::Net_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Net_lvalueContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

VerilogParser::Const_selectContext* VerilogParser::Net_lvalueContext::const_select() {
  return getRuleContext<VerilogParser::Const_selectContext>(0);
}

tree::TerminalNode* VerilogParser::Net_lvalueContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Net_lvalueContext *> VerilogParser::Net_lvalueContext::net_lvalue() {
  return getRuleContexts<VerilogParser::Net_lvalueContext>();
}

VerilogParser::Net_lvalueContext* VerilogParser::Net_lvalueContext::net_lvalue(size_t i) {
  return getRuleContext<VerilogParser::Net_lvalueContext>(i);
}

tree::TerminalNode* VerilogParser::Net_lvalueContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Net_lvalueContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Net_lvalueContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Net_lvalueContext::getRuleIndex() const {
  return VerilogParser::RuleNet_lvalue;
}


std::any VerilogParser::Net_lvalueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_lvalue(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_lvalueContext* VerilogParser::net_lvalue() {
  Net_lvalueContext *_localctx = _tracker.createInstance<Net_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 644, VerilogParser::RuleNet_lvalue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4345);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(4330);
        hierarchical_identifier();
        setState(4332);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::LB) {
          setState(4331);
          const_select();
        }
        break;
      }

      case VerilogParser::LC: {
        enterOuterAlt(_localctx, 2);
        setState(4334);
        match(VerilogParser::LC);
        setState(4335);
        net_lvalue();
        setState(4340);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(4336);
          match(VerilogParser::CO);
          setState(4337);
          net_lvalue();
          setState(4342);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4343);
        match(VerilogParser::RC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_selectContext ------------------------------------------------------------------

VerilogParser::Const_selectContext::Const_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Const_selectContext::LB() {
  return getToken(VerilogParser::LB, 0);
}

VerilogParser::Constant_range_expressionContext* VerilogParser::Const_selectContext::constant_range_expression() {
  return getRuleContext<VerilogParser::Constant_range_expressionContext>(0);
}

tree::TerminalNode* VerilogParser::Const_selectContext::RB() {
  return getToken(VerilogParser::RB, 0);
}

VerilogParser::Const_bit_selectContext* VerilogParser::Const_selectContext::const_bit_select() {
  return getRuleContext<VerilogParser::Const_bit_selectContext>(0);
}


size_t VerilogParser::Const_selectContext::getRuleIndex() const {
  return VerilogParser::RuleConst_select;
}


std::any VerilogParser::Const_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConst_select(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Const_selectContext* VerilogParser::const_select() {
  Const_selectContext *_localctx = _tracker.createInstance<Const_selectContext>(_ctx, getState());
  enterRule(_localctx, 646, VerilogParser::RuleConst_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4348);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 453, _ctx)) {
    case 1: {
      setState(4347);
      const_bit_select();
      break;
    }

    default:
      break;
    }
    setState(4350);
    match(VerilogParser::LB);
    setState(4351);
    constant_range_expression();
    setState(4352);
    match(VerilogParser::RB);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_bit_selectContext ------------------------------------------------------------------

VerilogParser::Const_bit_selectContext::Const_bit_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> VerilogParser::Const_bit_selectContext::LB() {
  return getTokens(VerilogParser::LB);
}

tree::TerminalNode* VerilogParser::Const_bit_selectContext::LB(size_t i) {
  return getToken(VerilogParser::LB, i);
}

std::vector<VerilogParser::Constant_expressionContext *> VerilogParser::Const_bit_selectContext::constant_expression() {
  return getRuleContexts<VerilogParser::Constant_expressionContext>();
}

VerilogParser::Constant_expressionContext* VerilogParser::Const_bit_selectContext::constant_expression(size_t i) {
  return getRuleContext<VerilogParser::Constant_expressionContext>(i);
}

std::vector<tree::TerminalNode *> VerilogParser::Const_bit_selectContext::RB() {
  return getTokens(VerilogParser::RB);
}

tree::TerminalNode* VerilogParser::Const_bit_selectContext::RB(size_t i) {
  return getToken(VerilogParser::RB, i);
}


size_t VerilogParser::Const_bit_selectContext::getRuleIndex() const {
  return VerilogParser::RuleConst_bit_select;
}


std::any VerilogParser::Const_bit_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConst_bit_select(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Const_bit_selectContext* VerilogParser::const_bit_select() {
  Const_bit_selectContext *_localctx = _tracker.createInstance<Const_bit_selectContext>(_ctx, getState());
  enterRule(_localctx, 648, VerilogParser::RuleConst_bit_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4358); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(4354);
              match(VerilogParser::LB);
              setState(4355);
              constant_expression(0);
              setState(4356);
              match(VerilogParser::RB);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(4360); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 454, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_lvalueContext ------------------------------------------------------------------

VerilogParser::Variable_lvalueContext::Variable_lvalueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::Variable_lvalueContext::hierarchical_identifier() {
  return getRuleContext<VerilogParser::Hierarchical_identifierContext>(0);
}

VerilogParser::Select_Context* VerilogParser::Variable_lvalueContext::select_() {
  return getRuleContext<VerilogParser::Select_Context>(0);
}

tree::TerminalNode* VerilogParser::Variable_lvalueContext::LC() {
  return getToken(VerilogParser::LC, 0);
}

std::vector<VerilogParser::Variable_lvalueContext *> VerilogParser::Variable_lvalueContext::variable_lvalue() {
  return getRuleContexts<VerilogParser::Variable_lvalueContext>();
}

VerilogParser::Variable_lvalueContext* VerilogParser::Variable_lvalueContext::variable_lvalue(size_t i) {
  return getRuleContext<VerilogParser::Variable_lvalueContext>(i);
}

tree::TerminalNode* VerilogParser::Variable_lvalueContext::RC() {
  return getToken(VerilogParser::RC, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Variable_lvalueContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Variable_lvalueContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Variable_lvalueContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_lvalue;
}


std::any VerilogParser::Variable_lvalueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_lvalue(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_lvalueContext* VerilogParser::variable_lvalue() {
  Variable_lvalueContext *_localctx = _tracker.createInstance<Variable_lvalueContext>(_ctx, getState());
  enterRule(_localctx, 650, VerilogParser::RuleVariable_lvalue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4377);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER:
      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(4362);
        hierarchical_identifier();
        setState(4364);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == VerilogParser::LB) {
          setState(4363);
          select_();
        }
        break;
      }

      case VerilogParser::LC: {
        enterOuterAlt(_localctx, 2);
        setState(4366);
        match(VerilogParser::LC);
        setState(4367);
        variable_lvalue();
        setState(4372);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == VerilogParser::CO) {
          setState(4368);
          match(VerilogParser::CO);
          setState(4369);
          variable_lvalue();
          setState(4374);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(4375);
        match(VerilogParser::RC);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_operatorContext ------------------------------------------------------------------

VerilogParser::Unary_operatorContext::Unary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::PL() {
  return getToken(VerilogParser::PL, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::MI() {
  return getToken(VerilogParser::MI, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::EM() {
  return getToken(VerilogParser::EM, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TI() {
  return getToken(VerilogParser::TI, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TIAM() {
  return getToken(VerilogParser::TIAM, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TIVL() {
  return getToken(VerilogParser::TIVL, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Unary_operatorContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}


size_t VerilogParser::Unary_operatorContext::getRuleIndex() const {
  return VerilogParser::RuleUnary_operator;
}


std::any VerilogParser::Unary_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUnary_operator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Unary_operatorContext* VerilogParser::unary_operator() {
  Unary_operatorContext *_localctx = _tracker.createInstance<Unary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 652, VerilogParser::RuleUnary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4379);
    _la = _input->LA(1);
    if (!(((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281474977824772) != 0 || (((_la - 103) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 103)) & 6629298651489632257) != 0 || _la == VerilogParser::VL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_module_path_operatorContext ------------------------------------------------------------------

VerilogParser::Unary_module_path_operatorContext::Unary_module_path_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::EM() {
  return getToken(VerilogParser::EM, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TI() {
  return getToken(VerilogParser::TI, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::AM() {
  return getToken(VerilogParser::AM, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TIAM() {
  return getToken(VerilogParser::TIAM, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::VL() {
  return getToken(VerilogParser::VL, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TIVL() {
  return getToken(VerilogParser::TIVL, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::CA() {
  return getToken(VerilogParser::CA, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::TICA() {
  return getToken(VerilogParser::TICA, 0);
}

tree::TerminalNode* VerilogParser::Unary_module_path_operatorContext::CATI() {
  return getToken(VerilogParser::CATI, 0);
}


size_t VerilogParser::Unary_module_path_operatorContext::getRuleIndex() const {
  return VerilogParser::RuleUnary_module_path_operator;
}


std::any VerilogParser::Unary_module_path_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUnary_module_path_operator(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Unary_module_path_operatorContext* VerilogParser::unary_module_path_operator() {
  Unary_module_path_operatorContext *_localctx = _tracker.createInstance<Unary_module_path_operatorContext>(_ctx, getState());
  enterRule(_localctx, 654, VerilogParser::RuleUnary_module_path_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4381);
    _la = _input->LA(1);
    if (!(((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 281474977824772) != 0 || (((_la - 161) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 161)) & 131095) != 0)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

VerilogParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Decimal_numberContext* VerilogParser::NumberContext::decimal_number() {
  return getRuleContext<VerilogParser::Decimal_numberContext>(0);
}

VerilogParser::Octal_numberContext* VerilogParser::NumberContext::octal_number() {
  return getRuleContext<VerilogParser::Octal_numberContext>(0);
}

VerilogParser::Binary_numberContext* VerilogParser::NumberContext::binary_number() {
  return getRuleContext<VerilogParser::Binary_numberContext>(0);
}

VerilogParser::Hex_numberContext* VerilogParser::NumberContext::hex_number() {
  return getRuleContext<VerilogParser::Hex_numberContext>(0);
}

VerilogParser::Real_numberContext* VerilogParser::NumberContext::real_number() {
  return getRuleContext<VerilogParser::Real_numberContext>(0);
}


size_t VerilogParser::NumberContext::getRuleIndex() const {
  return VerilogParser::RuleNumber;
}


std::any VerilogParser::NumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNumber(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::NumberContext* VerilogParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 656, VerilogParser::RuleNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4388);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 458, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4383);
      decimal_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4384);
      octal_number();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4385);
      binary_number();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4386);
      hex_number();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4387);
      real_number();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_numberContext ------------------------------------------------------------------

VerilogParser::Real_numberContext::Real_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Fixed_point_numberContext* VerilogParser::Real_numberContext::fixed_point_number() {
  return getRuleContext<VerilogParser::Fixed_point_numberContext>(0);
}

VerilogParser::Exponential_numberContext* VerilogParser::Real_numberContext::exponential_number() {
  return getRuleContext<VerilogParser::Exponential_numberContext>(0);
}


size_t VerilogParser::Real_numberContext::getRuleIndex() const {
  return VerilogParser::RuleReal_number;
}


std::any VerilogParser::Real_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_numberContext* VerilogParser::real_number() {
  Real_numberContext *_localctx = _tracker.createInstance<Real_numberContext>(_ctx, getState());
  enterRule(_localctx, 658, VerilogParser::RuleReal_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4392);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::FIXED_POINT_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(4390);
        fixed_point_number();
        break;
      }

      case VerilogParser::EXPONENTIAL_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(4391);
        exponential_number();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decimal_numberContext ------------------------------------------------------------------

VerilogParser::Decimal_numberContext::Decimal_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Unsigned_numberContext* VerilogParser::Decimal_numberContext::unsigned_number() {
  return getRuleContext<VerilogParser::Unsigned_numberContext>(0);
}

VerilogParser::Decimal_baseContext* VerilogParser::Decimal_numberContext::decimal_base() {
  return getRuleContext<VerilogParser::Decimal_baseContext>(0);
}

VerilogParser::Decimal_valueContext* VerilogParser::Decimal_numberContext::decimal_value() {
  return getRuleContext<VerilogParser::Decimal_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Decimal_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Decimal_numberContext::getRuleIndex() const {
  return VerilogParser::RuleDecimal_number;
}


std::any VerilogParser::Decimal_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDecimal_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Decimal_numberContext* VerilogParser::decimal_number() {
  Decimal_numberContext *_localctx = _tracker.createInstance<Decimal_numberContext>(_ctx, getState());
  enterRule(_localctx, 660, VerilogParser::RuleDecimal_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4401);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 461, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4394);
      unsigned_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4396);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == VerilogParser::UNSIGNED_NUMBER) {
        setState(4395);
        size();
      }
      setState(4398);
      decimal_base();
      setState(4399);
      decimal_value();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_numberContext ------------------------------------------------------------------

VerilogParser::Binary_numberContext::Binary_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Binary_baseContext* VerilogParser::Binary_numberContext::binary_base() {
  return getRuleContext<VerilogParser::Binary_baseContext>(0);
}

VerilogParser::Binary_valueContext* VerilogParser::Binary_numberContext::binary_value() {
  return getRuleContext<VerilogParser::Binary_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Binary_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Binary_numberContext::getRuleIndex() const {
  return VerilogParser::RuleBinary_number;
}


std::any VerilogParser::Binary_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBinary_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Binary_numberContext* VerilogParser::binary_number() {
  Binary_numberContext *_localctx = _tracker.createInstance<Binary_numberContext>(_ctx, getState());
  enterRule(_localctx, 662, VerilogParser::RuleBinary_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4404);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::UNSIGNED_NUMBER) {
      setState(4403);
      size();
    }
    setState(4406);
    binary_base();
    setState(4407);
    binary_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Octal_numberContext ------------------------------------------------------------------

VerilogParser::Octal_numberContext::Octal_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Octal_baseContext* VerilogParser::Octal_numberContext::octal_base() {
  return getRuleContext<VerilogParser::Octal_baseContext>(0);
}

VerilogParser::Octal_valueContext* VerilogParser::Octal_numberContext::octal_value() {
  return getRuleContext<VerilogParser::Octal_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Octal_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Octal_numberContext::getRuleIndex() const {
  return VerilogParser::RuleOctal_number;
}


std::any VerilogParser::Octal_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOctal_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Octal_numberContext* VerilogParser::octal_number() {
  Octal_numberContext *_localctx = _tracker.createInstance<Octal_numberContext>(_ctx, getState());
  enterRule(_localctx, 664, VerilogParser::RuleOctal_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4410);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::UNSIGNED_NUMBER) {
      setState(4409);
      size();
    }
    setState(4412);
    octal_base();
    setState(4413);
    octal_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hex_numberContext ------------------------------------------------------------------

VerilogParser::Hex_numberContext::Hex_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Hex_baseContext* VerilogParser::Hex_numberContext::hex_base() {
  return getRuleContext<VerilogParser::Hex_baseContext>(0);
}

VerilogParser::Hex_valueContext* VerilogParser::Hex_numberContext::hex_value() {
  return getRuleContext<VerilogParser::Hex_valueContext>(0);
}

VerilogParser::SizeContext* VerilogParser::Hex_numberContext::size() {
  return getRuleContext<VerilogParser::SizeContext>(0);
}


size_t VerilogParser::Hex_numberContext::getRuleIndex() const {
  return VerilogParser::RuleHex_number;
}


std::any VerilogParser::Hex_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHex_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hex_numberContext* VerilogParser::hex_number() {
  Hex_numberContext *_localctx = _tracker.createInstance<Hex_numberContext>(_ctx, getState());
  enterRule(_localctx, 666, VerilogParser::RuleHex_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4416);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::UNSIGNED_NUMBER) {
      setState(4415);
      size();
    }
    setState(4418);
    hex_base();
    setState(4419);
    hex_value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeContext ------------------------------------------------------------------

VerilogParser::SizeContext::SizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::SizeContext::UNSIGNED_NUMBER() {
  return getToken(VerilogParser::UNSIGNED_NUMBER, 0);
}


size_t VerilogParser::SizeContext::getRuleIndex() const {
  return VerilogParser::RuleSize;
}


std::any VerilogParser::SizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSize(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::SizeContext* VerilogParser::size() {
  SizeContext *_localctx = _tracker.createInstance<SizeContext>(_ctx, getState());
  enterRule(_localctx, 668, VerilogParser::RuleSize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4421);
    match(VerilogParser::UNSIGNED_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fixed_point_numberContext ------------------------------------------------------------------

VerilogParser::Fixed_point_numberContext::Fixed_point_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Fixed_point_numberContext::FIXED_POINT_NUMBER() {
  return getToken(VerilogParser::FIXED_POINT_NUMBER, 0);
}


size_t VerilogParser::Fixed_point_numberContext::getRuleIndex() const {
  return VerilogParser::RuleFixed_point_number;
}


std::any VerilogParser::Fixed_point_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFixed_point_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Fixed_point_numberContext* VerilogParser::fixed_point_number() {
  Fixed_point_numberContext *_localctx = _tracker.createInstance<Fixed_point_numberContext>(_ctx, getState());
  enterRule(_localctx, 670, VerilogParser::RuleFixed_point_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4423);
    match(VerilogParser::FIXED_POINT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Exponential_numberContext ------------------------------------------------------------------

VerilogParser::Exponential_numberContext::Exponential_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Exponential_numberContext::EXPONENTIAL_NUMBER() {
  return getToken(VerilogParser::EXPONENTIAL_NUMBER, 0);
}


size_t VerilogParser::Exponential_numberContext::getRuleIndex() const {
  return VerilogParser::RuleExponential_number;
}


std::any VerilogParser::Exponential_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitExponential_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Exponential_numberContext* VerilogParser::exponential_number() {
  Exponential_numberContext *_localctx = _tracker.createInstance<Exponential_numberContext>(_ctx, getState());
  enterRule(_localctx, 672, VerilogParser::RuleExponential_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4425);
    match(VerilogParser::EXPONENTIAL_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unsigned_numberContext ------------------------------------------------------------------

VerilogParser::Unsigned_numberContext::Unsigned_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Unsigned_numberContext::UNSIGNED_NUMBER() {
  return getToken(VerilogParser::UNSIGNED_NUMBER, 0);
}


size_t VerilogParser::Unsigned_numberContext::getRuleIndex() const {
  return VerilogParser::RuleUnsigned_number;
}


std::any VerilogParser::Unsigned_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUnsigned_number(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Unsigned_numberContext* VerilogParser::unsigned_number() {
  Unsigned_numberContext *_localctx = _tracker.createInstance<Unsigned_numberContext>(_ctx, getState());
  enterRule(_localctx, 674, VerilogParser::RuleUnsigned_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4427);
    match(VerilogParser::UNSIGNED_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decimal_valueContext ------------------------------------------------------------------

VerilogParser::Decimal_valueContext::Decimal_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Decimal_valueContext::UNSIGNED_NUMBER() {
  return getToken(VerilogParser::UNSIGNED_NUMBER, 0);
}

tree::TerminalNode* VerilogParser::Decimal_valueContext::X_OR_Z_UNDERSCORE() {
  return getToken(VerilogParser::X_OR_Z_UNDERSCORE, 0);
}


size_t VerilogParser::Decimal_valueContext::getRuleIndex() const {
  return VerilogParser::RuleDecimal_value;
}


std::any VerilogParser::Decimal_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDecimal_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Decimal_valueContext* VerilogParser::decimal_value() {
  Decimal_valueContext *_localctx = _tracker.createInstance<Decimal_valueContext>(_ctx, getState());
  enterRule(_localctx, 676, VerilogParser::RuleDecimal_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4429);
    _la = _input->LA(1);
    if (!(_la == VerilogParser::UNSIGNED_NUMBER

    || _la == VerilogParser::X_OR_Z_UNDERSCORE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_valueContext ------------------------------------------------------------------

VerilogParser::Binary_valueContext::Binary_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Binary_valueContext::BINARY_VALUE() {
  return getToken(VerilogParser::BINARY_VALUE, 0);
}


size_t VerilogParser::Binary_valueContext::getRuleIndex() const {
  return VerilogParser::RuleBinary_value;
}


std::any VerilogParser::Binary_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBinary_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Binary_valueContext* VerilogParser::binary_value() {
  Binary_valueContext *_localctx = _tracker.createInstance<Binary_valueContext>(_ctx, getState());
  enterRule(_localctx, 678, VerilogParser::RuleBinary_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4431);
    match(VerilogParser::BINARY_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Octal_valueContext ------------------------------------------------------------------

VerilogParser::Octal_valueContext::Octal_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Octal_valueContext::OCTAL_VALUE() {
  return getToken(VerilogParser::OCTAL_VALUE, 0);
}


size_t VerilogParser::Octal_valueContext::getRuleIndex() const {
  return VerilogParser::RuleOctal_value;
}


std::any VerilogParser::Octal_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOctal_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Octal_valueContext* VerilogParser::octal_value() {
  Octal_valueContext *_localctx = _tracker.createInstance<Octal_valueContext>(_ctx, getState());
  enterRule(_localctx, 680, VerilogParser::RuleOctal_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4433);
    match(VerilogParser::OCTAL_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hex_valueContext ------------------------------------------------------------------

VerilogParser::Hex_valueContext::Hex_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Hex_valueContext::HEX_VALUE() {
  return getToken(VerilogParser::HEX_VALUE, 0);
}


size_t VerilogParser::Hex_valueContext::getRuleIndex() const {
  return VerilogParser::RuleHex_value;
}


std::any VerilogParser::Hex_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHex_value(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hex_valueContext* VerilogParser::hex_value() {
  Hex_valueContext *_localctx = _tracker.createInstance<Hex_valueContext>(_ctx, getState());
  enterRule(_localctx, 682, VerilogParser::RuleHex_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4435);
    match(VerilogParser::HEX_VALUE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Decimal_baseContext ------------------------------------------------------------------

VerilogParser::Decimal_baseContext::Decimal_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Decimal_baseContext::DECIMAL_BASE() {
  return getToken(VerilogParser::DECIMAL_BASE, 0);
}


size_t VerilogParser::Decimal_baseContext::getRuleIndex() const {
  return VerilogParser::RuleDecimal_base;
}


std::any VerilogParser::Decimal_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitDecimal_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Decimal_baseContext* VerilogParser::decimal_base() {
  Decimal_baseContext *_localctx = _tracker.createInstance<Decimal_baseContext>(_ctx, getState());
  enterRule(_localctx, 684, VerilogParser::RuleDecimal_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4437);
    match(VerilogParser::DECIMAL_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Binary_baseContext ------------------------------------------------------------------

VerilogParser::Binary_baseContext::Binary_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Binary_baseContext::BINARY_BASE() {
  return getToken(VerilogParser::BINARY_BASE, 0);
}


size_t VerilogParser::Binary_baseContext::getRuleIndex() const {
  return VerilogParser::RuleBinary_base;
}


std::any VerilogParser::Binary_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBinary_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Binary_baseContext* VerilogParser::binary_base() {
  Binary_baseContext *_localctx = _tracker.createInstance<Binary_baseContext>(_ctx, getState());
  enterRule(_localctx, 686, VerilogParser::RuleBinary_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4439);
    match(VerilogParser::BINARY_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Octal_baseContext ------------------------------------------------------------------

VerilogParser::Octal_baseContext::Octal_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Octal_baseContext::OCTAL_BASE() {
  return getToken(VerilogParser::OCTAL_BASE, 0);
}


size_t VerilogParser::Octal_baseContext::getRuleIndex() const {
  return VerilogParser::RuleOctal_base;
}


std::any VerilogParser::Octal_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOctal_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Octal_baseContext* VerilogParser::octal_base() {
  Octal_baseContext *_localctx = _tracker.createInstance<Octal_baseContext>(_ctx, getState());
  enterRule(_localctx, 688, VerilogParser::RuleOctal_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4441);
    match(VerilogParser::OCTAL_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hex_baseContext ------------------------------------------------------------------

VerilogParser::Hex_baseContext::Hex_baseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Hex_baseContext::HEX_BASE() {
  return getToken(VerilogParser::HEX_BASE, 0);
}


size_t VerilogParser::Hex_baseContext::getRuleIndex() const {
  return VerilogParser::RuleHex_base;
}


std::any VerilogParser::Hex_baseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHex_base(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hex_baseContext* VerilogParser::hex_base() {
  Hex_baseContext *_localctx = _tracker.createInstance<Hex_baseContext>(_ctx, getState());
  enterRule(_localctx, 690, VerilogParser::RuleHex_base);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4443);
    match(VerilogParser::HEX_BASE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- String_Context ------------------------------------------------------------------

VerilogParser::String_Context::String_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::String_Context::STRING() {
  return getToken(VerilogParser::STRING, 0);
}


size_t VerilogParser::String_Context::getRuleIndex() const {
  return VerilogParser::RuleString_;
}


std::any VerilogParser::String_Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitString_(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::String_Context* VerilogParser::string_() {
  String_Context *_localctx = _tracker.createInstance<String_Context>(_ctx, getState());
  enterRule(_localctx, 692, VerilogParser::RuleString_);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4445);
    match(VerilogParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attribute_instanceContext ------------------------------------------------------------------

VerilogParser::Attribute_instanceContext::Attribute_instanceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::LP() {
  return getToken(VerilogParser::LP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Attribute_instanceContext::AS() {
  return getTokens(VerilogParser::AS);
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::AS(size_t i) {
  return getToken(VerilogParser::AS, i);
}

std::vector<VerilogParser::Attr_specContext *> VerilogParser::Attribute_instanceContext::attr_spec() {
  return getRuleContexts<VerilogParser::Attr_specContext>();
}

VerilogParser::Attr_specContext* VerilogParser::Attribute_instanceContext::attr_spec(size_t i) {
  return getRuleContext<VerilogParser::Attr_specContext>(i);
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::RP() {
  return getToken(VerilogParser::RP, 0);
}

std::vector<tree::TerminalNode *> VerilogParser::Attribute_instanceContext::CO() {
  return getTokens(VerilogParser::CO);
}

tree::TerminalNode* VerilogParser::Attribute_instanceContext::CO(size_t i) {
  return getToken(VerilogParser::CO, i);
}


size_t VerilogParser::Attribute_instanceContext::getRuleIndex() const {
  return VerilogParser::RuleAttribute_instance;
}


std::any VerilogParser::Attribute_instanceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAttribute_instance(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Attribute_instanceContext* VerilogParser::attribute_instance() {
  Attribute_instanceContext *_localctx = _tracker.createInstance<Attribute_instanceContext>(_ctx, getState());
  enterRule(_localctx, 694, VerilogParser::RuleAttribute_instance);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4447);
    match(VerilogParser::LP);
    setState(4448);
    match(VerilogParser::AS);
    setState(4449);
    attr_spec();
    setState(4454);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == VerilogParser::CO) {
      setState(4450);
      match(VerilogParser::CO);
      setState(4451);
      attr_spec();
      setState(4456);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4457);
    match(VerilogParser::AS);
    setState(4458);
    match(VerilogParser::RP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attr_specContext ------------------------------------------------------------------

VerilogParser::Attr_specContext::Attr_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Attr_nameContext* VerilogParser::Attr_specContext::attr_name() {
  return getRuleContext<VerilogParser::Attr_nameContext>(0);
}

tree::TerminalNode* VerilogParser::Attr_specContext::EQ() {
  return getToken(VerilogParser::EQ, 0);
}

VerilogParser::Constant_expressionContext* VerilogParser::Attr_specContext::constant_expression() {
  return getRuleContext<VerilogParser::Constant_expressionContext>(0);
}


size_t VerilogParser::Attr_specContext::getRuleIndex() const {
  return VerilogParser::RuleAttr_spec;
}


std::any VerilogParser::Attr_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAttr_spec(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Attr_specContext* VerilogParser::attr_spec() {
  Attr_specContext *_localctx = _tracker.createInstance<Attr_specContext>(_ctx, getState());
  enterRule(_localctx, 696, VerilogParser::RuleAttr_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4460);
    attr_name();
    setState(4463);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::EQ) {
      setState(4461);
      match(VerilogParser::EQ);
      setState(4462);
      constant_expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attr_nameContext ------------------------------------------------------------------

VerilogParser::Attr_nameContext::Attr_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Attr_nameContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Attr_nameContext::getRuleIndex() const {
  return VerilogParser::RuleAttr_name;
}


std::any VerilogParser::Attr_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitAttr_name(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Attr_nameContext* VerilogParser::attr_name() {
  Attr_nameContext *_localctx = _tracker.createInstance<Attr_nameContext>(_ctx, getState());
  enterRule(_localctx, 698, VerilogParser::RuleAttr_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4465);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Block_identifierContext ------------------------------------------------------------------

VerilogParser::Block_identifierContext::Block_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Block_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Block_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleBlock_identifier;
}


std::any VerilogParser::Block_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitBlock_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Block_identifierContext* VerilogParser::block_identifier() {
  Block_identifierContext *_localctx = _tracker.createInstance<Block_identifierContext>(_ctx, getState());
  enterRule(_localctx, 700, VerilogParser::RuleBlock_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4467);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cell_identifierContext ------------------------------------------------------------------

VerilogParser::Cell_identifierContext::Cell_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Cell_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Cell_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleCell_identifier;
}


std::any VerilogParser::Cell_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitCell_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Cell_identifierContext* VerilogParser::cell_identifier() {
  Cell_identifierContext *_localctx = _tracker.createInstance<Cell_identifierContext>(_ctx, getState());
  enterRule(_localctx, 702, VerilogParser::RuleCell_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4469);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Config_identifierContext ------------------------------------------------------------------

VerilogParser::Config_identifierContext::Config_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Config_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Config_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleConfig_identifier;
}


std::any VerilogParser::Config_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitConfig_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Config_identifierContext* VerilogParser::config_identifier() {
  Config_identifierContext *_localctx = _tracker.createInstance<Config_identifierContext>(_ctx, getState());
  enterRule(_localctx, 704, VerilogParser::RuleConfig_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4471);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Escaped_identifierContext ------------------------------------------------------------------

VerilogParser::Escaped_identifierContext::Escaped_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Escaped_identifierContext::ESCAPED_IDENTIFIER() {
  return getToken(VerilogParser::ESCAPED_IDENTIFIER, 0);
}


size_t VerilogParser::Escaped_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleEscaped_identifier;
}


std::any VerilogParser::Escaped_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEscaped_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Escaped_identifierContext* VerilogParser::escaped_identifier() {
  Escaped_identifierContext *_localctx = _tracker.createInstance<Escaped_identifierContext>(_ctx, getState());
  enterRule(_localctx, 706, VerilogParser::RuleEscaped_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4473);
    match(VerilogParser::ESCAPED_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Event_identifierContext ------------------------------------------------------------------

VerilogParser::Event_identifierContext::Event_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Event_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Event_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleEvent_identifier;
}


std::any VerilogParser::Event_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitEvent_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Event_identifierContext* VerilogParser::event_identifier() {
  Event_identifierContext *_localctx = _tracker.createInstance<Event_identifierContext>(_ctx, getState());
  enterRule(_localctx, 708, VerilogParser::RuleEvent_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4475);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_identifierContext ------------------------------------------------------------------

VerilogParser::Function_identifierContext::Function_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Function_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Function_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleFunction_identifier;
}


std::any VerilogParser::Function_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitFunction_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Function_identifierContext* VerilogParser::function_identifier() {
  Function_identifierContext *_localctx = _tracker.createInstance<Function_identifierContext>(_ctx, getState());
  enterRule(_localctx, 710, VerilogParser::RuleFunction_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4477);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Gate_instance_identifierContext ------------------------------------------------------------------

VerilogParser::Gate_instance_identifierContext::Gate_instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Gate_instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Gate_instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleGate_instance_identifier;
}


std::any VerilogParser::Gate_instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGate_instance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Gate_instance_identifierContext* VerilogParser::gate_instance_identifier() {
  Gate_instance_identifierContext *_localctx = _tracker.createInstance<Gate_instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 712, VerilogParser::RuleGate_instance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4479);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Generate_block_identifierContext ------------------------------------------------------------------

VerilogParser::Generate_block_identifierContext::Generate_block_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Generate_block_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Generate_block_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleGenerate_block_identifier;
}


std::any VerilogParser::Generate_block_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenerate_block_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Generate_block_identifierContext* VerilogParser::generate_block_identifier() {
  Generate_block_identifierContext *_localctx = _tracker.createInstance<Generate_block_identifierContext>(_ctx, getState());
  enterRule(_localctx, 714, VerilogParser::RuleGenerate_block_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4481);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Genvar_identifierContext ------------------------------------------------------------------

VerilogParser::Genvar_identifierContext::Genvar_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Genvar_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Genvar_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleGenvar_identifier;
}


std::any VerilogParser::Genvar_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitGenvar_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Genvar_identifierContext* VerilogParser::genvar_identifier() {
  Genvar_identifierContext *_localctx = _tracker.createInstance<Genvar_identifierContext>(_ctx, getState());
  enterRule(_localctx, 716, VerilogParser::RuleGenvar_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4483);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hierarchical_identifierContext ------------------------------------------------------------------

VerilogParser::Hierarchical_identifierContext::Hierarchical_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Hierarchical_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

std::vector<VerilogParser::Hier_refContext *> VerilogParser::Hierarchical_identifierContext::hier_ref() {
  return getRuleContexts<VerilogParser::Hier_refContext>();
}

VerilogParser::Hier_refContext* VerilogParser::Hierarchical_identifierContext::hier_ref(size_t i) {
  return getRuleContext<VerilogParser::Hier_refContext>(i);
}


size_t VerilogParser::Hierarchical_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleHierarchical_identifier;
}


std::any VerilogParser::Hierarchical_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHierarchical_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hierarchical_identifierContext* VerilogParser::hierarchical_identifier() {
  Hierarchical_identifierContext *_localctx = _tracker.createInstance<Hierarchical_identifierContext>(_ctx, getState());
  enterRule(_localctx, 718, VerilogParser::RuleHierarchical_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4488);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 467, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4485);
        hier_ref(); 
      }
      setState(4490);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 467, _ctx);
    }
    setState(4491);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Hier_refContext ------------------------------------------------------------------

VerilogParser::Hier_refContext::Hier_refContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Hier_refContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}

tree::TerminalNode* VerilogParser::Hier_refContext::DT() {
  return getToken(VerilogParser::DT, 0);
}

VerilogParser::Const_bit_selectContext* VerilogParser::Hier_refContext::const_bit_select() {
  return getRuleContext<VerilogParser::Const_bit_selectContext>(0);
}


size_t VerilogParser::Hier_refContext::getRuleIndex() const {
  return VerilogParser::RuleHier_ref;
}


std::any VerilogParser::Hier_refContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitHier_ref(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Hier_refContext* VerilogParser::hier_ref() {
  Hier_refContext *_localctx = _tracker.createInstance<Hier_refContext>(_ctx, getState());
  enterRule(_localctx, 720, VerilogParser::RuleHier_ref);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4493);
    identifier();
    setState(4495);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == VerilogParser::LB) {
      setState(4494);
      const_bit_select();
    }
    setState(4497);
    match(VerilogParser::DT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

VerilogParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::Escaped_identifierContext* VerilogParser::IdentifierContext::escaped_identifier() {
  return getRuleContext<VerilogParser::Escaped_identifierContext>(0);
}

VerilogParser::Simple_identifierContext* VerilogParser::IdentifierContext::simple_identifier() {
  return getRuleContext<VerilogParser::Simple_identifierContext>(0);
}


size_t VerilogParser::IdentifierContext::getRuleIndex() const {
  return VerilogParser::RuleIdentifier;
}


std::any VerilogParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::IdentifierContext* VerilogParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 722, VerilogParser::RuleIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4501);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case VerilogParser::ESCAPED_IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(4499);
        escaped_identifier();
        break;
      }

      case VerilogParser::SIMPLE_IDENTIFIER: {
        enterOuterAlt(_localctx, 2);
        setState(4500);
        simple_identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Input_port_identifierContext ------------------------------------------------------------------

VerilogParser::Input_port_identifierContext::Input_port_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Input_port_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Input_port_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleInput_port_identifier;
}


std::any VerilogParser::Input_port_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInput_port_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Input_port_identifierContext* VerilogParser::input_port_identifier() {
  Input_port_identifierContext *_localctx = _tracker.createInstance<Input_port_identifierContext>(_ctx, getState());
  enterRule(_localctx, 724, VerilogParser::RuleInput_port_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4503);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Instance_identifierContext ------------------------------------------------------------------

VerilogParser::Instance_identifierContext::Instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleInstance_identifier;
}


std::any VerilogParser::Instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitInstance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Instance_identifierContext* VerilogParser::instance_identifier() {
  Instance_identifierContext *_localctx = _tracker.createInstance<Instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 726, VerilogParser::RuleInstance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4505);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Library_identifierContext ------------------------------------------------------------------

VerilogParser::Library_identifierContext::Library_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Library_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Library_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleLibrary_identifier;
}


std::any VerilogParser::Library_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitLibrary_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Library_identifierContext* VerilogParser::library_identifier() {
  Library_identifierContext *_localctx = _tracker.createInstance<Library_identifierContext>(_ctx, getState());
  enterRule(_localctx, 728, VerilogParser::RuleLibrary_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4507);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_identifierContext ------------------------------------------------------------------

VerilogParser::Module_identifierContext::Module_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Module_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Module_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleModule_identifier;
}


std::any VerilogParser::Module_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_identifierContext* VerilogParser::module_identifier() {
  Module_identifierContext *_localctx = _tracker.createInstance<Module_identifierContext>(_ctx, getState());
  enterRule(_localctx, 730, VerilogParser::RuleModule_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4509);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_instance_identifierContext ------------------------------------------------------------------

VerilogParser::Module_instance_identifierContext::Module_instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Module_instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Module_instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleModule_instance_identifier;
}


std::any VerilogParser::Module_instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitModule_instance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Module_instance_identifierContext* VerilogParser::module_instance_identifier() {
  Module_instance_identifierContext *_localctx = _tracker.createInstance<Module_instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 732, VerilogParser::RuleModule_instance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4511);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Net_identifierContext ------------------------------------------------------------------

VerilogParser::Net_identifierContext::Net_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Net_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Net_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleNet_identifier;
}


std::any VerilogParser::Net_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitNet_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Net_identifierContext* VerilogParser::net_identifier() {
  Net_identifierContext *_localctx = _tracker.createInstance<Net_identifierContext>(_ctx, getState());
  enterRule(_localctx, 734, VerilogParser::RuleNet_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4513);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Output_port_identifierContext ------------------------------------------------------------------

VerilogParser::Output_port_identifierContext::Output_port_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Output_port_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Output_port_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleOutput_port_identifier;
}


std::any VerilogParser::Output_port_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitOutput_port_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Output_port_identifierContext* VerilogParser::output_port_identifier() {
  Output_port_identifierContext *_localctx = _tracker.createInstance<Output_port_identifierContext>(_ctx, getState());
  enterRule(_localctx, 736, VerilogParser::RuleOutput_port_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4515);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Parameter_identifierContext ------------------------------------------------------------------

VerilogParser::Parameter_identifierContext::Parameter_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Parameter_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Parameter_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleParameter_identifier;
}


std::any VerilogParser::Parameter_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitParameter_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Parameter_identifierContext* VerilogParser::parameter_identifier() {
  Parameter_identifierContext *_localctx = _tracker.createInstance<Parameter_identifierContext>(_ctx, getState());
  enterRule(_localctx, 738, VerilogParser::RuleParameter_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4517);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Port_identifierContext ------------------------------------------------------------------

VerilogParser::Port_identifierContext::Port_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Port_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Port_identifierContext::getRuleIndex() const {
  return VerilogParser::RulePort_identifier;
}


std::any VerilogParser::Port_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitPort_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Port_identifierContext* VerilogParser::port_identifier() {
  Port_identifierContext *_localctx = _tracker.createInstance<Port_identifierContext>(_ctx, getState());
  enterRule(_localctx, 740, VerilogParser::RulePort_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4519);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_identifierContext ------------------------------------------------------------------

VerilogParser::Real_identifierContext::Real_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Real_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Real_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleReal_identifier;
}


std::any VerilogParser::Real_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitReal_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Real_identifierContext* VerilogParser::real_identifier() {
  Real_identifierContext *_localctx = _tracker.createInstance<Real_identifierContext>(_ctx, getState());
  enterRule(_localctx, 742, VerilogParser::RuleReal_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4521);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_identifierContext ------------------------------------------------------------------

VerilogParser::Simple_identifierContext::Simple_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::Simple_identifierContext::SIMPLE_IDENTIFIER() {
  return getToken(VerilogParser::SIMPLE_IDENTIFIER, 0);
}


size_t VerilogParser::Simple_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSimple_identifier;
}


std::any VerilogParser::Simple_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSimple_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Simple_identifierContext* VerilogParser::simple_identifier() {
  Simple_identifierContext *_localctx = _tracker.createInstance<Simple_identifierContext>(_ctx, getState());
  enterRule(_localctx, 744, VerilogParser::RuleSimple_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4523);
    match(VerilogParser::SIMPLE_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Specparam_identifierContext ------------------------------------------------------------------

VerilogParser::Specparam_identifierContext::Specparam_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Specparam_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Specparam_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSpecparam_identifier;
}


std::any VerilogParser::Specparam_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSpecparam_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Specparam_identifierContext* VerilogParser::specparam_identifier() {
  Specparam_identifierContext *_localctx = _tracker.createInstance<Specparam_identifierContext>(_ctx, getState());
  enterRule(_localctx, 746, VerilogParser::RuleSpecparam_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4525);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_function_identifierContext ------------------------------------------------------------------

VerilogParser::System_function_identifierContext::System_function_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::System_function_identifierContext::SYSTEM_TF_IDENTIFIER() {
  return getToken(VerilogParser::SYSTEM_TF_IDENTIFIER, 0);
}


size_t VerilogParser::System_function_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_function_identifier;
}


std::any VerilogParser::System_function_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_function_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_function_identifierContext* VerilogParser::system_function_identifier() {
  System_function_identifierContext *_localctx = _tracker.createInstance<System_function_identifierContext>(_ctx, getState());
  enterRule(_localctx, 748, VerilogParser::RuleSystem_function_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4527);
    match(VerilogParser::SYSTEM_TF_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- System_task_identifierContext ------------------------------------------------------------------

VerilogParser::System_task_identifierContext::System_task_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* VerilogParser::System_task_identifierContext::SYSTEM_TF_IDENTIFIER() {
  return getToken(VerilogParser::SYSTEM_TF_IDENTIFIER, 0);
}


size_t VerilogParser::System_task_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleSystem_task_identifier;
}


std::any VerilogParser::System_task_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitSystem_task_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::System_task_identifierContext* VerilogParser::system_task_identifier() {
  System_task_identifierContext *_localctx = _tracker.createInstance<System_task_identifierContext>(_ctx, getState());
  enterRule(_localctx, 750, VerilogParser::RuleSystem_task_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4529);
    match(VerilogParser::SYSTEM_TF_IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Task_identifierContext ------------------------------------------------------------------

VerilogParser::Task_identifierContext::Task_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Task_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Task_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleTask_identifier;
}


std::any VerilogParser::Task_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTask_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Task_identifierContext* VerilogParser::task_identifier() {
  Task_identifierContext *_localctx = _tracker.createInstance<Task_identifierContext>(_ctx, getState());
  enterRule(_localctx, 752, VerilogParser::RuleTask_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4531);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Terminal_identifierContext ------------------------------------------------------------------

VerilogParser::Terminal_identifierContext::Terminal_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Terminal_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Terminal_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleTerminal_identifier;
}


std::any VerilogParser::Terminal_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTerminal_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Terminal_identifierContext* VerilogParser::terminal_identifier() {
  Terminal_identifierContext *_localctx = _tracker.createInstance<Terminal_identifierContext>(_ctx, getState());
  enterRule(_localctx, 754, VerilogParser::RuleTerminal_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4533);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Topmodule_identifierContext ------------------------------------------------------------------

VerilogParser::Topmodule_identifierContext::Topmodule_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Topmodule_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Topmodule_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleTopmodule_identifier;
}


std::any VerilogParser::Topmodule_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitTopmodule_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Topmodule_identifierContext* VerilogParser::topmodule_identifier() {
  Topmodule_identifierContext *_localctx = _tracker.createInstance<Topmodule_identifierContext>(_ctx, getState());
  enterRule(_localctx, 756, VerilogParser::RuleTopmodule_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4535);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_identifierContext ------------------------------------------------------------------

VerilogParser::Udp_identifierContext::Udp_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Udp_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Udp_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_identifier;
}


std::any VerilogParser::Udp_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_identifierContext* VerilogParser::udp_identifier() {
  Udp_identifierContext *_localctx = _tracker.createInstance<Udp_identifierContext>(_ctx, getState());
  enterRule(_localctx, 758, VerilogParser::RuleUdp_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4537);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Udp_instance_identifierContext ------------------------------------------------------------------

VerilogParser::Udp_instance_identifierContext::Udp_instance_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Udp_instance_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Udp_instance_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleUdp_instance_identifier;
}


std::any VerilogParser::Udp_instance_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitUdp_instance_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Udp_instance_identifierContext* VerilogParser::udp_instance_identifier() {
  Udp_instance_identifierContext *_localctx = _tracker.createInstance<Udp_instance_identifierContext>(_ctx, getState());
  enterRule(_localctx, 760, VerilogParser::RuleUdp_instance_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4539);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_identifierContext ------------------------------------------------------------------

VerilogParser::Variable_identifierContext::Variable_identifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

VerilogParser::IdentifierContext* VerilogParser::Variable_identifierContext::identifier() {
  return getRuleContext<VerilogParser::IdentifierContext>(0);
}


size_t VerilogParser::Variable_identifierContext::getRuleIndex() const {
  return VerilogParser::RuleVariable_identifier;
}


std::any VerilogParser::Variable_identifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<VerilogParserVisitor*>(visitor))
    return parserVisitor->visitVariable_identifier(this);
  else
    return visitor->visitChildren(this);
}

VerilogParser::Variable_identifierContext* VerilogParser::variable_identifier() {
  Variable_identifierContext *_localctx = _tracker.createInstance<Variable_identifierContext>(_ctx, getState());
  enterRule(_localctx, 762, VerilogParser::RuleVariable_identifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4541);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool VerilogParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 193: return event_expressionSempred(antlrcpp::downCast<Event_expressionContext *>(context), predicateIndex);
    case 305: return constant_expressionSempred(antlrcpp::downCast<Constant_expressionContext *>(context), predicateIndex);
    case 309: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 312: return module_path_expressionSempred(antlrcpp::downCast<Module_path_expressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool VerilogParser::event_expressionSempred(Event_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 2);
    case 1: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool VerilogParser::constant_expressionSempred(Constant_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 12);
    case 3: return precpred(_ctx, 11);
    case 4: return precpred(_ctx, 10);
    case 5: return precpred(_ctx, 9);
    case 6: return precpred(_ctx, 8);
    case 7: return precpred(_ctx, 7);
    case 8: return precpred(_ctx, 6);
    case 9: return precpred(_ctx, 5);
    case 10: return precpred(_ctx, 4);
    case 11: return precpred(_ctx, 3);
    case 12: return precpred(_ctx, 2);
    case 13: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool VerilogParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return precpred(_ctx, 12);
    case 15: return precpred(_ctx, 11);
    case 16: return precpred(_ctx, 10);
    case 17: return precpred(_ctx, 9);
    case 18: return precpred(_ctx, 8);
    case 19: return precpred(_ctx, 7);
    case 20: return precpred(_ctx, 6);
    case 21: return precpred(_ctx, 5);
    case 22: return precpred(_ctx, 4);
    case 23: return precpred(_ctx, 3);
    case 24: return precpred(_ctx, 2);
    case 25: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool VerilogParser::module_path_expressionSempred(Module_path_expressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 26: return precpred(_ctx, 7);
    case 27: return precpred(_ctx, 6);
    case 28: return precpred(_ctx, 5);
    case 29: return precpred(_ctx, 4);
    case 30: return precpred(_ctx, 3);
    case 31: return precpred(_ctx, 2);
    case 32: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void VerilogParser::initialize() {
  ::antlr4::internal::call_once(verilogparserParserOnceFlag, verilogparserParserInitialize);
}
